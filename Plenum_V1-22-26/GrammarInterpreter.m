(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["PlenumGI`","PDESolver`"]


(* <<Statistics`ContinuousDistributions` *)
(* <<Statistics`DiscreteDistributions`  *)
(* <<Graphics`Graphics3D` *)
(* <<Statistics`MultinormalDistribution` *)
(* <<Graphics`Graphics` *)

<<gyKDTree.m


(*commented out  in Version 21
<<mPower.m
Needs[ "Imtek`MultiGrid`" ]
Needs[ "Imtek`GeometricFDMSolver`" ]
*)


executeGrammar::"usage"="executeGrammar[gr_Grammar,init_,depth_,saveChoices_,opt___?OptionQ] - simulates the grammar"


createRealGrid::"usage"="createRealGrid[inGrid_,inGridBLPos_,inGridDelta_,opt___?OptionQ] - get a grid, the real BottomLeft position,grid delta, and it outputs the grid in real coordiantes. There's an option to plot 3d."


getSimulationStruct::"usage"="getSimulationStruct[] - returns the simulation structure"


loadSimulationStruct::"usage"="loadSimulationStruct[] - load the simulation structure"


grammarPDF::"usage"="grammarPDF..."


Grammar::"usage"="Grammar struct..."


with::"usage"="with..."


solving::"usage"="solving..."


where::"usage"="where..."


under::"usage"="under..."


grammarIndexOfElementInList::"usage"="grammarIndexOfElementInList..."


grammarNumElementsInList::"usage"="grammarNumElementsInList..."


grammarCreateObjectID::"usage"="grammarCreateObjectID..."


grammarDynamicObjID::"usage"="grammarDynamicObjID..."


grammarNumberOfDynamicObjID::"usage"="grammarNumberOfDynamicObjID..."


grammarDiscreteDistribution::"usage"="grammarDiscreteDistribution..."


grammarSigmoid::"usage"="grammarSigmoid[x_, t_]..."


grammarHillFunc::"usage"="grammarHillFunc[x_,thresh_,n_]..."


rules::"usage"="rules..."


spatialGrammar::"usage"="spatialGrammar..."


spatialObject::"usage"="spatialObject..."


spatialObjCoordParamters::"usage"="spatialObjCoordParamters..."


spatialObjParamters::"usage"="spatialObjParamters..."


spatialObjRadParam::"usage"="spatialObjRadParam..."


spatialObjDistance::"usage"="spatialObjDistance..."


spatialPlaneDistance::"usage"="spatialPlaneDistance..."


spatialYPlanes::"usage"="spatialYPlanes..."


gDiffusion::"usage"="gDiffusion grammar..."


gDiffVariable::"usage"="gDiffVariable..."


gDiffSpatialParamX::"usage"="gDiffSpatialParamX..."


gDiffSpatialParamY::"usage"="gDiffSpatialParamY..."


gDiffSpatialParamR::"usage"="gDiffSpatialParamR..."


gDiffDecay::"usage"="gDiffDecay..."


gDiffConstant::"usage"="gDiffConstant..."


gDiffDecayFunc::"usage"="gDiffDecayFunc..."


gDiffSource::"usage"="gDiffSource..."


gDiffBoundaryTypeLeft::"usage"="gDiffBoundaryTypeLeft..."


gDiffBoundaryTypeRight::"usage"="gDiffBoundaryTypeRight..."


gDiffBoundaryTypeBottom::"usage"="gDiffBoundaryTypeBottom..."


gDiffBoundaryTypeTop::"usage"="gDiffBoundaryTypeTop..."


gDiffBoundaryValLeft::"usage"="gDiffBoundaryValLeft..."


gDiffBoundaryValRight::"usage"="gDiffBoundaryValRight..."


gDiffBoundaryValBottom::"usage"="gDiffBoundaryValBottom..."


gDiffBoundaryValTop::"usage"="gDiffBoundaryValTop..."


(* User-supplied function: "g1DGrowthFunction:", and the following options (set below to default values) *)

Options[executeGrammar]={simStopCriteriaArr-> {},maxDerivationTimeBetweenSimSteps->\[Infinity], measureDynamics-> False,measureDynamicsForEveryDiscreteStep-> True,derivTimeToMeasureDynamics-> 0.001,timeBetweenMeasureDynamicsSteps-> 0.1 ,endIterationDisplayFunction-> False,maxTotalSimulationTime->\[Infinity],useDelayedRules-> False,useAcceleratedRules-> False,screenPoolItems-> {},arrSimulationTimePoints-> {},saveAllSimulation-> False,iterFunctionsHandle-> {},isStaticStructurePool-> False,multiGridLevel-> 5,pdeGridsIniVal-> {},pdeGridPosIniVal-> {},pdeGridSave-> False,pdeDeltaGrid-> 0.1,pdeDeltaTime-> 0.1,pdeBoundaryWidth-> 0,pdeSecretionDistributionOption-> 1(*1-Normal distribution,2-Uniform circle*)};


Options[createRealGrid] = {plotRealGrid-> False};


Begin["`Private`"]


(***********************Major changes for version 7******************************************)


(*
1. Handle the assignment of object in the LHS of a rule as a short notation.
	example  - 
{c1 == cell[param1a,param1b],c2 == cell[param2a,param2b]}-> {c1,c2}


2. Handle rules in the RHS - these rules will be executed according to their order over the whole pool.
		example - 
	{c1 == cell[id,param1,idNext]} -> {node[param1] , {cell[idPrev,param2,id],region[idStart,id]}-> {cell[idPrev,param2,idNext],region[idStart,idPrev]}, region[id,idEnd]-> region[idNext,idEnd], cell[idPrev,param2,id]-> cell[idPrev,param2,idNext]},
			with[param1]
		this rule kills the cell and replace it by a node element. The RHS rules are intended to fix the references of other elements when the cell is removed. Note that the rules are executed according to their order, so first the interpreter tries to find both a previous cell and a region and change them both. The third rule applies only if the first rule doesn't , meaning that there is no region refering to the cell.

A shorter version for this rule is the follwing using a recursive rule:
{c1 == cell[id,param1,idNext]} -> {node[param1] , cell[idPrev,param2,id]-> {cell[idPrev,param2,idNext],region[idStart,id]-> region[idStart,idPrev]}, region[id,idEnd]-> region[idNext,idEnd]},
			with[param1]

	Here the region rule is placed in the RHS of the previous cell rule. This is a short version for describing a rule where one element (region) might not exist but still we want to apply the rule for the other elements (previous cell). So instead of writing a rule for each combination we place the rules of the optional elements in the RHS of the required elements , and this can continue recursively.

Remark : since there are multiple elements in the rules and they are performed deterministicaly there could be conflics between different executions. We execute only one of those executionsbut then there is an issue of ambigiuity of which one to execute that will not depend on its order in the pool (pool configurations will depend on ordering in the pool). We can assume that the pool is always sorted alphabeticaly and therefore picking the first matching will be consistent every time and thus the pool configuration does not depend on the order of the elements. Or we can pick one of the executions in random and thus this is no longer deterministic operation but it will be consistent with the pool states. 

Remark 2 : In this version the rules are applied one after the other according to their order in the RHS set of rules. A rule will be applied over the pool in one iteration while all the new items created by the rule will be available only for the next rule and not during the current rule sweep. 
*) 


(*
new in this version is the use of EventLocator in NDSolve for finding the time that the next event (rule fire) happens. This can be use only in Mathematica 5.2 and above. NDSolve is 5 times faster that way , on a rough estimate. This is especially critical when we use sigmoid (and other non-linear) functions that causes extreme changes in the total rate.
*)


(*
RuleDelayed (:>)  : a continuous rule that will be applied only in the end of discrete events. The rule can have only algebraic equations. The equations are calculated before NDSolve at time 0 and then 'frozen' . This in order to reduce costly integrations of NDSolve that do not affect much the outcome of the discrete stochastic events.

useDelayedRules Option : The rules will be delayed only if useDelayedRules is True. If not then the delayed rules will be integrated as regular rules. The default is False.

Note that delayed rules will not work with rules that have complicated functions such that have reference to arrays. This is because the interpreter tries to differentiate the rate fuction for each parameter. So a parameter that is simply a reference to an array will cause a complex non-zero derivative . In that case create multiple rules for such a template rule.
see - gOEGrammarDelayed in oeGrammar1.nb for an example.

*)


(***********************Major changes for version 8******************************************)


(*
change findNextRuleExec function so that only new items will be added to the set of functions and functions that have deleted items will be removed

*)


(***********************Major changes for version 9******************************************)


(*
Tau leaping method - based on Gilespie paper: "Approximate accelerated stochastic simulation of chemically
reacting systems" - J.Chem.Phys.115,1716 (2001).W.Press

A rule with \[DoubleRightArrow] (DoubleRightArrow) will be an accelerated rule.

The interpreter finds the derivative of the accelerated rules with respect to any of the parameters. Then it looks for the derivative of each parameter in the rule with respect to time whether its from continuous rules or accelerated rules.

During execution the interpereter sums up the derivative of each object parameter with respect to time, from all the accelerated and continuous rule matchings that the object apears in. Then calculate the minimum possible Tau leap from all the accelerated rates. 
The interpreter picks uniform randomly the next "regular" reaction to happen.Integration is done over all the continuous rules until Tau or the rate of regular rules execution is reached. The accelerated rules are executed (randomly from the Poisson distribution) until the time limit (Tau or less). If the regular execution rate was reached then the regular rule matching is chosen from the sum of all regular rates, Else Tau is again calculated from the new gradients. Also sum the effects of all the accelerated and continuous rules.
Need to check if the total regular rate has surpessed the random point before starting to integrate again. In that case we need to backtrack and do it again with smaller Tau.
*)


(*
option screenPoolItems:
remove Pool items that are unnecessary for the simulation.
example - 
screenPoolItems-> {Hold[screenItemsFunc[thePool]]}

*)


(***********************Major changes for version 10******************************************)


(*
adding an initial value and time variable for continuous rules. For example:
the ode rule -
y'==-d y +p

could be replaced by the algebraic rule-
y == -(p/d)(1-E^(-d \[Tau]))+E^(-d \[Tau]) y[0]

\[Tau] - is the time variable
*)


(*
delayed rules are now treated as accelarated rules. if there is a delayed rule all the discrete rules will be used as accelerated in order to find the tau time for the next step.
In order to calculate the tau , we need the time derivative of the algebraic equation. Therefore now a user inputs the time derivative equation and the interpreter DSolve it. 

*)


(***********************Major changes for version 11******************************************)


(*
Handle PDEs (diffusion in 2D) - 

diffusion-> {diffusionVariable-> {prot1,prot2},spatialVariables-> {x,y},decayConstant-> {gProt1Decay, gProt2Decay},spaceScale-> gSpScale}


create a spatial structure for some objects:
example : spatialGrammar-> {spatialObject-> cell,spatialObjParamters->{3,4}}
spatialObjParamters - is the location of the x,y paramters in the corresponding spatial object.

spatial objects are connected in a Delaunay Triangulation . and rules that have some spatial elements will be applied only to neighboring  objects (either directly or to some degree).




addition of a Stochastic Differential Equation , or more specificaly a Wiener process:
grammarWienerVariable-> wt  , specify the random variable that is used inside ODE.
The interpreter replace ever instance of this variable with a different interpolation over random array for the time range.
And only then use NDSolve.

The problem is that NDSolve wroks very slow with these unsmooth functions!

*)

(***********************Major changes for version 12******************************************)
(*

KDtree usage for spatial elements

*)


(***********************Major changes for version 13****************************************)


(*

change to a package

*)


(***********************Major changes for version 14****************************************)


(*

fix bug - removed the usage of PrecisionGoal in NDSolve. This caused some simulations to finish before time.

*)


(***********************Major changes for version 15****************************************)


(*

Static structure pool - When the pool is of static structure , no added or removed objects (also no added rule instatiation) during the simulation, then the simulator can speed up the computation by maintaining a fixed structure and only updating the objects in the existing pool.
Can we automaticaly identify a fixed structure pool? 

*)


(***********************Major changes for version 16****************************************)


(*
useDynamicalPlanes - False: same as in previous versions. True: then the planes can move, so they have a location which is moved by the cells (not the basal lamina) and therefore their equations must be updated when cells connect or disconnect from them.

There is importance for order of elements in a spatial rule. Only the first (left most) element can have equations for its paramters! So if you need a plane moving , create te same rule twice , one for plane pushing cell (cell is first element) and the other cell pushing plane (plane is first element)

*)


(***********************Major changes for version 17****************************************)


(*
switch to use a time dependent PDE solver. 


gDiffusion-> {gDiffVariable-> {prot1},gDiffSpatialParamX-> {{cell(*object*),3(*parameter position*)}},gDiffSpatialParamY-> {{cell(*object*),4(*parameter position*)}},
gDiffSpatialParamR-> {{cell(*object*),5(*parameter position*)}},
gDiffDecay-> {gProt1Decay},gDiffConstant-> {gProt1Diff},gDiffSource-> {src1},
gDiffBoundaryTypeLeft-> gPDETypeNeumann,gDiffBoundaryTypeRight-> gPDETypeNeumann,gDiffBoundaryTypeBottom-> gPDETypeNeumann,
gDiffBoundaryTypeTop-> gPDETypeNeumann,
gDiffBoundaryValLeft-> 0, gDiffBoundaryValRight-> 0,
gDiffBoundaryValBottom-> 0,gDiffBoundaryValTop-> 0
}


pdeBoundaryWidth - the grid is added a wide boundary over the underlying spatial objects. This is because without it the objects that secrte may be too close to the edges and then the PDE solution doesn't look good, hence substance accumulate in the boundaries.


screenPoolItems - the functionality of this was disabled. need to check again where to put it in the code (after removing all items)
*)


(***********************Major changes for version 18****************************************)


(*
change the plane boundary functionality so that it will push objects when they are over the boundary regardless of the distance from the boundary line. This fixes the bug where objects that passed the boundary by some distance were not pushed back by boundary element.


The old options:
spatialPlaneDistance-> gOEPlaneDistance,spatialXPlanes->{},spatialYPlanes-> {leftBoundary,rightBoundary}

were changed to :
spatialBoundaryDistance-> gOEPlaneDistance,spatialBottomBoundary->bottomBoundary,spatialTopBoundary->topBoundary,spatialLeftBoundary-> leftBoundary,spatialRightBoundary-> rightBoundary

*)


(***********************Major changes for version 19****************************************)


(*
PDE secretion new option - we assume now that each node in the grid has the concentration at that location.
look at the new gSecretionDistributionOption->1 .


Handle grid size that is decreaseing (used to handle only increasing size)
see changes in countGridPointsToExpand and createNewGrids   - Changed back to older version because we got many error messages , kept the code in remark


*)


(***********************Major changes for version 20****************************************)


(*

Diffusion: user provides a decay function of space, instead of decay constant over the whole space. 
this is used for the stroma part of the tissue , in the OE application. The stroma has higher decay constant than the OE itself.
flag - gDiffDecayFunc
*)


(***********************Major changes for version 21****************************************)


(*

commneted out mPower and Imtek references
*)


(***********************Major changes for version 22****************************************)


(*

making this file a regular package - so it will be open source.
*)


(* --------------------------------------------------- CODE CODE CODE ----------------------------------------------- *)



Protect[rules];


(************************************Global Variables*************************************)


{Clear[with],Clear[solving],Clear[where],Clear[under],Clear[grammarPDF] ,Clear[grammarIndexOfElementInList],Clear[grammarNumElementsInList],Clear[grammarCreateObjectID],Clear[grammarDynamicObjID],Clear[grammarNumberOfDynamicObjID],Clear[grammarDiscreteDistribution],Clear[\[Tau]]};


grammarReservedReservedWordsList = {grammarPDF,grammarIndexOfElementInList ,grammarNumElementsInList,grammarCreateObjectID,grammarDynamicObjID,grammarNumberOfDynamicObjID,grammarDiscreteDistribution,\[Tau]};


grammarSigmoid[x_,t_]:=1/(1+Exp[-x/t])


grammarHillFunc[x_,thresh_,n_]:= x^n/(x^n+thresh^n);


gTauLeapEpsilon = 1;(*0.1;0.05;0.01;0.001*)


{typeVarDervTime,typeVarFuncTime,typeVarConstant} = {1,2,3};


gbUnlimitedTau = True;(*should be False so that there will be any Tau limiting by gTauLeapEpsilon*)


gbSolveAllByFullMGM = False;(*
It seems that the Full MultiGrid method is more efficient. (even though we have a good guess for initial values)

For level 6 :
only 2 cycles of imsMultiGridCycle takes 1.74 Second
while imsFullMultiGrid takes 1.25 Second

*)


(* this is a set of utility functions *)


argMax[lst_List] := Flatten[ Position[lst,Max[lst]] ];
argMax[x_] := {1};


getElementInList[lst_,elementType_] := Module[{tempList}, 
If[Head[lst] === List,
tempList = Select[lst, Head[#] == elementType &];
If[Length[tempList]  >=1 , tempList[[1]] , Null,Null], Null]];


randomPick[range_Integer] := Ceiling[RandomReal[]*range];


normalizeVector[vec_] := vec/Total[vec];


(* end set of utility functions *)


debugTiming=False;


debugSaveInterRes=False;


debugPrintODE = False;


getter[gr_,name_]:=name/.Apply[List,gr]


setter[gr_,name_,value_]:=Module[{grout},
grout=If[getter[gr,name]==name,
Append[gr,name->value],
g2D/.(name->oldvalue_ )-> (name->value)]]


NameExt[V_Symbol]:= ToExpression[StringJoin[ToString[V],"_"]]
NameExt[x_]:=x



NameExt2[lhs_List]:=Map[NameExt2,lhs];
NameExt2[head_[x___]]:=Map[NameExt,head[x]];
NameExt2[term_Symbol]:=term;


findVbls[e_]:=Module[{tmpVarlst},
tmpVarlst={};

Map[Function[{elem},
If[AtomQ[elem] && Not[NumberQ[elem]] && Not[NumberQ[N[elem]]] && Head[elem] == Symbol && !ValueQ[elem]&& elem=!=True && elem=!=False && elem =!= Null,
AppendTo[tmpVarlst,elem]];
],e,-1];

Union[tmpVarlst]
]


SetAttributes[findVbls,ReadProtected]


findVbls2[e_]:=Module[{curVars},
curVars = Complement[findVbls[e],grammarReservedReservedWordsList] ;

Flatten[{curVars,Union[Cases[e,grammarCreateObjectID[_],Infinity]]}]
]


SetAttributes[findVbls2,ReadProtected]


preProcessRules2[gr_Grammar]:=setter[gr,processedRules,
preProcessRules2[getter[gr,rules]]]


SetAttributes[preProcessRules2,ReadProtected]


indexOfWithSection = 2;
indexOfSubjectToSection = 3;
indexOfViaSection = 4;
indexOfConstraintsVars = 5;
indexOfWhereVariables = 6;
indexOfLHSElements = 7;
indexOfAppliedPartOfLHS = 8;
indexOfLHSVars = 9;
indexOfRHSVars = 10;
indexOfRateFuncStruct = 11;
indexComplexParamsExp = 12;
indexReplaceAll = 13;



(*
the with section has the rate function that depends on the input and maybe intermediate (from the subjectto) variables , and the output parameters cond probability function

there are two options:
1. output (RHS) parameters are in and only in grammarPDF structures
2. no  grammarPDF structeres but we have a single function that combines the input,output and intermediate parameters together.

for (1) we seperate the grammarPDF structures from the function and the resulting function is the rate function (rho).
  for (2) we integrate out all the output parameters and we get left with is the rate function.  
*)
HandleRateFunc[ruleRateFuncStruct_,arrInputParams_,arrOutputParams_] := Module[{ruleRateFunc,arrGrammarPDF,arrInputParamsExp,inputParamsRateFunc,condProbCDFArr,outputParamsCondRateFunc,outParamsNormFactor,arrOutputParamsInRateFunc,bFoudOutParam,arrOutputParamsStruct,foundParamSt},

If[debug,Print["HandleRateFunc: ruleRateFuncStruct = ",ruleRateFuncStruct];
Print["HandleRateFunc: arrInputParams = ",arrInputParams];
Print["HandleRateFunc: arrOutputParams = ",arrOutputParams];
];

ruleRateFunc = ruleRateFuncStruct[[1]];

arrGrammarPDF = {};
arrInputParamsExp = {};

If[Head[ruleRateFunc] === grammarPDF,
AppendTo[arrGrammarPDF,ruleRateFunc/.grammarPDF[dist_,var_]-> (var-> Hold[Random[dist]])]
,
If[Head[ruleRateFunc] === Times,
Map[Function[{term},
If[Head[term] === grammarPDF,AppendTo[arrGrammarPDF,term/.grammarPDF[dist_,var_]-> (var-> Hold[Random[dist]])];, AppendTo[arrInputParamsExp,term] ];],ruleRateFunc];
];
];

If[debug,Print["HandleRateFunc: arrGrammarPDF = ",arrGrammarPDF]];

If[Length[arrGrammarPDF] > 0, (*this is the first option*)
inputParamsRateFunc = Apply[Times,arrInputParamsExp ];

Return[{inputParamsRateFunc,{arrGrammarPDF,{}}}];
,
(*this is the (2) option  - there are no grammarPDF so we need to integrate the output params*)

arrOutputParamsInRateFunc = Flatten[Map[Function[{outParam},
bFoudOutParam = False;
Map[Function[{elem},If[outParam === elem, bFoudOutParam = True;]],ruleRateFunc,-1] ;
If[bFoudOutParam,outParam,{}]
],arrOutputParams]];

If[debug,Print["arrOutputParamsInRateFunc = ",arrOutputParamsInRateFunc]];

arrOutputParamsStruct = Map[Function[{outParam},{outParam,-\[Infinity],\[Infinity]}],arrOutputParamsInRateFunc];

If[Length[arrOutputParamsInRateFunc] >0,

inputParamsRateFunc = ruleRateFunc;
If[debug,Print["inputParamsRateFunc 1  = ",inputParamsRateFunc]];

If[Length[ruleRateFuncStruct]>1,

arrOutputParamsStruct = Map[Function[{outParamSt},
(*going over the limits for the variables*)
foundParamSt = Null;

Map[Function[{varSt},
If[varSt[[1]] == outParamSt[[1]],
foundParamSt = varSt;
]
],ruleRateFuncStruct[[2]]];

If[foundParamSt===Null,outParamSt,foundParamSt]

],arrOutputParamsStruct];

];

If[debug,Print["arrOutputParamsStruct = ",arrOutputParamsStruct]];

Map[Function[{curOutputParamSt},inputParamsRateFunc = Integrate[inputParamsRateFunc,curOutputParamSt]],arrOutputParamsStruct];

(*Print["inputParamsRateFunc  = ",inputParamsRateFunc];*)

If[debug,Print["inputParamsRateFunc 2  = ",inputParamsRateFunc]];

If[Head[inputParamsRateFunc]===Integrate,
Print["Error - the function could not be integrated"];
Print["function = ",ruleRateFunc];
Print["variables = ",arrOutputParamsStruct];

Print[" exit interpreter"];
Exit[];
];

outputParamsCondRateFunc = ruleRateFunc/inputParamsRateFunc;

If[debug,Print["outputParamsCondRateFunc  = ",outputParamsCondRateFunc]];

(*now normalize the function *)
outParamsNormFactor = outputParamsCondRateFunc;
Map[Function[{curOutputParamSt},outParamsNormFactor = Integrate[outParamsNormFactor,curOutputParamSt]],arrOutputParamsStruct];
outputParamsCondRateFunc /= outParamsNormFactor;

If[debug,Print["HandleRateFunc: outputParamsCondRateFunc = ",outputParamsCondRateFunc]];

condProbCDFArr = calcCondProbsFromMultiVariateDist[outputParamsCondRateFunc,arrOutputParamsStruct];

If[debug,Print["HandleRateFunc: condProbCDFArr = ",condProbCDFArr]];

Return[{inputParamsRateFunc,{{},condProbCDFArr}}];
,
Return[{ruleRateFunc,{{},{}}}];
];

]

];



SetAttributes[HandleRateFunc,ReadProtected]


calcCondProbsFromMultiVariateDist[multVarDist_,arrVarsSt_]:=Module[{curMultVarDist,nextMultVarDist,curIntegralCDF,varEndIntegral,condProbCDFArr},

nextMultVarDist = multVarDist;

(*forward direction - create all the sub joint distributions*)
fwdMultVarDistArr = Map[Function[{curVarSt},

curMultVarDist = nextMultVarDist;

nextMultVarDist = Integrate[curMultVarDist,curVarSt]; 

curMultVarDist
],arrVarsSt];

bckdMlutVarDist = 1;

condProbCDFArr = MapThread[Function[{tempMultVarDist,curVarSt},

curCondMultVarDist = tempMultVarDist/bckdMlutVarDist; (*this distribution is P (A|B,C,D...) *)

(*now we'll need to sample from this distribution so we get the Inverse CDF of it. so first get the CDF*)
varEndIntegral = Unique[SymbolName[curVarSt[[1]]]];

curIntegralCDF = Integrate[curCondMultVarDist,{curVarSt[[1]],curVarSt[[2]],varEndIntegral}];

bckdMlutVarDist = tempMultVarDist;

{curIntegralCDF,varEndIntegral,curVarSt[[1]]}

],{Reverse[fwdMultVarDistArr],Reverse[arrVarsSt]}];

condProbCDFArr
]


SetAttributes[calcCondProbsFromMultiVariateDist,ReadProtected]


sampleFromMultiVariateDist[condProbCDFArr_]:=Module[{rndNum,solInverseCDF,rndDistVal,curFuncCDF,curCDFVar},
arrDistValsRulesArr = {};

Map[Function[{condProbCDF},
If[debug,Print[" condProbCDF = ",condProbCDF];];

(*uniformly distributed number between 0 and 1*)
rndNum = RandomReal[];

If[debug,Print[" rndNum = ",rndNum];];
If[debug,Print[" arrDistValsRulesArr = ",arrDistValsRulesArr];];

curFuncCDF = condProbCDF[[1]]/.condProbCDF[[2]]-> curCDFVar ;

solInverseCDF = findRootInMonotoneIncreaseFunc[curFuncCDF/.arrDistValsRulesArr ,rndNum,curCDFVar,{-10,10}];

If[debug,Print["solInverseCDF = ",solInverseCDF];];

rndDistVal = curCDFVar/.solInverseCDF[[1]];

AppendTo[arrDistValsRulesArr ,condProbCDF[[3]]-> rndDistVal];

],condProbCDFArr];

arrDistValsRulesArr
];


SetAttributes[sampleFromMultiVariateDist,ReadProtected]


findRootInMonotoneIncreaseFunc[inFunc_,inFuncVal_,inVar_,inBarckets_] := Module[{curStartVal,curSolFunc,checkRes,curBrackets,valinBrackets,tempCenterVal,maxNumIterationsInMIFunc},

maxNumIterationsInMIFunc = 100;
toleranceMonIncFuncBracket = 10^-8;

curBrackets = inBarckets;

For[indexFRoot=1,indexFRoot<=maxNumIterationsInMIFunc,indexFRoot++,

If[Abs[curBrackets[[1]]-curBrackets[[2]]]<= toleranceMonIncFuncBracket,
Return[{inVar-> curBrackets[[1]]}];
];

curStartVal = N[Apply[Plus,curBrackets]/2];

checkRes = Check[curSolFunc = FindRoot[inFunc== inFuncVal,{inVar,curStartVal}],err];

If[checkRes =!= err,
Return[curSolFunc],
valinBrackets = {inFunc/.inVar-> curBrackets[[1]],inFunc/.inVar-> curBrackets[[2]]};

If[valinBrackets[[1]]<=inFuncVal && valinBrackets[[2]]<=inFuncVal,
(*move the upper bracket upward*)
curBrackets[[2]] += Max[100,Abs[curBrackets[[2]]]];
,

If[valinBrackets[[1]]>= inFuncVal && valinBrackets[[2]]>= inFuncVal,
(*move the lower bracket downward*)
curBrackets[[1]] -=  Max[100,Abs[curBrackets[[1]]]]; 
,
(*move to the center*)
tempCenterVal = inFunc/.inVar-> curStartVal;

If[tempCenterVal<= inFuncVal,
curBrackets[[1]]  = curStartVal;
,
curBrackets[[2]]  = curStartVal;
];

];
];

];
];

Print["findRootInMonotoneIncreaseFunc: ERROR - did not converged after ",maxNumIterationsInMIFunc, " iterations"];
Print["{inFunc,inFuncVal,inVar,inBarckets} = ",{inFunc,inFuncVal,inVar,inBarckets}];

Return[curSolFunc]
];


SetAttributes[findRootInMonotoneIncreaseFunc,ReadProtected]


replaceObjectAssignments[{inRuleLHS_,inRuleRHS_}]:=Module[{objReplaceList,curRuleCombined,currentRuleLHS,currentRuleRHS,retTempRule},
objReplaceList = {};

{currentRuleLHS,currentRuleRHS} = {inRuleLHS,inRuleRHS};

If[Head[currentRuleLHS]=!= List  , 
	currentRuleLHS = {currentRuleLHS};
];

If[Head[currentRuleRHS]=!= List  , 
	currentRuleRHS = {currentRuleRHS};
];


curRuleCombined = Map[Function[{curElem},
If[Head[curElem] === Equal,
AppendTo[objReplaceList,curElem[[1]]-> curElem[[2]]];
curElem[[2]]
,
If[Head[curElem] === Rule || Head[curElem] === RuleDelayed || Head[curElem] === DoubleRightArrow,
retTempRule = replaceObjectAssignments[{curElem[[1]],curElem[[2]]}];
retTempRule[[1]]-> retTempRule[[2]]
,
curElem
]
] 
],Join[currentRuleLHS,currentRuleRHS]];

curRuleCombined = curRuleCombined/. objReplaceList;

{curRuleCombined[[Range[1,Length[currentRuleLHS]]]],curRuleCombined[[Range[Length[currentRuleLHS]+1,Length[curRuleCombined]]]]}
];


SetAttributes[replaceObjectAssignments,ReadProtected]


preProcessRules2[ru_List]:=Module[{ippr,newelement,ruleVbls,constraintVbls,listConstraintVbls,whereConstraints,tempRHSVariables,solvingSection,solvingSectionFinal,dervVarsConvertArr,dervVarsMapToElems,indexRule,currentRuleRHS,currentRuleLHS,curRuleMappedLHS,curRuleMappedRHS,rhsRulesArr,bIsRuleDelayed,bIsRuleAccelerated,tempEq,tempruls,tempruls2,posVarsInElements,curContElmLoc,resAccelStrct,curEqIntVar,curIntFunc,tempind,temparr,delEntriesInSolv,bIsDiffusionRule,tempvar},
newelement={Null,Null,Null,Null};

gGrammarRulesLHS = {};
gGrammarContRulesSolvingSec = {};

gPositionOfContRules = {};
gPositionOfDiscRules = {};
gMappedRegLHStoRHSelems = {};
gFullMapRegLHStoRHSelems = {};
gFullLHSModifiedElems = {};
gMonotoneRulesArr = {};
gRHSRulesArr = {};
gPositionOfDelayedContRules = {};
gPositionOfAcceleratedRules = {};
gGrammarContElmLoc = {};
gAcceleratedRulesStruct = {};
gGrammarAccelElmLoc = {};

gGrammarDiffRulesSolvingSec = {};
gGrammarDiffElmLoc = {};
gPositionOfDiffRules = {};

gContParamStruct = {};

indexRule = 1;

For[ippr=1;rup={},ippr<=Length[ru],Null,
	If[(Head[ru[[ippr]]]===Rule) || (Head[ru[[ippr]]]===RuleDelayed) || (Head[ru[[ippr]]]===DoubleRightArrow),

If[debug,
Print["preProcessRules2: rule"];
];

bIsRuleDelayed = (Head[ru[[ippr]]]===RuleDelayed && guseDelayedRules);

bIsRuleAccelerated = (Head[ru[[ippr]]]===DoubleRightArrow && guseAcceleratedRules) || gbEnforceAllRulesAccelStruct;

(*guy - change - find only the variables that are on the left side*)
(* was before  - ruleVbls=findVbls[ru[[ippr]][[1]]] ]; *)
currentRuleLHS = ru[[ippr]][[1]];
currentRuleRHS = ru[[ippr]][[2]];

If[Head[currentRuleLHS]=!= List  , 
	currentRuleLHS = {currentRuleLHS};
];

If[Head[currentRuleRHS]=!= List  , 
	currentRuleRHS = {currentRuleRHS};
];

(*find and replace all the object assignments in the rule*)
{currentRuleLHS,currentRuleRHS} = replaceObjectAssignments[{currentRuleLHS,currentRuleRHS}];

rhsRulesArr = {};
(*go over the RHS and extract all the rules (deterministic) in there*)
currentRuleRHS = DeleteCases[Map[Function[{curRHSElem},
If[Head[curRHSElem] === Rule,
AppendTo[rhsRulesArr,curRHSElem];
0,
curRHSElem
]
],currentRuleRHS],0];

AppendTo[gRHSRulesArr,rhsRulesArr];

newelement={currentRuleLHS->currentRuleRHS, {1.0},Null,Null,{},{},{},{},{},{},{},0,{}};

ruleVbls=findVbls[currentRuleLHS];

tempRHSVariables = findVbls[currentRuleRHS];

(* handle the quantifiers and regular elements *)
regularRuleElements = Flatten[Map[Function[{ruleElem},If[Head[ruleElem]===ForAll || Head[ruleElem]===Not,{},ruleElem] ],currentRuleLHS]];
forAllRuleElements = Flatten[Map[Function[{ruleElem},
If[Head[ruleElem]===ForAll && Head[ruleElem[[2]]]=!= Not,
changeOfForAllElems = Map[
Function[{curForAllElem},
curForAllElem-> _
],If[Head[ruleElem[[1]]]=!=List,{ruleElem[[1]]},ruleElem[[1]]]];

{{ruleElem[[1]],ruleElem[[2]]/.changeOfForAllElems}}
,{}] ],currentRuleLHS],1];

notExistsRuleElements = Flatten[Map[Function[{ruleElem},
If[Head[ruleElem]===ForAll && Head[ruleElem[[2]]]=== Not,
changeOfForAllElems = Map[
Function[{curForAllElem},
curForAllElem-> _
],If[Head[ruleElem[[1]]]=!=List,{ruleElem[[1]]},ruleElem[[1]]]];
{{ruleElem[[1]],ruleElem[[2,1]]/.changeOfForAllElems}}
,
If[Head[ruleElem]===Not,
{{guytempVar[],ruleElem[[1]]}},
{}]
] 

],currentRuleLHS],1];


newelement[[indexOfLHSElements]] = {regularRuleElements,forAllRuleElements,notExistsRuleElements};

(*link to every regular element in the LHS an element in the RHS, if exist*)
curRuleMappedLHS ={};
curRuleMappedRHS ={};
MapIndexed[Function[{curLHSElem,curLHSElemIndex},
If[Head[curLHSElem]===ForAll,{},
tempMatchingRHS = DeleteCases[
MapIndexed[Function[{curRHSElem,curRHSElemIndex},
If[curLHSElem === curRHSElem,curRHSElemIndex[[1]],0]
],currentRuleRHS],0];

tempMatchingRHS = Complement[tempMatchingRHS,curRuleMappedRHS];

If[Length[tempMatchingRHS]>0,
curRuleMappedLHS = Append[curRuleMappedLHS,curLHSElemIndex[[1]]];
curRuleMappedRHS = Append[curRuleMappedRHS,tempMatchingRHS[[1]]];
]
]
],regularRuleElements];

gMappedRegLHStoRHSelems = Append[gMappedRegLHStoRHSelems,{Partition[curRuleMappedLHS,1],Partition[curRuleMappedRHS,1]}];

(*Remark: the applied part of the LHS is the part of only the Reg and ForAll elements. here we do not change the name of quantifiers variables to _ because we use them for the execution of the rule *)
newelement[[indexOfAppliedPartOfLHS]] = Flatten[{regularRuleElements,Map[Function[{ruleElem},
If[Head[ruleElem]===ForAll && Head[ruleElem[[2]]]=!= Not,
ruleElem[[2]]
,{}] ],currentRuleLHS]}];

(*a monotone rule - a rule were all LHS elements are not removed , meaning all are mapped to a RHS element*)
gMonotoneRulesArr = Append[gMonotoneRulesArr,Length[regularRuleElements] === Length[curRuleMappedLHS]];

If[gIsStaticStructurePool,
fullMapLHStoRHSelems[regularRuleElements,currentRuleRHS];
];


];

newelement[[indexComplexParamsExp]]=  0;

(*Print["newelement[[indexOfLHSElements]] = ",newelement[[indexOfLHSElements]]];*)

Map[Function[{curTerm},
If[Length[curTerm]>0,
Map[If[Length[#]>1,
newelement[[indexComplexParamsExp]] = 1;
]&,curTerm]
]
],Flatten[newelement[[indexOfLHSElements]]]];

(*Print["newelement[[indexComplexParamsExp]] = ",newelement[[indexComplexParamsExp]]];*)


whereConstraints = getElementInList[ru[[ippr]][[2]],where];

If[whereConstraints =!= Null , newelement[[indexOfWhereVariables]]=Complement[findVbls[whereConstraints],ruleVbls] ]; 

ippr++;

solvingSection = {};

While[ippr<=Length[ru]&&Not[Head[ru[[ippr]]]===Rule] && Not[Head[ru[[ippr]]]===RuleDelayed] && Not[Head[ru[[ippr]]]===DoubleRightArrow],

If[(Head[ru[[ippr]]]===with),
newelement[[indexOfWithSection]]=Apply[List,ru[[ippr]]]];

If[(Head[ru[[ippr]]]===under),
newelement[[indexOfWithSection]]=Exp[-ru[[ippr,1]]]];

If[(Head[ru[[ippr]]]===subjectto),
newelement[[indexOfSubjectToSection]]=Union[Apply[List,ru[[ippr]]]] ;
constraintVbls=findVbls[ru[[ippr]]];
newelement[[indexOfConstraintsVars]]=Complement[constraintVbls,ruleVbls] ;
newelement[[indexOfWhereVariables]]=Complement[newelement[[indexOfWhereVariables]],constraintVbls] ];

If[(Head[ru[[ippr]]]===via),
newelement[[indexOfViaSection]]=ru[[ippr,1]]];

If[Head[ru[[ippr]]] === solving,
solvingSection=Apply[List,ru[[ippr]]];];

If[Head[ru[[ippr]]] === grammarReplaceAll,
newelement[[indexReplaceAll]]=Apply[List,ru[[ippr]]];

(*just add for each rule a rule of LHS->True*)
newelement[[indexReplaceAll]] = Map[{#[[1]],#[[2]]} &,newelement[[indexReplaceAll]]];

];

ippr++];


(* remove the reserved key words *)
newelement[[indexOfConstraintsVars]] = Complement[newelement[[indexOfConstraintsVars]],grammarReservedReservedWordsList] ;
newelement[[indexOfWhereVariables]] = Complement[newelement[[indexOfWhereVariables]],grammarReservedReservedWordsList] ;
newelement[[indexOfLHSVars]] = Complement[ruleVbls,grammarReservedReservedWordsList];
newelement[[indexOfRHSVars]] = Complement[tempRHSVariables,Flatten[{newelement[[indexOfConstraintsVars]],newelement[[indexOfWhereVariables]],newelement[[indexOfLHSVars]],grammarReservedReservedWordsList}]];

gGrammarRulesLHS = Append[gGrammarRulesLHS,Flatten[newelement[[indexOfLHSElements]],1]];

If[Length[solvingSection]>0,(*this is a continuous rule!*)

If[debug,
Print["preProcessRules2: solvingSection = ",solvingSection];
];

bIsRuleAccelerated = False;(*can't be if its a continuous rule*)

(*go over the equation to find diffusion variables. If one is found then this equation relates to the diffusion process*)
bIsDiffusionRule = False;
Map[Function[{curvar},

If[!FreeQ[solvingSection,curvar],
bIsDiffusionRule = True;
]
],Join[giDiffVars,giSourceFunctions]];

newelement[[indexOfRateFuncStruct]] = {0,{{},{}}};

posVarsInElements = Map[Function[{curvar},
Position[Flatten[newelement[[indexOfLHSElements]],1],curvar,{2,Infinity}][[1]]
], newelement[[indexOfLHSVars]]];

curContElmLoc = Map[Function[{curEq},
{
(*go over only the LHS of the equation - find the equation's variable *)
tempvar = DeleteCases[MapThread[Function[{curvar,curvarpos},
If[!FreeQ[curEq[[1]],curvar],
curvarpos
,
0
]
], {newelement[[indexOfLHSVars]],posVarsInElements}],0];

If[Length[tempvar]>0,tempvar[[1]],{}]
,
(*both sides of the equation - find all variables in equation*)
DeleteCases[MapThread[Function[{curvar,curvarpos},
If[!FreeQ[curEq,curvar],
curvarpos
,
0
]
], {newelement[[indexOfLHSVars]],posVarsInElements}],0]
}

],solvingSection];

tempruls = Map[Function[{curvar},curvar-> curvar[gGrammarTimeVar]],newelement[[indexOfLHSVars]]];
tempruls2 = Map[Function[{curvar},curvar[gGrammarTimeVar][N[0]]-> curvar[N[0]]],newelement[[indexOfLHSVars]]];

solvingSection = Map[Function[{curEq},

If[bIsRuleDelayed && Head[curEq[[1]]] === Derivative[1],
(*integrate the differential equation*)
curEqIntVar = curEq[[1,1]];
tempEq = curEq/.  {curEqIntVar->curEqIntVar[gGrammarTimeVar],\[Tau]-> gGrammarTimeVar};
tempEq = tempEq /.Derivative[i_][x_[gGrammarTimeVar]]-> Derivative[i][x] [gGrammarTimeVar];

curIntFunc = (curEqIntVar/. DSolve[tempEq,curEqIntVar,gGrammarTimeVar][[1]]);

curIntFunc = curIntFunc[gGrammarTimeVar] /. Solve[curIntFunc[0] == curEqIntVar0 ,C[1]][[1]];

curIntFunc = (curIntFunc/.tempruls)/.curEqIntVar0-> curEqIntVar[0];

tempEq = {curEqIntVar[gGrammarTimeVar]== curIntFunc,curEq[[2]]/.Append[tempruls,\[Tau]-> gGrammarTimeVar]};
,
tempEq = (curEq /.Append[tempruls,\[Tau]-> gGrammarTimeVar])/.tempruls2;

tempEq = tempEq /.Derivative[i_][x_[gGrammarTimeVar]]-> Derivative[i][x] [gGrammarTimeVar];

tempEq = {tempEq,\!\(
\*SubscriptBox[\(\[PartialD]\), \(gGrammarTimeVar\)]\ \((tempEq[\([\)\(2\)\(]\)])\)\)};

];

N[tempEq]
],solvingSection];

(*combine  algebraic and diff equations for the same variable
Print["before solvingSection = ",solvingSection];

delEntriesInSolv = {};
solvingSection = MapIndexed[Function[{curEqStruct,curEqStructInd},
Print["{curEqStruct,curEqStructInd} = ",{curEqStruct,curEqStructInd}];

If[curEqStructInd[[1]]<Length[solvingSection],

temparr = DeleteCases[MapIndexed[Function[{curEqStruct2,curEqStruct2ind},
tempind = 0;
Print["{curEqStruct2,curEqStruct2ind} = ",{curEqStruct2,curEqStruct2ind}];

If[(curEqStruct[[1,1]] == curEqStruct2[[1,1]]) /. {Derivative[1][x_] [gGrammarTimeVar]-> x,x_[gGrammarTimeVar]-> x},
(*found a matching*)
tempind = curEqStruct2ind[[1]];
If[(Head[curEqStruct[[1,1]]] /. Derivative[1][x_]-> 0 )=== 0,
tempEq = {curEqStruct2[[1]],curEqStruct[[1,2]]};
,
tempEq = {curEqStruct[[1]],curEqStruct2[[1,2]]};
];
];

tempind
],solvingSection[[Range[curEqStructInd[[1]]+1,Length[solvingSection]]]]],0];

If[Length[temparr]>0,
AppendTo[delEntriesInSolv,{curEqStructInd[[1]]+temparr[[1]]}];
];

tempEq
,
curEqStruct
]

],solvingSection];

solvingSection = Delete[solvingSection,delEntriesInSolv];

*)

If[bIsDiffusionRule,
gGrammarDiffRulesSolvingSec = Append[gGrammarDiffRulesSolvingSec,solvingSection];
gGrammarDiffElmLoc = Append[gGrammarDiffElmLoc,curContElmLoc];
gPositionOfDiffRules = Append[gPositionOfDiffRules,indexRule];

,
gGrammarContRulesSolvingSec = Append[gGrammarContRulesSolvingSec,solvingSection];
gGrammarContElmLoc = Append[gGrammarContElmLoc,curContElmLoc];
gPositionOfContRules = Append[gPositionOfContRules,indexRule];

If[bIsRuleDelayed,
gPositionOfDelayedContRules =Append[gPositionOfDelayedContRules,indexRule];
];
];

addToContParametersStruct[currentRuleLHS,curContElmLoc];
,
newelement[[indexOfRateFuncStruct]] = HandleRateFunc[newelement[[indexOfWithSection]],newelement[[indexOfLHSVars]],newelement[[indexOfRHSVars]]];

gPositionOfDiscRules = Append[gPositionOfDiscRules,indexRule];
];

If[bIsRuleAccelerated,

resAccelStrct = createAcceleratedRuleStct[regularRuleElements(*the LHS elems*),currentRuleRHS,newelement[[indexOfWithSection]][[1]],newelement[[indexOfLHSVars]]];

If[resAccelStrct=!= False,
gGrammarAccelElmLoc = Append[gGrammarAccelElmLoc,resAccelStrct[[1]]];
gAcceleratedRulesStruct = Append[gAcceleratedRulesStruct,{newelement[[indexOfWithSection]][[1]],resAccelStrct[[2]]}];
gPositionOfAcceleratedRules =Append[gPositionOfAcceleratedRules,indexRule];
];

];

indexRule++;

rup=Append[rup,newelement];

];

If[debug,
Print["preProcessRules2: gRHSRulesArr = ",gRHSRulesArr];
Print["preProcessRules2: gGrammarContRulesSolvingSec = ",gGrammarContRulesSolvingSec];
Print["preProcessRules2: gGrammarContElmLoc = ",gGrammarContElmLoc];

Print["preProcessRules2: gGrammarDiffRulesSolvingSec = ",gGrammarDiffRulesSolvingSec];
Print["preProcessRules2: gGrammarDiffElmLoc = ",gGrammarDiffElmLoc];
Print["preProcessRules2: gPositionOfDiffRules = ",gPositionOfDiffRules];
];


rup
]


(*This defines the functionextractVariableswhich extracts all variables from an expression.*)


extractVariables[expr_]:=Module[{cond=Not[MemberQ[Attributes[#],Protected]]&},Union[Cases[expr,_Symbol?cond[_]|_Symbol?cond,\[Infinity]]]]


(*example*)


extractVariables[1+9x+p[1]Exp[ty]]


SetAttributes[fullMapLHStoRHSelems,ReadProtected]


(*we map every element on the LHS to the closest element on the RHS.*)


fullMapLHStoRHSelems[lhsRulesElems_,rhsRulesElems_]:=Module[{arrModifiedElems,arrMapToRHS,arrScoresRHS,varsLHS,varsRHS,arrtempIn,tot,arrnewIndexes},

If[debug,
Print["fullMapLHStoRHSelems: lhsRulesElems = ",lhsRulesElems];
Print["fullMapLHStoRHSelems: rhsRulesElems = ",rhsRulesElems];
];

arrMapToRHS = Table[0,{Length[lhsRulesElems]}];
arrModifiedElems = Table[True,{Length[lhsRulesElems]}];

(*first assign the guranteed matchings*)
MapThread[Function[{lhsIndex,rhsIndex},
arrMapToRHS[[lhsIndex[[1]]]] = rhsIndex[[1]];
arrModifiedElems[[lhsIndex[[1]]]] = False;(*this object is not modified by the rule*)

],{Last[gMappedRegLHStoRHSelems][[1]],Last[gMappedRegLHStoRHSelems][[2]]}];

(*now score every existing LHS element to an existing RHS element, then map it to the highest score*)
(*a valid mapped element must have an exactly thr same element Head and number of parameters.*)
(*score (+1) is given for each matching numerical value or variable*)
MapIndexed[Function[{curLHSElem,curLHSElemIndex},

If[arrMapToRHS[[curLHSElemIndex[[1]]]] >0 || Head[curLHSElem]===ForAll,{},
(*score each element*)
arrScoresRHS = MapIndexed[Function[{curRHSElem,curRHSElemIndex},
If[Length[Cases[arrMapToRHS,curRHSElemIndex[[1]]]] == 0 &&  Head[curLHSElem] === Head[curRHSElem] && Length[curLHSElem] === Length[curRHSElem],
(*score each parameter*)
Total[MapThread[Function[{curLHSElemParam,curRHSElemParam},
If[curLHSElemParam === curRHSElemParam,
2
,
varsLHS = extractVariables[curLHSElemParam];
varsRHS = extractVariables[curRHSElemParam];
If[Length[Intersection[varsLHS ,varsRHS]] == Length[varsLHS] == Length[varsRHS],1,0]
]
],{Apply[List,curLHSElem],Apply[List,curRHSElem]}]]
,
-1
]
],rhsRulesElems];

If[Max[arrScoresRHS]< 0,
Print["ERROR: isStaticStructurePool  - can not find correspoding element!!"];
Print["lhsRulesElems= ",lhsRulesElems];
Print["rhsRulesElems= ",rhsRulesElems];
];

arrMapToRHS[[curLHSElemIndex[[1]]]] = Ordering[arrScoresRHS,-1][[1]];
]
],lhsRulesElems];

If[debug,
Print["fullMapLHStoRHSelems: arrMapToRHS = ",arrMapToRHS];
];

(*now create a mapping of only the modified elements. So we remove the unmodified elements and adjust the indexes accordingly*)
arrtempIn = Table[0,{Length[lhsRulesElems]}];
arrtempIn[[arrMapToRHS[[Flatten[Position[arrModifiedElems,True]]]]]]= 1;
tot = 0;
arrnewIndexes = Map[Function[{curin},If[curin >0, tot+= 1; tot,0]],arrtempIn];
arrMapToRHS = arrnewIndexes[[arrMapToRHS]];
arrMapToRHS = Delete[arrMapToRHS,Position[arrModifiedElems,False]];

gFullMapRegLHStoRHSelems = Append[gFullMapRegLHStoRHSelems,arrMapToRHS];
gFullLHSModifiedElems = Append[gFullLHSModifiedElems,Flatten[Position[arrModifiedElems,True]]];
];


SetAttributes[preProcessRules2,ReadProtected]


addToContParametersStruct[currentRuleLHS_,curContElmLoc_]:=Module[{arrElems,indexFound},
If[debug,
Print["addToContParametersStruct: {currentRuleLHS,curContElmLoc} = ",{currentRuleLHS,curContElmLoc}];
];

arrElems =DeleteCases[ Map[Function[{curEqElmLoc},
If[Length[curEqElmLoc[[1]]]>0,
{Head[currentRuleLHS[[curEqElmLoc[[1,1]]]]],curEqElmLoc[[1,2]]},0]
],curContElmLoc],0];

Map[Function[{curel},
indexFound = 0;

MapIndexed[Function[{curContElem,curContElemIn},

If[curel[[1]] === curContElem[[1]],indexFound = curContElemIn[[1]];];

],gContParamStruct];

If[indexFound == 0,
AppendTo[gContParamStruct,{curel[[1]],{curel[[2]]}}];
,
AppendTo[gContParamStruct[[indexFound,2]],curel[[2]]];
];

],arrElems];

If[debug,
Print["addToContParametersStruct: gContParamStruct = ",gContParamStruct];
];

];


SetAttributes[addToContParametersStruct,ReadProtected]


createAcceleratedRuleStct[accelRuleInputElems_,accelRuleOutputElems_,accelWithSection_,inputVars_]:=Module[{diffParams,bMatchingElemenets,curRuleAffectedParams},

If[Length[accelRuleInputElems] != Length[accelRuleOutputElems],
Print["ERROR: createCurAcceleratedRuleStct function Length[accelRuleInputElems] \[NotEqual] Length[accelRuleOutputElems]"];
Print["ERROR: createCurAcceleratedRuleStct  {accelRuleInputElems,accelRuleOutputElems,accelWithSection,inputVars} = ",{accelRuleInputElems,accelRuleOutputElems,accelWithSection,inputVars}];

Return[False];
];

bMatchingElemenets = True;
curRuleAffectedParams = {};
curRulePosParams = {};

MapThread[Function[{curInputElem,curOutputElem,curelemIndex},
If[Head[curInputElem]=!=  Head[curOutputElem] || Length[curInputElem] =!= Length[curOutputElem],
bMatchingElemenets = False;
,
If[Length[curOutputElem]>0,
MapThread[Function[{curInputElemParam,curOutputElemParam,curelemParamIndex},

If[AtomQ[curInputElemParam] && !NumericQ[curInputElemParam],

diffParams = curOutputElemParam-curInputElemParam;

If[NumericQ[diffParams],
If[diffParams!= 0  ||  \!\(
\*SubscriptBox[\(\[PartialD]\), \(curInputElemParam\)]\ accelWithSection\)  =!= 0,
AppendTo[curRuleAffectedParams ,{diffParams,\!\(
\*SubscriptBox[\(\[PartialD]\), \(curInputElemParam\)]\ accelWithSection\)}];
AppendTo[curRulePosParams ,{curelemIndex,curelemParamIndex}];

];
,
bMatchingElemenets = False;
];
];

],{Apply[List,curInputElem],Apply[List,curOutputElem],Range[1,Length[curInputElem]]}]
]
]
],{accelRuleInputElems,accelRuleOutputElems,Range[1,Length[accelRuleInputElems]]}];

If[!bMatchingElemenets,
Print["ERROR: createCurAcceleratedRuleStct function bMatchingElemenets False]"];
Print["ERROR: createCurAcceleratedRuleStct  {accelRuleInputElems,accelRuleOutputElems,accelWithSection,inputVars} = ",{accelRuleInputElems,accelRuleOutputElems,accelWithSection,inputVars}];

Return[False];
];

{curRulePosParams,curRuleAffectedParams}

]


SetAttributes[createAcceleratedRuleStct,ReadProtected]


addDervVar[curX_]:=Module[{},
AppendTo[gDervVarsList,curX];
]


SetAttributes[addDervVar,ReadProtected]


FindMatchingPoolRule[ruleLHS_]:=Module[ {poolPositions,i,j,poolPosCounter,poolPosCounterTotalSize,poolPosCounterSizes, currentPoolVector,matchingPoolRuleVectorsOfRegElems ,
matchingPoolRuleVectorsOfForAll ,matchingPoolRuleCorrespondingForAllElems}, 
(*create the data structure*)

(* reminder  - ruleLHS = {regularRuleElements,forAllRuleElements,notExistsRuleElements} *)

(* first we handle the regular rule elements *)

matchingPoolRuleVectorsOfRegElems = {};
matchingPoolRuleVectorsOfForAll = {};
matchingPoolRuleCorrespondingForAllElems={};

If[Length[ruleLHS[[1]]]=!= 0  , 

poolPositions =Map[Flatten[Position[thePool,#]]&,ruleLHS[[1]]];

poolVectorPositions = Distribute[poolPositions,List];

matchingPoolRuleVectorsOfRegElems = Apply[List,Flatten[Apply[tempDelNode,
Map[Function[{poolvector},
If[Length[poolvector] == Length[Union[poolvector]],

(* check if the rule is valid when all the elements are cosidered together *)
If[Apply[List,Part[thePool,poolvector]] /. ruleLHS[[1]]->True,
poolvector
,
tempDelNode[]
]
]
],poolVectorPositions]]]];


,
(*if there are no regular elements in the LHS then all the elements in the match the rule *)
matchingPoolRuleVectorsOfRegElems  = Table[{i},{Length[thePool]}];
];

(*now handle the forAll RuleElements*)
If[Length[matchingPoolRuleVectorsOfRegElems]=!=0 &&Length[ruleLHS[[2]]]=!= 0,

ruleLHSForAllElements = ruleLHS[[2,All,2]];
ruleLHSRegAndForAllElems = Flatten[{ruleLHS[[1]],ruleLHSForAllElements}];

(* go over the forAll elements *)
posArrInPoolperEachForAllElem = Map[Function[{forallElem},

Flatten[Position[thePool,forallElem]]

],ruleLHSForAllElements];

groupsArrForAllElemsTable = Table[0,{Length[ruleLHSForAllElements]}];
tempForAllElementsMatchingTable =Map[Function[{forallElem},
{forallElem,forallElem}
],ruleLHSForAllElements];

codeOption = 1;(*1 - takes about 0.6sec , 2 - takes about 1.0sec*)
If[codeOption === 1,
iNumItemsInEachGroup = 50;
iNumGroupsPerForAll = 50;
groupsArrForAllElemsTable = Table[{0,Table[{0,Table[0,{iNumItemsInEachGroup}]},{iNumGroupsPerForAll}]},{Length[ruleLHSForAllElements]}];
];

(*now group the forAll elements to groups of matching pool elements*)
MapIndexed[Function[{posArrForAllElem,indexForAll},

Scan[Function[{posForAllElem},

If[codeOption === 1,
If[groupsArrForAllElemsTable[[indexForAll[[1]],1]]===0,
(*create the first group*)
groupsArrForAllElemsTable[[indexForAll[[1]],2,1,2,1]] = posForAllElem;(*first item in first group*)
groupsArrForAllElemsTable[[indexForAll[[1]],2,1,1]]++;(*number of items in first group*)
groupsArrForAllElemsTable[[indexForAll[[1]],1]] ++;(*number of groups in this ForAll*)

,
bFoundMatching = False;
Do[
(*Print["groupsArrForAllElemsTable[[indexForAll[[1]],2,indexOfGroup]] = ",groupsArrForAllElemsTable[[indexForAll[[1]],2,indexOfGroup]]];*)

numItemsInCurrentGroup = groupsArrForAllElemsTable[[indexForAll[[1]],2,indexOfGroup,1]];

(*it is enough to check a matching with the first entry *)
If[Apply[List,Part[thePool,{groupsArrForAllElemsTable[[indexForAll[[1]],2,indexOfGroup,2,1]],posForAllElem}]] /. tempForAllElementsMatchingTable[[indexForAll[[1]]]]->True,
groupsArrForAllElemsTable[[indexForAll[[1]],2,indexOfGroup,2,numItemsInCurrentGroup+1]] = posForAllElem;
groupsArrForAllElemsTable[[indexForAll[[1]],2,indexOfGroup,1]]++;
bFoundMatching = True;
Break[];
];
,{indexOfGroup,groupsArrForAllElemsTable[[indexForAll[[1]],1]]}];

If[!bFoundMatching ,
(*this adds a new group to the list of groups of the current forAll elem*)
groupsArrForAllElemsTable[[indexForAll[[1]],1]]++;
numOfGroupsInCurrentCluster = groupsArrForAllElemsTable[[indexForAll[[1]],1]];
groupsArrForAllElemsTable[[indexForAll[[1]],2,numOfGroupsInCurrentCluster,2,1]] = posForAllElem;(*first item in first group*)
groupsArrForAllElemsTable[[indexForAll[[1]],2,numOfGroupsInCurrentCluster,1]]++;(*number of items in first group*)
];

];
,
If[groupsArrForAllElemsTable[[indexForAll[[1]]]]===0,
(*create the first group*)
groupsArrForAllElemsTable[[indexForAll[[1]]]] = {{posForAllElem}};
,
bFoundMatching = False;
Do[(*it is enough to check a matching with the first entry *)
groupOfForAllElem = groupsArrForAllElemsTable[[indexForAll[[1]],indexOfGroup]];

If[Apply[List,Part[thePool,{groupOfForAllElem[[1]],posForAllElem}]] /. tempForAllElementsMatchingTable[[indexForAll[[1]]]]->True,
groupsArrForAllElemsTable[[indexForAll[[1]],indexOfGroup]] = {posForAllElem,groupsArrForAllElemsTable[[indexForAll[[1]],indexOfGroup]]};
bFoundMatching = True;
Break[];
];
,{indexOfGroup,Length[groupsArrForAllElemsTable[[indexForAll[[1]]]]]}];

If[!bFoundMatching ,
(*this adds a new group to the list of groups of the current forAll elem*)
PrependTo[groupsArrForAllElemsTable[[indexForAll[[1]]]],{posForAllElem}];(*Apply[List,Flatten[tempHead[tempHead[{posForAllElem}],Apply[tempHead,groupsArrForAllElemsTable[[indexForAll[[1]]]]]]]]*)
];

];

]

],posArrForAllElem];

],posArrInPoolperEachForAllElem];

If[codeOption === 1,
groupsArrForAllElemsTable = Map[Function[{groupsArr},
Map[Function[{grp},
grp[[2,Range[1,grp[[1]]]]]
],groupsArr[[2,Range[1,groupsArr[[1]]]]]]
],groupsArrForAllElemsTable];

,
groupsArrForAllElemsTable = Map[Function[{grpArr},Map[Function[{grp},Flatten[grp]],grpArr]],groupsArrForAllElemsTable];
];

(*
Print["tempForAllElementsMatchingTable[[indexForAll[[1]]]] = ",tempForAllElementsMatchingTable[[1]]];

Print["size of groupsArrForAllElemsTable = ",Map[Function[{groupsArr},Map[Function[{grp},Length[grp]],groupsArr]],groupsArrForAllElemsTable]];
Print["The first group in the pool = ",Apply[List,Part[thePool,groupsArrForAllElemsTable[[1,1]]]] ];
*)

(*this part takes about 0.2sec*)
(*verify that all the ForAll elems have at least one group*)
bForAllElemsHaveSomeMatching = True;
Scan[Function[{groupsArrForAllElem},If[groupsArrForAllElem===0,bForAllElemsHaveSomeMatching=False;]],groupsArrForAllElemsTable];

If[bForAllElemsHaveSomeMatching,

(*there is a more efficient way to do the distribute by constructing an index table of groupsArrForAllElemsTable and run ditribute over it instead*)
groupsArrForAllElemsTableDist = Distribute[groupsArrForAllElemsTable,List];

(*now check for each regular entry which cluster of groups of all the ForAll elements actualy corresponds*)
 
matchingPoolRuleCorrespondingForAllElems = Map[Function[{regElementsPoolIndexes},

matchingClusterGroupsVector=tempDelNode[];

Do[
groupsDist= groupsArrForAllElemsTableDist[[groupsDistIndex]];

(*get the first element from each group*)
forAllElementsPoolIndexes = groupsDist[[All,1]];
currentPoolVector = Flatten[{regElementsPoolIndexes,forAllElementsPoolIndexes}];
If[Length[currentPoolVector] == Length[Union[currentPoolVector]],

(* check if the rule is valid when all the elements are cosidered together *)
If[Apply[List,Part[thePool,currentPoolVector]] /. ruleLHSRegAndForAllElems->True,
matchingClusterGroupsVector = groupsDist;
Break[];
];
];
,{groupsDistIndex,Length[groupsArrForAllElemsTableDist]}];

matchingClusterGroupsVector
],matchingPoolRuleVectorsOfRegElems];

(*now remove all the reg elements in places where there was no match for the ForAll elements*)
matchingPoolRuleVectorsOfRegElems = MapThread[Function[{regElems,forAllElems},
If[Length[forAllElems]>0,regElems,tempDelNode[]]
],{matchingPoolRuleVectorsOfRegElems,matchingPoolRuleCorrespondingForAllElems}];

matchingPoolRuleVectorsOfRegElems = Apply[List,Flatten[ Apply[tempDelNode,matchingPoolRuleVectorsOfRegElems]]];
matchingPoolRuleCorrespondingForAllElems = Apply[List,Flatten[ Apply[tempDelNode,matchingPoolRuleCorrespondingForAllElems]]];

(*now for each entry of regular we need to create all combinations of the chosen cluster of groups*)

matchingPoolRuleCorrespondingForAllElems =Map[Function[{mtPoolRuleAllElements},Distribute[mtPoolRuleAllElements,List] ],matchingPoolRuleCorrespondingForAllElems];
,
matchingPoolRuleVectorsOfRegElems = {};
matchingPoolRuleCorrespondingForAllElems={};
];

];

{matchingPoolRuleVectorsOfRegElems ,matchingPoolRuleCorrespondingForAllElems}
];


SetAttributes[FindMatchingPoolRule,ReadProtected]


createVariablesToNewPoolElements[arrNewPoolItems_List]:=Module[{indContElem,arrNewVars},

If[debug,
Print["createVariablesToNewPoolElements: arrNewPoolItems = ",arrNewPoolItems];
];

arrNewVars = Map[Function[{newPoolitem},
indContElem = 0;

gPoolItemCounter++;

MapIndexed[Function[{curElem,curElemind},
If[curElem[[1]] === Head[newPoolitem],
indContElem = curElemind[[1]];
];
],gContParamStruct];

MapIndexed[Function[{curparamval,curparamIndex},

If[indContElem>0 && Length[Cases[gContParamStruct[[indContElem,2]],curparamIndex[[1]]]]>0,
(*Unique[SymbolName[Head[newPoolitem]]<>ToString[curparamIndex[[1]]]]*)

SetAttributes[Evaluate[Symbol[SymbolName[Head[newPoolitem]]<>"$params$1"]],NHoldAll];

Symbol[SymbolName[Head[newPoolitem]]<>"$params$1"][gPoolItemCounter,curparamIndex[[1]]]
,
curparamval
]
],newPoolitem]

],arrNewPoolItems];

gPoolVariables = Join[gPoolVariables,arrNewVars];

If[debug,
Print["createVariablesToNewPoolElements: gPoolVariables = ",gPoolVariables];
];

];



(*this function must be called only after gContParamStruct is created so that's after preProcessRules2*)

createStaticPoolItemsConstParams[]:= Module[{indexFound},
gStaticPoolItemsConstParams = Map[Function[{curItem},

indexFound = 0;

MapIndexed[Function[{curElem,curElemind},
If[curElem[[1]] === Head[curItem],
indContElem = curElemind[[1]];
];
],gContParamStruct];

(*return the indices of the NON-continuous parameters (the constants)*)
If[indexFound == 0,
Range[1,Length[curItem]]
,
Complement[Range[1,Length[curItem]],gContParamStruct[[indexFound,2]]]
]
],thePool];

If[debug,
Print["createStaticPoolItemsConstParams: gStaticPoolItemsConstParams = ",gStaticPoolItemsConstParams];
];

];


updateVariablesInStaticPool[posModItemsInLHS_]:=Module[{tempItemVars,curVec},

gPoolVariables[[posModItemsInLHS]] = MapThread[Function[{curItem,curItemVars,curItemConstParams},
tempItemVars = curItemVars;
tempItemVars[[curItemConstParams]] = Apply[List,curItem[[curItemConstParams]]]; 
tempItemVars
],{thePool[[posModItemsInLHS]],gPoolVariables[[posModItemsInLHS]],gStaticPoolItemsConstParams[[posModItemsInLHS]]}];

]


SetAttributes[createVariablesToNewPoolElements,ReadProtected]


addNewPoolItemsToStructs[arrNewPoolItems_List]:=Module[{bIsInContinuousRule},

gPoolObjModified = Join[gPoolObjModified,Table[True,{Length[arrNewPoolItems]}]];
gPoolObjContEqs = Join[gPoolObjContEqs,Map[Function[{curNewItem},Table[{0,methodSum},{Length[curNewItem]}] ],arrNewPoolItems]];
gPoolObjVarTypes = Join[gPoolObjVarTypes,Map[Function[{curNewItem},Table[typeVarConstant,{Length[curNewItem]}] ],arrNewPoolItems]];
If[Length[gPositionOfSpatialRules]>0,
gPoolObjSpatialConnectArr = Join[gPoolObjSpatialConnectArr,Table[{},{Length[arrNewPoolItems]}]];
gPoolObjSpatialDiscRateArr = Join[gPoolObjSpatialDiscRateArr,Table[{},{Length[arrNewPoolItems]}]];
];

];


SetAttributes[addNewPoolItemsToStructs,ReadProtected]


(*call this function AFTER actually adding the items to the pool*)
HandleNewPoolItemInRule[arrNewPoolItems_List,indexPoolOfFirstNewItem_,ruleStruct_, indexRule_]:=Module[ { currentPoolVector,arrOrderRuleElems,lenRuleElems,ruleElemsStruct,ruleElemsIndexes,inverseRuleElemsIndexes,newitemPoolvectors,curVecIndexes,newCombVecItems,curCombItems,tempMatchingPoolRuleVecs,replaceAllSec,bReturn}, 

bReturn = False;
(* reminder  - ruleLHS = {regularRuleElements,forAllRuleElements,notExistsRuleElements} *)

(* first we handle the regular rule elements *)

(* global variables used here: 

glRuleMatchingPoolItemsLocations;
glmatchingPoolRuleVectorsOfRegElems;
glRuleForAllMatchingPoolItemsLocations;
glmatchingPoolRuleCorrespondingForAllElems;
glRuleNotExistsMatchingPoolItemsLocations;
glmatchingPoolRuleCorrespondingNotExistsElems;
*)

ruleLHS = {Map[Function[{curterm},
If[Length[curterm]>0,
Map[If[Length[#]>1 && Head[#]=!= Pattern,ToExpression["_"],#]&,curterm]
,
curterm
]
],ruleStruct[[indexOfLHSElements,1]]]
,ruleStruct[[indexOfLHSElements,2]],ruleStruct[[indexOfLHSElements,3]]};

RuleMatchingPoolItemsLocations = glRuleMatchingPoolItemsLocations[[indexRule]] ;
matchingPoolRuleVectorsOfRegElems  = glmatchingPoolRuleVectorsOfRegElems[[indexRule]];
matchingPoolRuleVecsProb = glmatchingPoolRuleVecsProb[[indexRule]];
matchingPoolRuleVecReplaceAll = glmatchingPoolRuleVecReplaceAll[[indexRule]];
RuleForAllMatchingPoolItemsLocations = glRuleForAllMatchingPoolItemsLocations[[indexRule]] ;
matchingPoolRuleCorrespondingForAllElems = glmatchingPoolRuleCorrespondingForAllElems[[indexRule]] ;
RuleNotExistsMatchingPoolItemsLocations = glRuleNotExistsMatchingPoolItemsLocations[[indexRule]] ;
matchingPoolRuleCorrespondingNotExistsElems = glmatchingPoolRuleCorrespondingNotExistsElems[[indexRule]] ;

If[debug,
Print["HandleNewPoolItemInRule: START ********************* "];
Print["HandleNewPoolItemInRule: indexRule = ",indexRule];

Print["HandleNewPoolItemInRule: thePool = ", thePool];


Print["HandleNewPoolItemInRule: arrNewPoolItems = ",arrNewPoolItems];
Print["HandleNewPoolItemInRule: indexPoolOfFirstNewItem = ",indexPoolOfFirstNewItem];
Print["HandleNewPoolItemInRule: ruleLHS = ",ruleLHS];
Print["HandleNewPoolItemInRule: RuleMatchingPoolItemsLocations = ",RuleMatchingPoolItemsLocations];
Print["HandleNewPoolItemInRule: matchingPoolRuleVectorsOfRegElems = ",matchingPoolRuleVectorsOfRegElems];
Print["HandleNewPoolItemInRule: matchingPoolRuleVecsProb = ",matchingPoolRuleVecsProb];
Print["HandleNewPoolItemInRule: matchingPoolRuleVecReplaceAll = ",matchingPoolRuleVecReplaceAll];
Print["HandleNewPoolItemInRule: RuleForAllMatchingPoolItemsLocations = ",RuleForAllMatchingPoolItemsLocations];
Print["HandleNewPoolItemInRule: matchingPoolRuleCorrespondingForAllElems = ",matchingPoolRuleCorrespondingForAllElems];
Print["HandleNewPoolItemInRule: RuleNotExistsMatchingPoolItemsLocations = ",RuleNotExistsMatchingPoolItemsLocations];
];

If[Length[ruleLHS[[1]]]=!= 0  , 

timingRes1a = Timing[

(*first find which new items match the regular rule elements*)

ruleElemsNewItemsMatching =Map[Function[{lhsRegElem},

Apply[List,Flatten[Apply[tempDelNode,
MapIndexed[Function[{newPoolItem,newPoolIndex},

If[newPoolItem /. lhsRegElem->True,
(*return the index in the pool of that new item*)
newPoolIndex[[1]]+indexPoolOfFirstNewItem-1
,tempDelNode[],tempDelNode[]
]
],arrNewPoolItems]]]]

],ruleLHS[[1]]];

If[debug,Print["ruleElemsNewItemsMatching = ",ruleElemsNewItemsMatching];];

RuleMatchingPoolItemsLocationsPrev = RuleMatchingPoolItemsLocations;
(*combine the new pool item matching with the old ones*)
RuleMatchingPoolItemsLocations = MapThread[Function[{ruleElemMatchPoolItems,ruleElemesMatchNewItems},
Flatten[{ruleElemMatchPoolItems,ruleElemesMatchNewItems},1]
],{RuleMatchingPoolItemsLocations,ruleElemsNewItemsMatching}];

If[debug,Print["RuleMatchingPoolItemsLocations = ",RuleMatchingPoolItemsLocations];];

(*count how many matchings there are for each rule element*)
arrOrderRuleElems = Ordering[Map[Length[#]&,RuleMatchingPoolItemsLocations]];

If[debug,Print["arrOrderRuleElems = ",arrOrderRuleElems];];

lenRuleElems = Length[arrOrderRuleElems];

If[debug,Print["lenRuleElems = ",lenRuleElems];];

newMatchingPoolRuleVectorsOfRegElems = Flatten[MapIndexed[Function[{elem,elemIndex},

ruleElemsStruct = Flatten[{{ruleElemsNewItemsMatching[[arrOrderRuleElems[[elemIndex[[1]]]]]]},
If[elemIndex[[1]]>1,RuleMatchingPoolItemsLocationsPrev[[arrOrderRuleElems[[Range[1,elemIndex[[1]]-1]] ] ]],{}],
If[elemIndex[[1]]<lenRuleElems,RuleMatchingPoolItemsLocations[[ arrOrderRuleElems[[Range[elemIndex[[1]]+1,lenRuleElems]] ] ]],{}]},1];

(*Print["ruleElemsStruct = ",ruleElemsStruct];*)

ruleElemsIndexes = Flatten[{arrOrderRuleElems[[elemIndex[[1]]]],If[elemIndex[[1]]>1,arrOrderRuleElems[[Range[1,elemIndex[[1]]-1]]],{}],If[elemIndex[[1]]<lenRuleElems,arrOrderRuleElems[[Range[elemIndex[[1]]+1,lenRuleElems]]],{}]}];

(*Print["ruleElemsIndexes = ",ruleElemsIndexes];*)

inverseRuleElemsIndexes = Ordering[ruleElemsIndexes];

newitemPoolvectors = Map[{#}&,ruleElemsStruct[[1]]];

If[lenRuleElems>1,
MapIndexed[Function[{rlElemArr,rlElemIndex},
curVecIndexes = ruleElemsIndexes[[Range[1,rlElemIndex[[1]]+1]]];

newCombVecItems = Distribute[{newitemPoolvectors,rlElemArr},List];

newitemPoolvectors = DeleteCases[Map[Function[{curComb}, 

	(* check if the rule is valid when all the elements are cosidered together *)
curCombItems = Flatten[{curComb[[1]],{curComb[[2]]}},1];

If[Length[curCombItems] == Length[Union[curCombItems]],

If[thePool[[curCombItems]] /. ruleLHS[[1,curVecIndexes]]->True,
curCombItems
,
tempDelNode,tempDelNode
],
tempDelNode
]

],newCombVecItems],tempDelNode];

],ruleElemsStruct[[Range[2,lenRuleElems]]]];

Map[#[[inverseRuleElemsIndexes]]&,newitemPoolvectors]
,newitemPoolvectors]


],arrOrderRuleElems],1];

Map[Function[{curnewVec},

gPoolObjModified[[curnewVec]] = True;

],newMatchingPoolRuleVectorsOfRegElems];

If[debug,Print["newMatchingPoolRuleVectorsOfRegElems = ",newMatchingPoolRuleVectorsOfRegElems];];

];

If[bReturn,Return[];];

(*now we compute the probability for each new regular vector *)
If[debugTiming,Print["timingRes1a = ",timingRes1a]];
];

(*now we compute the probability for each new regular vector *)
If[debugTiming,Print["timingRes1a = ",timingRes1a]];

timingRes1b = Timing[

tempMatchingPoolRuleVecs = DeleteCases[Map[Function[{newMatchVecReg},

If[debug,Print["ruleStruct = ",ruleStruct]];
If[debug,Print["newMatchVecReg = ",newMatchVecReg]];
If[debug,Print["gPoolVariables[[newMatchVecReg]] = ",gPoolVariables[[newMatchVecReg]]]];
If[debug,Print["ruleStruct[[indexOfAppliedPartOfLHS]] = ",ruleStruct[[indexOfAppliedPartOfLHS]]]];

If[ruleStruct[[indexComplexParamsExp]]==1,

eqTermParams = Flatten[MapThread[Function[{curterm,curpoolitem},
If[Length[curterm]>0,
MapThread[Function[{termParam,poolItemParam},If[Head[termParam]===Pattern,typeTermReg[termParam[[1]]-> poolItemParam],typeTermComplex[termParam==poolItemParam]]],{Apply[List,curterm],Apply[List,curpoolitem]}]
,{}]
],{Flatten[ruleStruct[[indexOfAppliedPartOfLHS]]],gPoolVariables[[newMatchVecReg]]}]];

If[debug,Print["eqTermParams = ",eqTermParams]];

typeTermRegArr = Cases[eqTermParams,typeTermReg[_]];
If[Length[typeTermRegArr]>0,typeTermRegArr = typeTermRegArr[[All,1]];];

tempEqParams = Flatten[{Cases[eqTermParams,typeTermComplex[_]][[All,1]],
Flatten[Map[Function[{curTermRegRule},If[NumericQ[curTermRegRule[[2]]] , curTermRegRule[[1]] == (curTermRegRule[[1]]/.curTermRegRule),{}]],typeTermRegArr]]
}];

solTermParams = Solve[tempEqParams,ruleStruct[[indexOfLHSVars]]];

If[debug,Print["solTermParams = ",solTermParams]];

If[Length[solTermParams]>0,

solTermParams2 = Flatten[{First[solTermParams],typeTermRegArr}];
If[debug,Print["solTermParams2 = ",solTermParams2]];

{tempProb, tempConstraintsRules,replaceAllSec} = 
gRateFuncsStruct[[indexRule]][ruleStruct[[indexOfLHSVars]]/.solTermParams2];

If[debug,Print["guy-  tempProb 1  = ",tempProb]];
If[debug,Print["guy- tempConstraintsRules 1 = ",tempConstraintsRules]];
If[debug,Print["guy- replaceAllSec 1 = ",replaceAllSec]];

{{tempProb, tempConstraintsRules},newMatchVecReg,replaceAllSec}

,
tempDelNode
]
,

tempConstraintsRules = {};

(*change this*)
{tempProb, tempConstraintsRules,replaceAllSec} = 
gRateFuncsStruct[[indexRule]][gPoolVariables[[newMatchVecReg]]];

(*
If[Length[ruleStruct[[indexOfRHSVars]]]> 0,

{tempProb, tempConstraintsRules,replaceAllSec} = 
probtrans[ ruleStruct ][gPoolVariables[[newMatchVecReg]]];

,
tempProb =gPoolVariables[[newMatchVecReg]]/. ruleStruct[[indexOfLHSElements,1]]-> N[ruleStruct[[indexOfRateFuncStruct,1]]];
replaceAllSec = ruleStruct[[indexReplaceAll]];

];
*)

(*guy - note : tempConstraintsRules is a set of sets of rules that correspond to each possible solution of Solve*)

If[debug,Print["guy- tempProb = ",tempProb]];
If[debug,Print["guy- tempConstraintsRules = ",tempConstraintsRules]];
If[debug,Print["guy- replaceAllSec = ",replaceAllSec]];

{{tempProb, tempConstraintsRules},newMatchVecReg,replaceAllSec}
]

],newMatchingPoolRuleVectorsOfRegElems],tempDelNode];

newMatchingPoolRuleVecsProb = tempMatchingPoolRuleVecs[[All,1]];
newMatchingPoolRuleVectorsOfRegElems = tempMatchingPoolRuleVecs[[All,2]];
newMatchingPoolRuleVecsReplaceAll=tempMatchingPoolRuleVecs[[All,3]];

matchingPoolRuleVecsProb =  Flatten[{newMatchingPoolRuleVecsProb,matchingPoolRuleVecsProb},1];

matchingPoolRuleVectorsOfRegElems =  Flatten[{newMatchingPoolRuleVectorsOfRegElems,matchingPoolRuleVectorsOfRegElems},1];

matchingPoolRuleVecReplaceAll =  Flatten[{newMatchingPoolRuleVecsReplaceAll,matchingPoolRuleVecReplaceAll},1];

If[debug,Print["matchingPoolRuleVectorsOfRegElems = ",matchingPoolRuleVectorsOfRegElems];];
If[debug,Print["matchingPoolRuleVecReplaceAll = ",matchingPoolRuleVecReplaceAll];];

];

If[debugTiming,Print["timingRes1b = ",timingRes1b]];

timingRes2 = Timing[
(*Handle the ForAll elements*)
If[Length[ruleLHS[[2]]]=!= 0,

ruleLHSForAllElements = ruleLHS[[2,All,2]];
ruleLHSRegAndForAllElems = Flatten[{ruleLHS[[1]],ruleLHSForAllElements}];

ruleLHSRegAndForAllElemTable = Table[Flatten[{ruleLHS[[1]],ruleLHSForAllElements[[indexElem]]}] , {indexElem,Length[ruleLHSForAllElements]}];
(*Print["ruleLHSRegAndForAllElemTable = ",ruleLHSRegAndForAllElemTable];*)

timingRes2a = Timing[
(* go over the forAll elements and find the positions that the new pool item match*)
ruleForAllElemsNewItemsMatching =Map[Function[{lhsForAllElem},

Apply[List,Flatten[Apply[tempDelNode,
MapIndexed[Function[{newPoolItem,newPoolIndex},

If[newPoolItem /. lhsForAllElem->True,
(*return the index in the pool of that new item*)
newPoolIndex[[1]]+indexPoolOfFirstNewItem-1
,tempDelNode[],tempDelNode[]
]
],arrNewPoolItems]]]]

],ruleLHSForAllElements];

(*Print["ruleForAllElemsNewItemsMatching = ",ruleForAllElemsNewItemsMatching];*)

(*combine the new pool item matching with the old ones ,of the ForAll Elems*)
RuleForAllMatchingPoolItemsLocations = MapThread[Function[{ruleForAllElemMatchPoolItems,ruleForAllElemMatchNewItems},
Flatten[{ruleForAllElemMatchPoolItems,ruleForAllElemMatchNewItems},1]
],{RuleForAllMatchingPoolItemsLocations,ruleForAllElemsNewItemsMatching}];

(*Print["RuleForAllMatchingPoolItemsLocations = ",RuleForAllMatchingPoolItemsLocations];*)
];

If[debugTiming,Print["timingRes2a = ",timingRes2a]];

(* now for every new reg vectors that was added before (with the new item) we check if there is a matching for all items *)

timingRes2b = Timing[
newMatchingPoolRuleCorrespondingForAllElems = Map[Function[{newMatchVecReg},

(* Remark - when handling multiple ForAll elements this falatten should be changed*)
DeleteCases[
Flatten[MapIndexed[Function[{ruleForAllMatchLocs,indexRuleForAllMatchLocs},

(*we add here a list over ruleForAllMatchLocs because we are using only one item at a time and no multiple ForAll Elems , should change this to handle multi ForAll Elems *)
currentPoolVector = Flatten[{newMatchVecReg,{ruleForAllMatchLocs}},1];
If[Length[currentPoolVector] == Length[Union[currentPoolVector]],

(* check if the rule is valid when all the elements are cosidered together *)
If[thePool[[currentPoolVector]] /. ruleLHSRegAndForAllElemTable[[indexRuleForAllMatchLocs[[1]]]]->True,
ruleForAllMatchLocs
,tempDelNode,tempDelNode
],
tempDelNode
]

],RuleForAllMatchingPoolItemsLocations,{2}],1],tempDelNode,Infinity]

],newMatchingPoolRuleVectorsOfRegElems];

(*Print["newMatchingPoolRuleCorrespondingForAllElems = ",newMatchingPoolRuleCorrespondingForAllElems];*)

matchingPoolRuleCorrespondingForAllElems =  Flatten[{newMatchingPoolRuleCorrespondingForAllElems,matchingPoolRuleCorrespondingForAllElems},1];

(*Print["matchingPoolRuleCorrespondingForAllElems = ",matchingPoolRuleCorrespondingForAllElems];*)

];

If[debugTiming,Print["timingRes2b = ",timingRes2b]];

(* now we add the new items tat matched a forAll elements to their correspoding reg vectors
Remark - important , we assume that there is only one ForAll element in a rule
*)

(*
Print["matchingPoolRuleVectorsOfRegElems = ",matchingPoolRuleVectorsOfRegElems];
Print["matchingPoolRuleCorrespondingForAllElems = ",matchingPoolRuleCorrespondingForAllElems];
Print["ruleLHSRegAndForAllElemTable = ",ruleLHSRegAndForAllElemTable];
*)

timingRes2c = Timing[
matchingPoolRuleCorrespondingForAllElems = MapThread[Function[{matchRuleRegVec,matchRuleCorspndForAll},

(*Remark - in order to have multiple ForAll Elements should change this Flatten (and the next one)  so it will flat only the second level*)
Flatten[{matchRuleCorspndForAll,

DeleteCases[
Flatten[MapIndexed[Function[{rlForAllElmNewItem,indexRlForAllNewItem},

(* the same remark as before about the list over rlForAllElmNewItem*)
currentPoolVector = Flatten[{matchRuleRegVec,{rlForAllElmNewItem}},1];
If[Length[currentPoolVector] == Length[Union[currentPoolVector]],

(* check if the rule is valid when all the elements are cosidered together *)
If[thePool[[currentPoolVector]]/. ruleLHSRegAndForAllElemTable[[indexRlForAllNewItem[[1]]]]->True,
rlForAllElmNewItem,
tempDelNode,tempDelNode]
,
tempDelNode]

],ruleForAllElemsNewItemsMatching,{2}],1],tempDelNode,Infinity]
},1]

],{matchingPoolRuleVectorsOfRegElems,matchingPoolRuleCorrespondingForAllElems}];

(*Print["matchingPoolRuleCorrespondingForAllElems = ",matchingPoolRuleCorrespondingForAllElems];*)
];

If[debugTiming,Print["timingRes2c = ",timingRes2c]];
]];

If[debugTiming,Print["timingRes2 = ",timingRes2]];


(*handle the NotExists elements*)
If[Length[ruleLHS[[3]]]> 0,

ruleLHSNotExistsElements = ruleLHS[[3,All,2]];

ruleLHSRegAndNotExistsElemTable = Table[Flatten[{ruleLHS[[1]],ruleLHSNotExistsElements[[indexElem]]}] , {indexElem,Length[ruleLHSNotExistsElements]}];
If[debug,Print["ruleLHSRegAndNotExistsElemTable = ",ruleLHSRegAndNotExistsElemTable];];

(*first find which new items match the regular rule elements*)

ruleNotExistsElemsNewItemsMatching =Map[Function[{lhsNotExistsElem},

DeleteCases[
MapIndexed[Function[{newPoolItem,newPoolIndex},

If[newPoolItem /. lhsNotExistsElem->True,
(*return the index in the pool of that new item*)
newPoolIndex[[1]]+indexPoolOfFirstNewItem-1
,tempDelNode,tempDelNode
]
],arrNewPoolItems],tempDelNode,Infinity]

],ruleLHSNotExistsElements];

If[debug,Print["ruleNotExistsElemsNewItemsMatching = ",ruleNotExistsElemsNewItemsMatching];];

(*combine the new pool item matching with the old ones*)
RuleNotExistsMatchingPoolItemsLocations = MapThread[Function[{ruleNotExistsElemMatchPoolItems,ruleNotExistsElemesMatchNewItems},
Flatten[{ruleNotExistsElemMatchPoolItems,ruleNotExistsElemesMatchNewItems},1]
],{RuleNotExistsMatchingPoolItemsLocations,ruleNotExistsElemsNewItemsMatching}];

If[debug,Print["RuleNotExistsMatchingPoolItemsLocations = ",RuleNotExistsMatchingPoolItemsLocations];];

(* now for every new reg vectors that was added before (with the new item) we check if there is a matching NotExists items *)

timingRes3b = Timing[
newMatchingPoolRuleCorrespondingNotExistsElems = Map[Function[{newMatchVecReg},

DeleteCases[
Flatten[MapIndexed[Function[{ruleNotExistsMatchLocs,indexRuleNotExistsMatchLocs},

currentPoolVector = Flatten[{newMatchVecReg,{ruleNotExistsMatchLocs}},1];
If[Length[currentPoolVector] == Length[Union[currentPoolVector]],

(* check if the rule is valid when all the elements are cosidered together *)
If[thePool[[currentPoolVector]] /. ruleLHSRegAndNotExistsElemTable[[indexRuleNotExistsMatchLocs[[1]]]]->True,
ruleNotExistsMatchLocs
,tempDelNode,tempDelNode
],
tempDelNode
]

],RuleNotExistsMatchingPoolItemsLocations,{2}],1],tempDelNode,Infinity]

],newMatchingPoolRuleVectorsOfRegElems];

matchingPoolRuleCorrespondingNotExistsElems =  Flatten[{newMatchingPoolRuleCorrespondingNotExistsElems,matchingPoolRuleCorrespondingNotExistsElems},1];

];

If[debugTiming,Print["timingRes3b = ",timingRes3b]];

(* now we add the new items that matched a NotExists elements to their correspoding reg vectors
*)

timingRes3c = Timing[
matchingPoolRuleCorrespondingNotExistsElems = MapThread[Function[{matchRuleRegVec,matchRuleCorspndNotExists},

Flatten[{matchRuleCorspndNotExists,

DeleteCases[

Flatten[MapIndexed[Function[{rlNotExistsElmNewItem,indexRlNotExistsNewItem},

currentPoolVector = Flatten[{matchRuleRegVec,{rlNotExistsElmNewItem}},1];
If[Length[currentPoolVector] == Length[Union[currentPoolVector]],

(* check if the rule is valid when all the elements are cosidered together *)
If[thePool[[currentPoolVector]] /. ruleLHSRegAndNotExistsElemTable[[indexRlNotExistsNewItem[[1]]]]->True,
rlNotExistsElmNewItem,
tempDelNode,tempDelNode]
,
tempDelNode]

],ruleNotExistsElemsNewItemsMatching,{2}],1],tempDelNode,Infinity]
},1]

],{matchingPoolRuleVectorsOfRegElems,matchingPoolRuleCorrespondingNotExistsElems}];

];

If[debugTiming,Print["timingRes3c = ",timingRes3c]];

];


If[debug,
Print["Resutls:"];

Print["HandleNewPoolItemInRule: RuleMatchingPoolItemsLocations = ",RuleMatchingPoolItemsLocations];
Print["HandleNewPoolItemInRule: matchingPoolRuleVectorsOfRegElems = ",matchingPoolRuleVectorsOfRegElems];
Print["HandleNewPoolItemInRule: RuleForAllMatchingPoolItemsLocations = ",RuleForAllMatchingPoolItemsLocations];
Print["HandleNewPoolItemInRule: matchingPoolRuleCorrespondingForAllElems = ",matchingPoolRuleCorrespondingForAllElems];
Print["HandleNewPoolItemInRule: RuleNotExistsMatchingPoolItemsLocations = ",RuleNotExistsMatchingPoolItemsLocations];
Print["HandleNewPoolItemInRule: matchingPoolRuleCorrespondingNotExistsElems = ",matchingPoolRuleCorrespondingNotExistsElems];
Print["HandleNewPoolItemInRule: matchingPoolRuleVecsProb = ",matchingPoolRuleVecsProb]
];


glRuleMatchingPoolItemsLocations[[indexRule]] = RuleMatchingPoolItemsLocations;
glmatchingPoolRuleVectorsOfRegElems[[indexRule]] = matchingPoolRuleVectorsOfRegElems;
glmatchingPoolRuleVecsProb[[indexRule]] = matchingPoolRuleVecsProb ;
glmatchingPoolRuleVecReplaceAll[[indexRule]] = matchingPoolRuleVecReplaceAll;
glRuleForAllMatchingPoolItemsLocations[[indexRule]] = RuleForAllMatchingPoolItemsLocations;
glmatchingPoolRuleCorrespondingForAllElems[[indexRule]] = matchingPoolRuleCorrespondingForAllElems;
glRuleNotExistsMatchingPoolItemsLocations[[indexRule]] = RuleNotExistsMatchingPoolItemsLocations;
glmatchingPoolRuleCorrespondingNotExistsElems[[indexRule]] = matchingPoolRuleCorrespondingNotExistsElems;

glNewMatchingPoolRuleVectorsOfRegElems[[indexRule]] = newMatchingPoolRuleVectorsOfRegElems;

];


SetAttributes[HandleNewPoolItemInRule,ReadProtected]


setStaticPoolStruct[]:=Module[{arrMapPoolItemToVecs,curModifiedItems},

If[debug,
Print["setStaticPoolStruct: glmatchingPoolRuleVectorsOfRegElems = ",glmatchingPoolRuleVectorsOfRegElems];
Print["setStaticPoolStruct: gFullLHSModifiedElems = ",gFullLHSModifiedElems];
];

arrMapPoolItemToVecs = Table[{},{Length[thePool]}];

(*first - mapping from each item to the set of vectors that it apears in*)
MapIndexed[Function[{curRlVecs,curRlInd},
MapIndexed[Function[{curVec,curVecInd},
Map[AppendTo[arrMapPoolItemToVecs[[#]],{curRlInd[[1]],curVecInd[[1]]}]&,curVec]
],curRlVecs]
],glmatchingPoolRuleVectorsOfRegElems];

If[debug,
Print["setStaticPoolStruct: arrMapPoolItemToVecs = ",arrMapPoolItemToVecs];
];

(*this maps each vector to the set of vectors that that have some overlap (intersection). Because when this vector is modified then all the other overlapping vectors' rates should be modified*)
gStaticPoolVecsToVecs = MapIndexed[Function[{curRlVecs,curRlInd},
MapIndexed[Function[{curVec,curVecInd},

curModifiedItems = curVec[[gFullLHSModifiedElems[[curRlInd[[1]]]]]];
Union[Flatten[arrMapPoolItemToVecs[[curModifiedItems]],1]]
],curRlVecs]
],glmatchingPoolRuleVectorsOfRegElems];

If[debug,
Print["setStaticPoolStruct: gStaticPoolVecsToVecs = ",gStaticPoolVecsToVecs];
];

]


SetAttributes[setStaticPoolStruct,ReadProtected]


gbUseDelanauy = False;


createSpatialConnections[]:=Module[{},

If[gbUseDelanauy,
createSpatialConnectionsDelanauy[];
,
createSpatialConnectionsKDT[];
];

]


useDynamicalPlanes = True;(*see above*)


createSpatialConnectionsKDT[]:=Module[{arrSpRads,arrnbrs,arrSpPoints,arrSppoints,curObjsPerElem,nonSptialElemPos,matchingPoolRuleVecsProb,arrSpIPndexes,arrSpatialObjGrp,curEdges,dtRes,bAreNbrs,nbrindex,arrPoolObjSpatialExistsConnect,arrPlaneConnections,indexFirstPlaneConnect},
(*NOTE  1. - this function does not take care of ForAll,Exist etc.*)
(*NOTE  2. - this function currently DOES NOT support rules that have more than 2 spatial elements. 
Should change te creation of arrSpatialObjGrp to contain vectors of multiple elements and not only 2 (edges)*)

If[debug,
Print["createSpatialConnections : "];
];

arrSpPoints = DeleteCases[MapIndexed[Function[{curObj,curObjInd},

If[Length[curObj]>0  && Head[curObj] === gSpatialObject,
{Apply[List,curObj][[gSpatialObjCoordParams]] ,curObjInd[[1]],curObj[[gSpatialObjRadParam]]}
,
0
]
],thePool],0];

If[debug,
Print["createSpatialConnections : gSpatialObjCoordParams = ",gSpatialObjCoordParams];
Print["createSpatialConnections : arrSpPoints = ",arrSpPoints];
];

arrSpatialObjGrp = {};

If[Length[arrSpPoints]>= 0,

arrSppoints = arrSpPoints[[All,1]];
arrSpIPndexes = arrSpPoints[[All,2]];
arrSpRads = arrSpPoints[[All,3]];


timeplanar = Timing[

gyKDTreeCreate[arrSppoints,arrSpRads];

arrSpatialObjGrp = Flatten[MapThread[Function[{curpnt,curpntRad,curpntind},

arrnbrs = gyKDTreeGetRangeWithRad[curpnt,curpntRad,gSpObjConnectionDistance];

DeleteCases[Map[Function[{curnbr},
If[curnbr>curpntind,{arrSpIPndexes[[curpntind]],arrSpIPndexes[[curnbr]]},0]
],arrnbrs],0]

],{arrSppoints,arrSpRads,Range[1,Length[arrSppoints]]}],1];

];
If[debugTiming,Print["timeplanar 1  = ",timeplanar];];

];

If[debug,
Print["createSpatialConnections : arrSpatialObjGrp = ",arrSpatialObjGrp];

tempLines = Map[Function[{curgrp},
Line[{Apply[List,thePool[[curgrp[[1]]]]][[gSpatialObjCoordParams]],Apply[List,thePool[[curgrp[[2]]]]][[gSpatialObjCoordParams]]}]
],arrSpatialObjGrp];

If[Length[gSpatialObjCoordParams]>2,
(*3D*)
Show[Graphics3D[tempLines]]
,
(*2D*)
Show[Graphics[tempLines]]
];

];

arrPlaneConnections = createPlaneConnections[arrSpPoints];
If[debug,
Print["after createPlaneConnections : arrPlaneConnections = ",arrPlaneConnections];
];

indexFirstPlaneConnect = Length[arrSpatialObjGrp]+1;
arrSpatialObjGrp = Join[arrSpatialObjGrp,arrPlaneConnections];

(*this to mark neighboring cells that got disconnected*)
arrPoolObjSpatialExistsConnect = Map[Function[{curentry},Table[False,{Length[curentry]}]],gPoolObjSpatialConnectArr];

If[debug,
Print["after createSpatialConnections : gPoolObjSpatialConnectArr = ",gPoolObjSpatialConnectArr];
Print["after createSpatialConnections : arrPoolObjSpatialExistsConnect = ",arrPoolObjSpatialExistsConnect];
Print["after createSpatialConnections : gPoolObjModified = ",gPoolObjModified];
];

(*mark all the new neighbors*)
MapIndexed[Function[{cursptEdge,cursptEdgeInd},
bAreNbrs = False;
MapIndexed[Function[{curNbr,curNbrInd},
If[curNbr == cursptEdge[[2]],
bAreNbrs = True;
nbrindex = curNbrInd[[1]];
]
],gPoolObjSpatialConnectArr[[cursptEdge[[1]]]]];

If[bAreNbrs,
arrPoolObjSpatialExistsConnect[[cursptEdge[[1]],nbrindex]] = True;

If[cursptEdgeInd[[1]]<indexFirstPlaneConnect || useDynamicalPlanes,
MapIndexed[Function[{curNbr,curNbrInd},
If[curNbr == cursptEdge[[1]],
nbrindex = curNbrInd[[1]];
]
],gPoolObjSpatialConnectArr[[cursptEdge[[2]]]]];

arrPoolObjSpatialExistsConnect[[cursptEdge[[2]],nbrindex]] = True;
];

,
AppendTo[gPoolObjSpatialConnectArr[[cursptEdge[[1]]]],cursptEdge[[2]]];
gPoolObjSpatialDiscRateArr[[cursptEdge[[1]]]] = {};
gPoolObjModified[[cursptEdge[[1]]]] = True;

If[cursptEdgeInd[[1]]<indexFirstPlaneConnect || useDynamicalPlanes,
AppendTo[gPoolObjSpatialConnectArr[[cursptEdge[[2]]]],cursptEdge[[1]]];
gPoolObjSpatialDiscRateArr[[cursptEdge[[2]]]] = {};
gPoolObjModified[[cursptEdge[[2]]]] = True;
];

];

],arrSpatialObjGrp];

If[debug,
Print["createSpatialConnections : after arrPoolObjSpatialExistsConnect = ",arrPoolObjSpatialExistsConnect];
Print["createSpatialConnections : after gPoolObjModified = ",gPoolObjModified];
];

(*mark all the disconected neighbors - and delete their entries in gPoolObjSpatialConnectArr - have to delete in reverse order *)
MapIndexed[Function[{curObjConnections,curObjInd},
MapThread[Function[{curIsConnectedNbr,curnbrInd},

If[!curIsConnectedNbr,
gPoolObjModified[[curObjInd[[1]]]] = True;
gPoolObjSpatialConnectArr[[curObjInd[[1]]]] = Delete[gPoolObjSpatialConnectArr[[curObjInd[[1]]]],curnbrInd];
gPoolObjSpatialDiscRateArr[[curObjInd[[1]]]] = {};
];

],{Reverse[curObjConnections],Reverse[Range[1,Length[curObjConnections]]]}]
],arrPoolObjSpatialExistsConnect];

If[debug,
Print["createSpatialConnections : after gPoolObjSpatialConnectArr = ",gPoolObjSpatialConnectArr];
];

];


(*SetAttributes[createSpatialConnectionsKDT,ReadProtected]*)


createSpatialConnectionsDelanauy[]:=Module[{arrSpPoints,points,curObjsPerElem,nonSptialElemPos,matchingPoolRuleVecsProb,arrSpIPndexes,arrSpatialObjGrp,curEdges,dtRes,bAreNbrs,nbrindex,arrPoolObjSpatialExistsConnect,arrPlaneConnections,indexFirstPlaneConnect},
(*NOTE  1. - this function does not take care of ForAll,Exist etc.*)
(*NOTE  2. - this function currently DOES NOT support rules that have more than 2 spatial elements. 
Should change te creation of arrSpatialObjGrp to contain vectors of multiple elements and not only 2 (edges)*)

If[debug,
Print["createSpatialConnections : "];
];

arrSpPoints = DeleteCases[MapIndexed[Function[{curObj,curObjInd},

If[Length[curObj]>0  && Head[curObj] === gSpatialObject,
{Apply[List,curObj][[gSpatialObjCoordParams]] ,curObjInd[[1]]}
,
0
]
],thePool],0];

If[debug,
Print["createSpatialConnections : arrSpPoints = ",arrSpPoints];
];

arrSpatialObjGrp = {};


If[Length[arrSpPoints]>= Length[gSpatialObjCoordParams]+2,

points = arrSpPoints[[All,1]];
arrSpIPndexes = arrSpPoints[[All,2]];


timeplanar = Timing[

dtRes=delaunayTriangulation[points(*,delaunayFormat->{edgeCoordinates-> True,regions-> True,regionCoordinates-> True}*)];
curEdges = edges/.dtRes;
If[debug,Print[" delaunayTriangulation - curEdges  = ",curEdges];];

];
If[debugTiming,Print["timeplanar 1  = ",timeplanar];];


arrSpatialObjGrp = Map[Function[{cedge},
{arrSpIPndexes[[cedge[[1]]]],arrSpIPndexes[[cedge[[2]]]]}
],curEdges];


,
If[Length[arrSpPoints]> 0,

arrSpIPndexes = arrSpPoints[[All,2]];
arrSpatialObjGrp = Subsets[arrSpIPndexes,{2}];
];

];


If[debug,
Print["createSpatialConnections : arrSpatialObjGrp = ",arrSpatialObjGrp];

tempLines = Map[Function[{curgrp},
Line[{Apply[List,thePool[[curgrp[[1]]]]][[gSpatialObjCoordParams]],Apply[List,thePool[[curgrp[[2]]]]][[gSpatialObjCoordParams]]}]
],arrSpatialObjGrp];

If[Length[gSpatialObjCoordParams]>2,
(*3D*)
Show[Graphics3D[tempLines]]
,
(*2D*)
Show[Graphics[tempLines]]
];

];

arrSpatialObjGrp = deleteDistantNeighbors[arrSpatialObjGrp];
arrPlaneConnections = createPlaneConnections[arrSpPoints];
If[debug,
Print["after createPlaneConnections : arrPlaneConnections = ",arrPlaneConnections];
];

indexFirstPlaneConnect = Length[arrSpatialObjGrp]+1;
arrSpatialObjGrp = Join[arrSpatialObjGrp,arrPlaneConnections];


(*this to mark neighboring cells that got disconnected*)
arrPoolObjSpatialExistsConnect = Map[Function[{curentry},Table[False,{Length[curentry]}]],gPoolObjSpatialConnectArr];

If[debug,
Print["after createSpatialConnections : gPoolObjSpatialConnectArr = ",gPoolObjSpatialConnectArr];
Print["after createSpatialConnections : arrPoolObjSpatialExistsConnect = ",arrPoolObjSpatialExistsConnect];
Print["after createSpatialConnections : gPoolObjModified = ",gPoolObjModified];
];

(*mark all the new neighbors*)
MapIndexed[Function[{cursptEdge,cursptEdgeInd},
bAreNbrs = False;
MapIndexed[Function[{curNbr,curNbrInd},
If[curNbr == cursptEdge[[2]],
bAreNbrs = True;
nbrindex = curNbrInd[[1]];
]
],gPoolObjSpatialConnectArr[[cursptEdge[[1]]]]];

If[bAreNbrs,
arrPoolObjSpatialExistsConnect[[cursptEdge[[1]],nbrindex]] = True;

If[cursptEdgeInd[[1]]<indexFirstPlaneConnect,
MapIndexed[Function[{curNbr,curNbrInd},
If[curNbr == cursptEdge[[1]],
nbrindex = curNbrInd[[1]];
]
],gPoolObjSpatialConnectArr[[cursptEdge[[2]]]]];

arrPoolObjSpatialExistsConnect[[cursptEdge[[2]],nbrindex]] = True;
];

,
AppendTo[gPoolObjSpatialConnectArr[[cursptEdge[[1]]]],cursptEdge[[2]]];
gPoolObjSpatialDiscRateArr[[cursptEdge[[1]]]] = {};
gPoolObjModified[[cursptEdge[[1]]]] = True;

If[cursptEdgeInd[[1]]<indexFirstPlaneConnect,
AppendTo[gPoolObjSpatialConnectArr[[cursptEdge[[2]]]],cursptEdge[[1]]];
gPoolObjSpatialDiscRateArr[[cursptEdge[[2]]]] = {};
gPoolObjModified[[cursptEdge[[2]]]] = True;
];

];

],arrSpatialObjGrp];

If[debug,
Print["createSpatialConnections : after arrPoolObjSpatialExistsConnect = ",arrPoolObjSpatialExistsConnect];
Print["createSpatialConnections : after gPoolObjModified = ",gPoolObjModified];
];

(*mark all the disconected neighbors - and delete their entries in gPoolObjSpatialConnectArr - have to delete in reverse order *)
MapIndexed[Function[{curObjConnections,curObjInd},
MapThread[Function[{curIsConnectedNbr,curnbrInd},

If[!curIsConnectedNbr,
gPoolObjModified[[curObjInd[[1]]]] = True;
gPoolObjSpatialConnectArr[[curObjInd[[1]]]] = Delete[gPoolObjSpatialConnectArr[[curObjInd[[1]]]],curnbrInd];
gPoolObjSpatialDiscRateArr[[curObjInd[[1]]]] = {};
];

],{Reverse[curObjConnections],Reverse[Range[1,Length[curObjConnections]]]}]
],arrPoolObjSpatialExistsConnect];


If[debug,
Print["createSpatialConnections : after gPoolObjSpatialConnectArr = ",gPoolObjSpatialConnectArr];
];

];


SetAttributes[createSpatialConnectionsDelanauy,ReadProtected]


deleteDistantNeighbors[arrSpatialObjGrp_]:=Module[{arrAdjSpatialObjGrp},
If[debug,
Print["deleteDistantNeighbors: arrSpatialObjGrp = ",arrSpatialObjGrp];
];

arrAdjSpatialObjGrp = DeleteCases[Map[Function[{curSpObjGrp},

(*the squared distance between the objects*)
If[\[Sqrt]Total[(Apply[List,thePool[[curSpObjGrp[[1]]]]][[gSpatialObjCoordParams]]-Apply[List,thePool[[curSpObjGrp[[2]]]]][[gSpatialObjCoordParams]])^2] - (thePool[[curSpObjGrp[[1]]]][[gSpatialObjRadParam]] + thePool[[curSpObjGrp[[2]]]][[gSpatialObjRadParam]])<gSpObjConnectionDistance,
curSpObjGrp
,
0
]
],arrSpatialObjGrp],0];

If[debug,
Print["deleteDistantNeighbors: arrAdjSpatialObjGrp = ",arrAdjSpatialObjGrp];
];

arrAdjSpatialObjGrp
];


SetAttributes[deleteDistantNeighbors,ReadProtected]


createPlaneConnections[arrSpPoints_]:=Module[{arrLPlaneConnections={},arrRPlaneConnections={},arrBPlaneConnections={},arrTPlaneConnections={}},
arrXPlaneConnections = arrYPlaneConnections = {};

If[gbIsSpatialLeftBound,
arrLPlaneConnections = createPlaneConnections[arrSpPoints,gSpatialLeftBound,1,1];
];
If[gbIsSpatialRightBound,
arrRPlaneConnections = createPlaneConnections[arrSpPoints,gSpatialRightBound,1,2];
];
If[gbIsSpatialBottomBound,
arrBPlaneConnections = createPlaneConnections[arrSpPoints,gSpatialBottomBound,2,1];
];
If[gbIsSpatialTopBound,
arrTPlaneConnections = createPlaneConnections[arrSpPoints,gSpatialTopBound,2,2];
];

Join[arrLPlaneConnections,arrRPlaneConnections,arrBPlaneConnections,arrTPlaneConnections]
];


SetAttributes[createPlaneConnections,ReadProtected]


createPlaneConnections[arrSpPoints_,curSpatialPlane_,curPlaneCoord_,inDirection_]:=Module[{arrPlanes,arrPlaneConnections,curpoint},
If[debug,
Print["createPlaneConnections: {arrSpPoints,curSpatialPlane,curPlaneCoord} = ",{arrSpPoints,curSpatialPlane,curPlaneCoord}];
];

arrPlanes = DeleteCases[MapIndexed[Function[{curObj,curObjInd},

If[Length[curObj]>0  && Head[curObj] === curSpatialPlane,
{curObj[[1]],curObjInd[[1]]}
,
0
]
],thePool],0];


(*go over the points and find the ones that are in the range*)
arrPlaneConnections = Flatten[Map[Function[{curpointStrct},
curpoint = curpointStrct[[1,curPlaneCoord]];
(*go over the planes to find the ones that are in range*)
DeleteCases[Map[Function[{curplane},
If[Abs[curpoint - curplane[[1]]]-thePool[[curpointStrct[[2]]]][[gSpatialObjRadParam]]< gSpPlaneConnectionDistance || (inDirection == 1 && curpoint-thePool[[curpointStrct[[2]]]][[gSpatialObjRadParam]]< curplane[[1]])|| (inDirection == 2 && curpoint+thePool[[curpointStrct[[2]]]][[gSpatialObjRadParam]]> curplane[[1]]),
{curpointStrct[[2]],curplane[[2]]}
,
0
]
],arrPlanes],0]
],arrSpPoints],1];

If[debug,
Print["createPlaneConnections: arrPlaneConnections = ",arrPlaneConnections];
];

arrPlaneConnections
]


resetPoolObjModified[]:=Module[{},

gPoolObjModified[[All]] = False;
];


calcSpatialDiscRulesRates[]:=Module[{arrruleLHS,ruleLHS,curObjsPerElem,tempProb, tempConstraintsRules,replaceAllSec,arrNewProbs},

If[Length[gPosSpatialDiscRules]>0,
arrruleLHS =  MapIndexed[Function[{ruleStruct,indexRule},

If[debug,Print["calcSpatialDiscRulesRates: {ruleStruct, indexRule[[1]]} = ",{ruleStruct, indexRule[[1]]}];];

ruleLHS = Map[Function[{curterm},
If[Length[curterm]>0,
Map[If[Length[#]>1 && Head[#]=!= Pattern,ToExpression["_"],#]&,curterm]
,
curterm
]
],ruleStruct[[indexOfLHSElements,1]]];

If[debug,Print["calcSpatialDiscRulesRates: ruleLHS = ",ruleLHS];];

ruleLHS

],preReleasegramtrans];

MapThread[Function[{curObjMod,curObjConnetions,curObjInd},
If[curObjMod,

If[debug,
Print["calcSpatialDiscRulesRates : {curObjMod,curObjConnetions,curObjInd} = ",{curObjMod,curObjConnetions,curObjInd}];
];

arrNewProbs = MapThread[Function[{curnbr,curnbrind},

DeleteCases[MapThread[Function[{ruleStruct,curruleLHS,indexRule},

If[MemberQ[gPositionOfDiscRules,indexRule] && MemberQ[gPositionOfSpatialRules,indexRule],

If[debug,Print["calcSpatialDiscRulesRates: {ruleStruct, indexRule} = ",{ruleStruct, indexRule}];];

If[debug,
Print["calcSpatialDiscRulesRates : {curnbr,curnbrind} = ",{curnbr,curnbrind}];
];

curObjsPerElem = Table[{},{Length[gGrammarRulesLHS[[indexRule]]]}];

If[debug,
Print["calcSpatialDiscRulesRates : curObjsPerElem1  = ",curObjsPerElem];
];

curObjsPerElem[[gSpatialRulesElemPos[[indexRule]]]] = {{curObjInd},{curnbrind}};

nonSptialElemPos = Complement[Range[1,Length[gGrammarRulesLHS[[indexRule]]]],gSpatialRulesElemPos[[indexRule]]];

If[Length[nonSptialElemPos]>0,
curObjsPerElem[[nonSptialElemPos]] = glRuleMatchingPoolItemsLocations[[indexRule]][[nonSptialElemPos]]
];

If[debug,
Print["calcSpatialDiscRulesRates : curObjsPerElem = ",curObjsPerElem];
];

DeleteCases[Map[Function[{curObjsVec},

(* check if the rule is valid when all the elements are cosidered together *)
If[Apply[List,Part[thePool,curObjsVec]] /. curruleLHS->True,

tempConstraintsRules = {};

(*change this*)
{tempProb, tempConstraintsRules,replaceAllSec} = 
gRateFuncsStruct[[indexRule]][gPoolVariables[[curObjsVec]]];

(*guy - note : tempConstraintsRules is a set of sets of rules that correspond to each possible solution of Solve*)

If[debug,Print["calcSpatialDiscRulesRates- tempProb = ",tempProb]];
If[debug,Print["calcSpatialDiscRulesRates- tempConstraintsRules = ",tempConstraintsRules]];
If[debug,Print["calcSpatialDiscRulesRates- replaceAllSec = ",replaceAllSec]];

{{tempProb, tempConstraintsRules},newMatchVecReg,replaceAllSec}
,
0
]

],Distribute[curObjsPerElem,List]],0]
,
0
]
],{preReleasegramtrans,arrruleLHS,Range[1,Length[preReleasegramtrans]]}],0]

],{curObjConnetions,Range[1,Length[curObjConnetions]]}];


gPoolObjSpatialDiscRateArr[[curObjInd[[1]]]] = arrNewProbs;

];
],{gPoolObjModified,gPoolObjSpatialConnectArr,Range[1,Length[gPoolObjSpatialConnectArr]]}];

Map[Function[{indexRule},
glmatchingPoolRuleVectorsOfRegElems[[indexRule]] = Flatten[Map[Function[{curobjSp},
Flatten[Map[Function[{curobjSpNbr},
curobjSpNbr[[indexRule,All,2]]
],curobjSp],1]

],gPoolObjSpatialDiscRateArr],1];

glmatchingPoolRuleVecsProb[[indexRule]] = Flatten[Map[Function[{curobjSp},
Flatten[Map[Function[{curobjSpNbr},
curobjSpNbr[[indexRule,All,1]]
],curobjSp],1]

],gPoolObjSpatialDiscRateArr],1];
],Range[1,Length[preReleasegramtrans]]];


];

]


SetAttributes[calcSpatialDiscRulesRates,ReadProtected]


removeFreePoolVars[curposDeleteElements_]:=Module[{},

(*Map[Function[{curObj},Map[Function[{curParamvar},Remove[curParamvar]],curObj]],gPoolVariables[[curposDeleteElements]]];*)

gPoolVariables = Delete[gPoolVariables, Partition[curposDeleteElements,1]];
];


SetAttributes[removeFreePoolVars,ReadProtected]


(*call this function BEFORE actually deleting the items from the pool*)
HandleDeletedPoolItems[arrDeletedPoolItemsIndexes_]:=Module[{arrtempRes},

timingResDel1 = Timing[
sortArrDeletedPoolItemsIndexes = Union[arrDeletedPoolItemsIndexes];
];
If[debugTiming,Print["timingResDel1 = ",timingResDel1]];

If[debug,
Print["inside HandleDeletedPoolItems"];
Print["sortArrDeletedPoolItemsIndexes = ",sortArrDeletedPoolItemsIndexes];
Print["glRuleMatchingPoolItemsLocations = ",glRuleMatchingPoolItemsLocations];
Print["glRuleForAllMatchingPoolItemsLocations = ",glRuleForAllMatchingPoolItemsLocations];
Print["glmatchingPoolRuleVectorsOfRegElems = ",glmatchingPoolRuleVectorsOfRegElems];
Print["glmatchingPoolRuleVecsProb = ",glmatchingPoolRuleVecsProb];
Print["glmatchingPoolRuleVecReplaceAll = ",glmatchingPoolRuleVecReplaceAll];
Print["glmatchingPoolRuleCorrespondingForAllElems = ",glmatchingPoolRuleCorrespondingForAllElems];
Print["glRuleNotExistsMatchingPoolItemsLocations = ",glRuleNotExistsMatchingPoolItemsLocations];
Print["glmatchingPoolRuleCorrespondingNotExistsElems = ",glmatchingPoolRuleCorrespondingNotExistsElems];

Print["gPoolObjModified = ",gPoolObjModified];
Print["gPoolObjContEqs = ",gPoolObjContEqs];
Print["gPoolObjVarTypes = ",gPoolObjVarTypes];

];

If[Length[sortArrDeletedPoolItemsIndexes]<=0,
If[debug,
Print["exit HandleDeletedPoolItems, no items to delete"];
];
Return[];
];

(*first go over all the global variables and remove the entries of the deleted items*)
arrDeletedPoolItems = Range[Length[thePool]];
arrDeletedPoolItems[[sortArrDeletedPoolItemsIndexes]] = 0;

timingResDel2 = Timing[

glRuleMatchingPoolItemsLocations = DeleteCases[Map[Function[{curRElemMatchPoolItem},
If[arrDeletedPoolItems[[curRElemMatchPoolItem]]>0,
curRElemMatchPoolItem
,
tempDelNode
]
],glRuleMatchingPoolItemsLocations,{3}],tempDelNode,Infinity];

glRuleForAllMatchingPoolItemsLocations = DeleteCases[Map[Function[{curRElemMatchPoolItem},

If[arrDeletedPoolItems[[curRElemMatchPoolItem]]>0,
curRElemMatchPoolItem
,
tempDelNode
]
],glRuleForAllMatchingPoolItemsLocations,{3}],tempDelNode,Infinity];

glmatchingPoolRuleCorrespondingForAllElems = DeleteCases[Map[Function[{curRElemMatchPoolItem},

If[arrDeletedPoolItems[[curRElemMatchPoolItem]]>0,
curRElemMatchPoolItem
,
tempDelNode
]
],glmatchingPoolRuleCorrespondingForAllElems,{3}],tempDelNode,Infinity];

glRuleNotExistsMatchingPoolItemsLocations = DeleteCases[Map[Function[{curRElemMatchPoolItem},

If[arrDeletedPoolItems[[curRElemMatchPoolItem]]>0,
curRElemMatchPoolItem
,
tempDelNode
]
],glRuleNotExistsMatchingPoolItemsLocations,{3}],tempDelNode,Infinity];

glmatchingPoolRuleCorrespondingNotExistsElems = DeleteCases[Map[Function[{curRElemMatchPoolItem},

If[arrDeletedPoolItems[[curRElemMatchPoolItem]]>0,
curRElemMatchPoolItem
,
tempDelNode
]
],glmatchingPoolRuleCorrespondingNotExistsElems,{3}],tempDelNode,Infinity];

];

If[debugTiming,Print["timingResDel2 = ",timingResDel2]];

timingResDel3 = Timing[
timingguy1 =  Timing[
glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]] =Map[Function[{mtchPoolRuleVectorArr},
Map[Function[{mtchPoolRuleVector},
(*remove this vector if one of the elements is removed *)
If[Length[Cases[arrDeletedPoolItems[[mtchPoolRuleVector]],0]]>0,

gPoolObjModified[[mtchPoolRuleVector]] = True;

tempDelNode
,
mtchPoolRuleVector
]
],mtchPoolRuleVectorArr]

],glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]]];

glmatchingPoolRuleVectorsOfRegElems[[gPositionOfSpatialRules]] = Table[{},{Length[gPositionOfSpatialRules]}];
];

timingguy1 =  Timing[
gPoolObjModified= Delete[gPoolObjModified, Partition[sortArrDeletedPoolItemsIndexes,1]];
gPoolObjContEqs= Delete[gPoolObjContEqs, Partition[sortArrDeletedPoolItemsIndexes,1]];
gPoolObjVarTypes= Delete[gPoolObjVarTypes, Partition[sortArrDeletedPoolItemsIndexes,1]];
];

timingguy1 =  Timing[
If[Length[gPositionOfSpatialRules]>0,

If[debug,
Print["{gPoolObjSpatialConnectArr,gPoolObjSpatialDiscRateArr} = ",{gPoolObjSpatialConnectArr,gPoolObjSpatialDiscRateArr}];
];

gPoolObjSpatialConnectArr = Delete[gPoolObjSpatialConnectArr, Partition[sortArrDeletedPoolItemsIndexes,1]];
gPoolObjSpatialDiscRateArr = Delete[gPoolObjSpatialDiscRateArr, Partition[sortArrDeletedPoolItemsIndexes,1]];

gPoolObjSpatialConnectArr = MapIndexed[Function[{curSpObjNbrs,curSpObjInd},
Map[Function[{curNbr},

If[arrDeletedPoolItems[[curNbr]] == 0,gPoolObjModified[[curSpObjInd[[1]]]] = True;tempDelNode,curNbr]

],curSpObjNbrs]

],gPoolObjSpatialConnectArr];

gPoolObjSpatialDiscRateArr = MapThread[Function[{curSpObjNbrs,curSpObjNbrsRate},

If[Length[curSpObjNbrsRate]>0,
DeleteCases[MapThread[Function[{curNbr,curnbrRates},

If[curNbr ===  tempDelNode,tempDelNode,curnbrRates]

],{curSpObjNbrs,curSpObjNbrsRate}],tempDelNode]
,
{}]
],{gPoolObjSpatialConnectArr,gPoolObjSpatialDiscRateArr}];

gPoolObjSpatialConnectArr = Map[Function[{curSpObjNbrs},

DeleteCases[Map[Function[{curNbr},

If[curNbr ===  tempDelNode,tempDelNode,curNbr]

],curSpObjNbrs],tempDelNode]
],gPoolObjSpatialConnectArr];
];

];

If[Length[glContEqArr]>0,
timingguy1 =  Timing[
glContEqArr[[gPosNonSpatialContRules]] = MapThread[Function[{mtchPoolRuleVectorArr,mtchPoolRuleContEqArr},

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVectorContEqs},
If[mtchPoolRuleVector === tempDelNode,
tempDelNode,
mtchPoolRuleVectorContEqs
]
],{mtchPoolRuleVectorArr,mtchPoolRuleContEqArr}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules[[gPosNonSpatialContRules]]]],glContEqArr[[gPosNonSpatialContRules]]}];

glContEqArr[[gPosSpatialContRules]] = Table[{},{Length[gPosSpatialContRules]}];
];
];

If[Length[glAccelRatesArr]>0,
glAccelRatesArr[[gPosNonSpatialAccelRules]] = MapThread[Function[{mtchPoolRuleVectorArr,mtchPoolRuleContEqArr},

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVectorContEqs},
If[mtchPoolRuleVector === tempDelNode,
tempDelNode,
mtchPoolRuleVectorContEqs
]
],{mtchPoolRuleVectorArr,mtchPoolRuleContEqArr}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfAcceleratedRules[[gPosNonSpatialAccelRules]]]],glAccelRatesArr[[gPosNonSpatialAccelRules]]}];

glAccelRatesArr[[gPosSpatialAccelRules]] = Table[{},{Length[gPosSpatialAccelRules]}];
];


If[Length[glDiffEqArr]>0,
glDiffEqArr[[gPosNonSpatialDiffRules]] = MapThread[Function[{mtchPoolRuleVectorArr,mtchPoolRuleContEqArr},

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVectorContEqs},
If[mtchPoolRuleVector === tempDelNode,
tempDelNode,
mtchPoolRuleVectorContEqs
]
],{mtchPoolRuleVectorArr,mtchPoolRuleContEqArr}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfDiffRules[[gPosNonSpatialDiffRules]]]],glDiffEqArr[[gPosNonSpatialDiffRules]]}];

glDiffEqArr[[gPosSpatialDiffRules]] = Table[{},{Length[gPosSpatialDiffRules]}];
];

timingguy1 =  Timing[
glmatchingPoolRuleVecsProb[[gPositionOfNonSpatialRules]] = MapThread[Function[{mtchPoolRuleVectorArr,mtchPoolRuleVectorProbArr},

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVectorProb},
If[mtchPoolRuleVector === tempDelNode,
tempDelNode,
mtchPoolRuleVectorProb
]
],{mtchPoolRuleVectorArr,mtchPoolRuleVectorProbArr}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]],glmatchingPoolRuleVecsProb[[gPositionOfNonSpatialRules]]}];

glmatchingPoolRuleVecsProb[[gPositionOfSpatialRules]] = Table[{},{Length[gPositionOfSpatialRules]}];
];

glmatchingPoolRuleVecReplaceAll = MapThread[Function[{mtchPoolRuleVectorArr,mtchPoolRuleVectorReplaceAllArr},

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVectorReplaceAll},
If[mtchPoolRuleVector === tempDelNode,
tempDelNode,
mtchPoolRuleVectorReplaceAll
]
],{mtchPoolRuleVectorArr,mtchPoolRuleVectorReplaceAllArr}]

],{glmatchingPoolRuleVectorsOfRegElems,glmatchingPoolRuleVecReplaceAll}];

glmatchingPoolRuleCorrespondingForAllElems = MapThread[Function[{mtchPoolRuleVectorArr,mtchPoolRuleVectorCorspondForAllArr},

If[Length[mtchPoolRuleVectorCorspondForAllArr]>0,
MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVectorCorspondForAll},
If[mtchPoolRuleVector === tempDelNode,
tempDelNode,
mtchPoolRuleVectorCorspondForAll
]
],{mtchPoolRuleVectorArr,mtchPoolRuleVectorCorspondForAllArr}]
,
mtchPoolRuleVectorCorspondForAllArr
]

],{glmatchingPoolRuleVectorsOfRegElems,glmatchingPoolRuleCorrespondingForAllElems}];

glmatchingPoolRuleCorrespondingNotExistsElems = MapThread[Function[{mtchPoolRuleVectorArr,mtchPoolRuleVectorCorspondNotExistsArr},

If[Length[mtchPoolRuleVectorCorspondNotExistsArr]>0,
MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVectorCorspondNotExists},
If[mtchPoolRuleVector === tempDelNode,
tempDelNode,
mtchPoolRuleVectorCorspondNotExists
]
],{mtchPoolRuleVectorArr,mtchPoolRuleVectorCorspondNotExistsArr}]
,
mtchPoolRuleVectorCorspondNotExistsArr
]

],{glmatchingPoolRuleVectorsOfRegElems,glmatchingPoolRuleCorrespondingNotExistsElems}];

If[debug,
Print["glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]] = ",glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]]];
Print["glmatchingPoolRuleVecsProb[[gPositionOfNonSpatialRules]] = ",glmatchingPoolRuleVecsProb[[gPositionOfNonSpatialRules]]];
If[Length[glContEqArr]>0,
Print["glContEqArr[[gPosNonSpatialContRules]] = ",glContEqArr[[gPosNonSpatialContRules]]];
];
If[Length[glAccelRatesArr]>0,
Print["glAccelRatesArr[[gPosNonSpatialAccelRules]] = ",glAccelRatesArr[[gPosNonSpatialAccelRules]]];
];
If[Length[glDiffEqArr]>0,
Print["glDiffEqArr[[gPosNonSpatialDiffRules]] = ",glDiffEqArr[[gPosNonSpatialDiffRules]]]
];
];

timingguy1 =  Timing[
glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]] =Map[Function[{curruleVecs},DeleteCases[ curruleVecs,tempDelNode]],glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]]];
glmatchingPoolRuleVecsProb[[gPositionOfNonSpatialRules]] =Map[Function[{curruleVecs},DeleteCases[ curruleVecs,tempDelNode]],glmatchingPoolRuleVecsProb[[gPositionOfNonSpatialRules]]];

If[Length[glContEqArr]>0,
glContEqArr[[gPosNonSpatialContRules]] = Map[Function[{curruleVecs},DeleteCases[ curruleVecs,tempDelNode]],glContEqArr[[gPosNonSpatialContRules]]];
];
If[Length[glAccelRatesArr]>0,
glAccelRatesArr[[gPosNonSpatialAccelRules]] = Map[Function[{curruleVecs},DeleteCases[ curruleVecs,tempDelNode]],glAccelRatesArr[[gPosNonSpatialAccelRules]]];
];
If[Length[glDiffEqArr]>0,
glDiffEqArr[[gPosNonSpatialDiffRules]] = Map[Function[{curruleVecs},DeleteCases[ curruleVecs,tempDelNode]],glDiffEqArr[[gPosNonSpatialDiffRules]]];
];

glmatchingPoolRuleVecReplaceAll =DeleteCases[glmatchingPoolRuleVecReplaceAll,tempDelNode,Infinity];
glmatchingPoolRuleCorrespondingForAllElems =DeleteCases[ glmatchingPoolRuleCorrespondingForAllElems,tempDelNode,Infinity];
glmatchingPoolRuleCorrespondingNotExistsElems =DeleteCases[ glmatchingPoolRuleCorrespondingNotExistsElems,tempDelNode,Infinity];

];
];

If[debugTiming,Print["timingResDel3 = ",timingResDel3]];

timingResDel4 = Timing[

arrDeletedPoolItems = Range[Length[thePool]];

iNumDeletedItems = Length[sortArrDeletedPoolItemsIndexes];
iMinDelItem = sortArrDeletedPoolItemsIndexes[[1]];
iMaxDelItem = sortArrDeletedPoolItemsIndexes[[iNumDeletedItems]];

iCurShift = 0;
iStartArrIndex = 1;
Scan[Function[{delItem},

arrDeletedPoolItems[[Range[iStartArrIndex,delItem]]] -= iCurShift;
iStartArrIndex = delItem+1;
iCurShift++;

],sortArrDeletedPoolItemsIndexes];

If[iMaxDelItem < Length[thePool],

arrDeletedPoolItems[[Range[iMaxDelItem+1,Length[thePool]]]] -= iNumDeletedItems;
];

(*now change the indexes in the global variables according to the shift*)
glRuleMatchingPoolItemsLocations =Map[arrDeletedPoolItems[[#]]&,glRuleMatchingPoolItemsLocations,{3}];
glRuleForAllMatchingPoolItemsLocations =Map[arrDeletedPoolItems[[#]]&,glRuleForAllMatchingPoolItemsLocations,{3}];
glRuleNotExistsMatchingPoolItemsLocations =Map[arrDeletedPoolItems[[#]]&,glRuleNotExistsMatchingPoolItemsLocations,{3}];

If[Length[gPositionOfSpatialRules]>0,
gPoolObjSpatialConnectArr = Map[Function[{curSpObjNbrs},

arrDeletedPoolItems[[curSpObjNbrs]]

],gPoolObjSpatialConnectArr];
];

glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]] = Map[arrDeletedPoolItems[[#]]&,glmatchingPoolRuleVectorsOfRegElems[[gPositionOfNonSpatialRules]],{3}];

glmatchingPoolRuleCorrespondingForAllElems =Map[arrDeletedPoolItems[[#]]&,glmatchingPoolRuleCorrespondingForAllElems,{3}];
glmatchingPoolRuleCorrespondingNotExistsElems =Map[arrDeletedPoolItems[[#]]&,glmatchingPoolRuleCorrespondingNotExistsElems,{3}];

(*
glRuleMatchingPoolItemsLocations = HandleDeleteInRuleMatchingPoolItemsLocs[glRuleMatchingPoolItemsLocations,sortArrDeletedPoolItemsIndexes];
glRuleForAllMatchingPoolItemsLocations = HandleDeleteInRuleMatchingPoolItemsLocs[glRuleForAllMatchingPoolItemsLocations,sortArrDeletedPoolItemsIndexes];
glRuleNotExistsMatchingPoolItemsLocations = HandleDeleteInRuleMatchingPoolItemsLocs[glRuleNotExistsMatchingPoolItemsLocations,sortArrDeletedPoolItemsIndexes];

glmatchingPoolRuleVectorsOfRegElems = HandleDeleteInMatchRuleVectorsStruct[glmatchingPoolRuleVectorsOfRegElems,sortArrDeletedPoolItemsIndexes];
glmatchingPoolRuleCorrespondingForAllElems = HandleDeleteInMatchRuleVectorsStruct[glmatchingPoolRuleCorrespondingForAllElems,sortArrDeletedPoolItemsIndexes];
glmatchingPoolRuleCorrespondingNotExistsElems = HandleDeleteInMatchRuleVectorsStruct[glmatchingPoolRuleCorrespondingNotExistsElems,sortArrDeletedPoolItemsIndexes];
*)
];

If[debugTiming,Print["timingResDel4 = ",timingResDel4]];

If[debug,
Print["ending HandleDeletedPoolItems"];
Print["glRuleMatchingPoolItemsLocations = ",glRuleMatchingPoolItemsLocations];
Print["glRuleForAllMatchingPoolItemsLocations = ",glRuleForAllMatchingPoolItemsLocations];
Print["glmatchingPoolRuleVectorsOfRegElems = ",glmatchingPoolRuleVectorsOfRegElems];
Print["glmatchingPoolRuleCorrespondingForAllElems = ",glmatchingPoolRuleCorrespondingForAllElems];
Print["glRuleNotExistsMatchingPoolItemsLocations = ",glRuleNotExistsMatchingPoolItemsLocations];
Print["glmatchingPoolRuleCorrespondingNotExistsElems = ",glmatchingPoolRuleCorrespondingNotExistsElems];
Print["finish HandleDeletedPoolItems"];
];

];


SetAttributes[HandleDeletedPoolItems,ReadProtected]


setDelayedVariables[curTime_]:=Module[{bCurRuleIsDelayed,bPoolChanged},
(*need to change this code does not work anymore in version 11 with the new data structures - gPoolObjContEqs*)
bPoolChanged = False;
(*
If[Length[Flatten[glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]]]]>0,

MapThread[Function[{curRulePoolItemsarr,curRuleContEqs,curPosContRule,curContRuleElmLoc},

bCurRuleIsDelayed = MemberQ[gPositionOfDelayedContRules,curPosContRule];

If[bCurRuleIsDelayed,
MapThread[Function[{curRulePoolItems,curRuleVecContEqs},

MapThread[Function[{curcontEq,curEqRuleElemLoc},

thePool[[curRulePoolItems[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] = 
(*go over the variables on the RHS and change them accordingly*)
(curcontEq[[1,2]]/.Flatten[Map[Function[{curEqVarLoc},

gPoolVariables[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]][gGrammarTimeVar]-> thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]

],curEqRuleElemLoc[[2]]]])/.{gGrammarTimeVar-> curTime,gPoolVariables[[curRulePoolItems[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]][N[0]]-> thePool[[curRulePoolItems[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]]};

bPoolChanged = True;

],{curRuleVecContEqs,curContRuleElmLoc}]

],{curRulePoolItemsarr,curRuleContEqs}],
{}
]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]],glContEqArr,gPositionOfContRules,gGrammarContElmLoc}];
];
*)

bPoolChanged
];



SetAttributes[setDelayedVariables,ReadProtected]


gContIntegrateRateThreshold = 10^6;


fnreStatusDiscreteEvent = 1;
fnreStatusMaxDeriv = 2;
fnreStatusFailed = 0;


bUseMyNDSolve = False;


numStepsMyNDSolve = 10000;


gReduceNumberTermsInEquation = False; (*this can be true only for huge space. Note - when using spatial grammar, using 'gReduceNumberTermsInEquation = True' was not more efficient!!! *)
gEpsilonReduceNumberTerms = 0.000000001;(*0.001;0.000000000001*)


bIntegrateODEWithTotalRate = False;(*Don't use True - integration with the total rate is much slower!!*)


defPrecisionNDSolve = 10^-7;(*the precision of eventLocator is the same as the precision for NDSolve which is half of MachinePrecision*)


findNextRuleExec[maxDerivTimeBetweenSteps_]:= Module[{timeDerivLimit,ndsolution,maxNumDerivIterations,curStartVal,bracketRange,bFound,maxNumIterFindTime,retVal,iDiscRuleIndex,iPoolPosForRuleIndex,arrIndexesInPosition,sumProbs,posOfRndChosenEntry,randomNumber,arrProbs,tempProbVal,diffEqOfAllVariables,solDiffEq,curLHSDiscRule,replaceAllSec,timingNDsolve,totDervForCurVar,bReachedMaxDerivTime,curTotRateExp,totRateProbFunc,curTotalProbRateVar,bFoundTimeOfEvent,timeEventOccured,bCurRuleIsDelayed,typeVarsArr,newContEqArr,cureqType,curvartype,diffVarsEqsArr,algVarsEqsArr,curtotDiffEq,curtotAlgEq,curtotDiffEqIniDerv,timeDependEqArr,curIterTimeDepEqArr,cureqvec,cureqvarsLocs,iniValsEqArr,varsStrctArr,varsIntegrateArr,varsIntegratePosArr,rulesVarsToValsArr,solVarTimeArr,prevIntegTime},

If[debug,Print["start findNextRuleExec"];];

bFoundTimeOfEvent = False;
timeEventOccured = 0;
prevIntegTime = 0;

varsIntegrateArr = {};
varsIntegratePosArr = {};

resetDiffDepFuncs[];

randomNumberTime = RandomReal[];

If[debug,Print["randomNumberTime = ",randomNumberTime];];

(*in this case we have a function of rho that depends on time \[Tau]:
 the diff equation :
 d (1-p)/dt=-rho(t)(1-p)
solve it numerically and find the time t that 
	1-p (t) = randomNumberTime
*)
(* We iterate between two steps: 
a. integrate the ODE (or SDE) for each continuous rule up to time ti, replace the variables in each term of the rate function (which is on Hold) with the a new function of the variable given t
 
b. sum all the rate functions together , and integrate up to time ti. the result is the probability function given time t -  Rp (t). if the Rp (ti)< r (the random number between 0 and 1) then inverse the function in order to find 
t == Pr_-1(r) and finish,
   
  c. ti = ti*2, return to a.  
*)

timingTemp = Timing[
(*first lets check that the total rate currently is not above the threshold. If it is , there is no need for continous rules integration. This is done only for efficiency*)
totalRateFunc = calcTotalDiscreteRate[];
];

If[debugTiming,Print[" calcTotalDiscreteRate timingTemp = ",timingTemp]];

timingTemp = Timing[
timeDependEqArr = getTimeDependetEqArr[];
If[debug,Print["timeDependEqArr = ",timeDependEqArr];];
];
If[debugTiming,Print["getTimeDependetEqArr timingTemp =",timingTemp];];


(*there are continuous rule-elements*)
If[(Length[gPositionOfContRules]>0 && Length[Flatten[glmatchingPoolRuleVecsProb[[gPositionOfContRules]]]]>0) || (Length[gPositionOfDiffRules]>0 && Length[Flatten[glmatchingPoolRuleVecsProb[[gPositionOfDiffRules]]]]>0) || Length[timeDependEqArr]>0,

If[debug,
Print["gPositionOfDiscRules = ",gPositionOfDiscRules];
Print["gPositionOfContRules = ",gPositionOfContRules];
Print["gPositionOfDiffRules = ",gPositionOfDiffRules];
Print["glmatchingPoolRuleVectorsOfRegElems = ",glmatchingPoolRuleVectorsOfRegElems];
Print["glMatchingPoolRuleVectorsValid = ",glMatchingPoolRuleVectorsValid];
Print["glmatchingPoolRuleVecsProb = ",glmatchingPoolRuleVecsProb];
];

(*Print["timingTemp1 1 =",timingTemp1];*)

If [totalRateFunc< gContIntegrateRateThreshold,

timingTemp = Timing[
iniValsEqArr = getIniValsEq[];
If[debug,Print["iniValsEqArr = ",iniValsEqArr];];
];
If[debugTiming,Print["getIniValsEq timingTemp =",timingTemp];];




If[debug,
Print["before varsStrctArr gPoolVariables =",gPoolVariables];
Print["before varsStrctArr gPoolObjVarTypes =",gPoolObjVarTypes];
];

timingTemp = Timing[
varsStrctArr = Flatten[MapThread[Function[{curPoolItemVars,curItemTypeVars,curItemInd},

DeleteCases[MapThread[Function[{curVar,curtypevar,curVarInd},

If[curtypevar == typeVarDervTime || curtypevar == typeVarFuncTime,{curVar,{curItemInd,curVarInd}},0]

],{Apply[List,curPoolItemVars],curItemTypeVars,Range[1,Length[curPoolItemVars]]}],0]

],{gPoolVariables,gPoolObjVarTypes,Range[1,Length[gPoolVariables]]}],1];

If[debug,Print["varsStrctArr = ",varsStrctArr];];

If[Length[varsStrctArr] >0,
varsIntegrateArr = varsStrctArr[[All,1]];
varsIntegratePosArr = varsStrctArr[[All,2]];
];

];
If[debugTiming,Print["varsStrctArr timingTemp =",timingTemp];];


If[bIntegrateODEWithTotalRate,
curTotRateExp = createTotalRateExpression[];

totalRateODE = (
\!\(\*SuperscriptBox["curProbFunc", "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar]==-curTotRateExp*curProbFunc[gGrammarTimeVar]);
totalRateIniCond = (curProbFunc[0]==1);

curTotalProbRateVar =  curProbFunc;
,

totalRateODE = {};
totalRateIniCond = {};

curTotalProbRateVar =  {};
];

(**********************initialization of time derivation limit *)
(*The following is deduced from :
randomNumberTime == E^(-totalRateFunc t)
we multiply by 0.9 so that integration will continue 10% more
*)

timeDerivLimit =  Log[randomNumberTime*0.9]/-totalRateFunc;

If[timeDerivLimit>maxDerivTimeBetweenSteps  || !NumericQ[timeDerivLimit],
timeDerivLimit=maxDerivTimeBetweenSteps;
];

maxNumDerivIterations = 20;

bReachedMaxDerivTime = False;
(***********************)

If[Length[varsIntegrateArr]>0 ||  (Length[gPositionOfDiffRules]>0 && Length[Flatten[glmatchingPoolRuleVecsProb[[gPositionOfDiffRules]]]]>0),

initWienerArr[timeDependEqArr];

For[iterNum=1,iterNum<= maxNumDerivIterations && !bFoundTimeOfEvent && !bReachedMaxDerivTime ,iterNum++,
If[debug,Print["iterNum = ",iterNum];];

(*integrate all the continuous equations*)
If[Length[varsIntegrateArr]>0,

timingTemp = Timing[
curIterTimeDepEqArr = updateWiener[timeDerivLimit,timeDependEqArr];
];
If[debug,Print["updateWiener curIterTimeDepEqArr =",curIterTimeDepEqArr];];
If[debugTiming,Print["updateWiener timingTemp =",timingTemp];];


timingNDsolve = Timing[

gCurGramEquations = Flatten[{curIterTimeDepEqArr,iniValsEqArr,totalRateODE,totalRateIniCond,
\!\(\*SuperscriptBox["dummyVartemp", "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar]==1,dummyVartemp[0]== 0 }];
gCurGramVars = Flatten[{varsIntegrateArr,curTotalProbRateVar,dummyVartemp}];

If[debug || debugPrintODE,
Print["gCurGramEquations = ",gCurGramEquations];
Print["gCurGramVars = ",gCurGramVars];
Print["rng = ",{gGrammarTimeVar,0,timeDerivLimit}];
];

(*Print["before NDSolve "];*)

(*REMARK -  we add dummyVartemp variable here because NDSolve can solve equations only if there is at least one differential equation . If there are only algebraic equations , NDSolve can not solve.
Note - Method->ExplicitRungeKutta   actualy worked slower for the OE grammar 

DO not use PrecisionGoal : the problem was that it missed results, so it depends on the total rate (which is dynamic and therefore hard to estimate) and the random number
*)
solDiffEq=NDSolve[gCurGramEquations,gCurGramVars,{gGrammarTimeVar,0,timeDerivLimit}(*,PrecisionGoal-> 4 DO NOT USE THIS- see remark above*) ];
(*Print["after NDSolve "];*)

If[debug,Print["solDiffEq  after NDSolve = ",solDiffEq];];

If[Length[solDiffEq]!= 1,
Print["findNextRuleExec: Error - invalid ODE - Flatten[{curIterTimeDepEqArr,iniValsEqArr,totalRateODE,totalRateIniCond}]  = ",Flatten[{curIterTimeDepEqArr,iniValsEqArr,totalRateODE,totalRateIniCond}]];
Print["varsIntegrateArr = ",varsIntegrateArr];
Print["{gGrammarTimeVar,0,timeDerivLimit} = ",{gGrammarTimeVar,0,timeDerivLimit}];
Print["solDiffEq = ",solDiffEq];
Print["thePool = ",thePool];
Print["gPoolVariables = ",gPoolVariables];

];

(*take the first solution*)
solDiffEq = First[solDiffEq];
];
If[debugTiming,Print["inside findNextRuleExec timingNDsolve = ",timingNDsolve];];

If[debug,Print["solDiffEq = ",solDiffEq];];

timingTemp = Timing[
solDiffEq = solDiffEq/. (x_->y_)-> (x-> y[gGrammarTimeVar]);
];
If[debugTiming,Print["solDiffEq timingTemp =",timingTemp];];

If[debug,Print["solDiffEq 2 = ",solDiffEq];];

timingTemp = Timing[
solVarTimeArr = solDiffEq[[Range[1,Length[varsIntegrateArr]]]];
soltotalProbRateVar = If[Length[solDiffEq]>Length[varsIntegrateArr], solDiffEq[[Length[varsIntegrateArr]+1]],0];
];
If[debugTiming,Print["soltotalProbRateVar timingTemp =",timingTemp];];

If[bIntegrateODEWithTotalRate,
If[curProbFunc === soltotalProbRateVar[[1]],
totRateProbFunc = (curProbFunc/.soltotalProbRateVar)
,
Print["ERROR - soltotalProbRateVar[[1]]=!= curProbFunc, soltotalProbRateVar = ",soltotalProbRateVar, " curProbFunc = ",curProbFunc];
];
];

MapThread[Function[{curPos,solVarTime},
If[gPoolVariables[[curPos[[1]],curPos[[2]]]] === solVarTime[[1]],
thePool[[curPos[[1]],curPos[[2]]]] = solVarTime[[2]];
,
Print["ERROR - No matching!!  gPoolVariables[[curPos[[1]],curPos[[2]]]]  = ",gPoolVariables[[curPos[[1]],curPos[[2]]]], "  solVarTime = ",solVarTime];
]
],{varsIntegratePosArr,solVarTimeArr}];

gIntegratedPool = thePool;

];(*end of Length[varsIntegrateArr]>0*)


(*diffusion - integrate the diffsion - and put the results in thePool*)
timingTemp = Timing[
integrateDiffusion[prevIntegTime,timeDerivLimit];
];
If[debugTiming,Print["integrateDiffusion timingTemp = ",timingTemp];];

prevIntegTime = timeDerivLimit;

If[!bIntegrateODEWithTotalRate,

timingTemp = Timing[
totalRateFunc = calcTotalDiscreteRate[];
];
If[debugTiming,Print["totalRateFunc timingTemp = ",timingTemp];];
If[debug,Print["totalRateFunc = ",totalRateFunc];];

If[debug,Print["totalRateFunc/.gGrammarTimeVar\[Rule] 0 = ",totalRateFunc/.gGrammarTimeVar-> 0];];
If[debug,Print["randomNumberTime = ",randomNumberTime];];

timeSol = FindRoot[Exp[-totalRateFunc * gGrammarTimeVar] == randomNumberTime, {gGrammarTimeVar, 0}];

timeEventOccured = gGrammarTimeVar/.timeSol;
    
(*if NDSolve integrated until less then the limit then we now that the event has occured*)
If[timeEventOccured <   timeDerivLimit,
bFoundTimeOfEvent = True;
];
];
];
];

If[bReachedMaxDerivTime,

(*Print["bReachedMaxDerivTime!!"];*)

(*change the values of all the values in the pool*)
thePool=thePool/.gGrammarTimeVar-> maxDerivTimeBetweenSteps;

applyNextGrid[maxDerivTimeBetweenSteps];

(*change all the values of delayed variables*)
setDelayedVariables[maxDerivTimeBetweenSteps];

If[debug,Print["thePool after 1 = ",thePool];];

(*change the values of all the affected discrete elements*)
groundPoolVecRates[];

gCurSimulationTime += maxDerivTimeBetweenSteps;

Return[{fnreStatusMaxDeriv,0,0,maxDerivTimeBetweenSteps}];

];

If[!bFoundTimeOfEvent,
Print["findNextRuleExec: did not find derivRange after timeDerivLimit = ",timeDerivLimit/2];
Print["findNextRuleExec: maxNumDerivIterations = ",maxNumDerivIterations];
Print["findNextRuleExec: totalRateFunc = ",totalRateFunc];
Print["findNextRuleExec: randomNumberTime = ",randomNumberTime];

Return[{fnreStatusFailed,0,0,0}];
];

gGrammarTimeFinalVal = timeEventOccured;

If[debug,
Print["gGrammarTimeFinalVal = ",gGrammarTimeFinalVal];
Print["glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]] = ",glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]]];
Print["grammarRulesArr[[gPositionOfContRules]] = ",grammarRulesArr[[gPositionOfContRules]]];
Print["thePool before = ",thePool];
];

(* change the values of all the values in the pool*)
thePool=thePool/.gGrammarTimeVar-> gGrammarTimeFinalVal;

If[debug,Print["thePool after 2 = ",thePool];];

applyNextGrid[gGrammarTimeFinalVal];

(*change the values of all the affected discrete elements*)
groundPoolVecRates[];

,
(*Length[varsIntegrateArr] == 0 - no continuous equations after removing all the delayed*)

gGrammarTimeFinalVal =  1/totalRateFunc*Log[1/randomNumberTime];
];

,
If[debug,Print["totalRateFunc >=  gContIntegrateRateThreshold!! "];];

If[debug,Print["totalRateFunc = ",totalRateFunc];];

gGrammarTimeFinalVal =  1/totalRateFunc*Log[1/randomNumberTime];

If[debug,Print["gGrammarTimeFinalVal = ",gGrammarTimeFinalVal];];

];
,

If[debug,Print["No Continuous rules!! "];];

If[debug,Print["totalRateFunc = ",totalRateFunc];];
If[totalRateFunc == 0,
Return[{fnreStatusFailed,0,0,0}];
];

gGrammarTimeFinalVal =  1/totalRateFunc*Log[1/randomNumberTime];

If[debug,Print["gGrammarTimeFinalVal = ",gGrammarTimeFinalVal];];

];

(*change all the values of delayed variables*)
setDelayedVariables[gGrammarTimeFinalVal];

(*Print["guy remove gGrammarTimeFinalVal = ",gGrammarTimeFinalVal];*)
gCurSimulationTime += gGrammarTimeFinalVal;

(*choose which discrete rule to fire *)
If[debug,Print["findNextRuleExec: glGroundPoolVecRates = ",glGroundPoolVecRates];];

arrProbs = MapThread[Function[{probVec,validVec},
If[validVec,probVec[[1]],0]
],{Flatten[glGroundPoolVecRates,1],Flatten[glMatchingPoolRuleVectorsValid[[gPositionOfDiscRules]]]}];

sumProbs = Apply[Plus,Flatten[arrProbs]];

If[debug,Print["findNextRuleExec: sumProbs = ",sumProbs];];

If[sumProbs == 0,
Return[{fnreStatusFailed,0,0,0}];
];

(* make a random choice of rule firing *)
randomNumber = RandomReal[{0,sumProbs}];

If[debug,Print["randomNumber = ",randomNumber];];

tempProbVal = 0;
posOfRndChosenEntry = 0;
MapIndexed[Function[{curProb,indexCurProb},
tempProbVal+=curProb;

If[posOfRndChosenEntry == 0 && tempProbVal>= randomNumber,
posOfRndChosenEntry = indexCurProb[[1]];
];

],Flatten[arrProbs]];

arrIndexesInPosition = Flatten[
MapIndexed[Function[{vecElems,indexVec},
indexVec
],glGroundPoolVecRates,{2}],1];

If[debug,Print["findNextRuleExec: posOfRndChosenEntry = ",posOfRndChosenEntry];];

iDiscRuleIndex = arrIndexesInPosition[[posOfRndChosenEntry]][[1]];
iPoolPosForRuleIndex = arrIndexesInPosition[[posOfRndChosenEntry]][[2]] ;

If[debug,
Print["iDiscRuleIndex = ",iDiscRuleIndex];
Print["iPoolPosForRuleIndex = ",iPoolPosForRuleIndex];
Print["exit findNextRuleExec"];
];

{fnreStatusDiscreteEvent,iDiscRuleIndex,iPoolPosForRuleIndex,gGrammarTimeFinalVal}
]


SetAttributes[findNextRuleExec,ReadProtected]


initWienerArr[timeDependEqArr_]:=Module[{counter},
If[giWienerVar=!= Null,
counter = 0;
Map[Function[{cureq},
If[!FreeQ[cureq,giWienerVar],counter++]
],timeDependEqArr];

glArrWienerVals = Table[{{0.,0.}},{counter}];
glWienerTimeLimit = 0;

Print["initWienerArr: Length[glArrWienerVals] = ",Length[glArrWienerVals]];
];

];


SetAttributes[initWienerArr,ReadProtected]


gWienerDeltaTime = 0.1;
gWienerMinSteps = 7;


updateWiener[timeDerivLimit_,timeDependEqArr_] := Module[{arrRnd,counter,curdelta,arrTimepnts},

If[giWienerVar=!= Null,

Print["GUYGUY: note updateWiener giWienerVar=!= Null"];

curdelta = If[Floor[(timeDerivLimit-glWienerTimeLimit)/gWienerDeltaTime]<gWienerMinSteps,
(timeDerivLimit-glWienerTimeLimit)/gWienerMinSteps
,
gWienerDeltaTime
];

curdeltasqr = Sqrt[curdelta]; (*because curdelta is the variance*)

arrTimepnts = Table[i,{i,glWienerTimeLimit+curdelta,timeDerivLimit+curdelta,curdelta}];

glArrWienerVals = Map[Function[{curVarWVals},
arrRnd = Transpose[{arrTimepnts,RandomReal[NormalDistribution[0,curdeltasqr],Length[arrTimepnts]]/curdelta}];
Join[curVarWVals,arrRnd]
],glArrWienerVals];

Print["updateWiener: {glWienerTimeLimit,timeDerivLimit} = ",{glWienerTimeLimit,timeDerivLimit}];

glWienerTimeLimit = Last[arrTimepnts];

glWienerFunc = Map[Function[{curVarWVals},
Interpolation[curVarWVals]
],glArrWienerVals];

counter = 0;
Map[Function[{cureq},
If[!FreeQ[cureq,giWienerVar],counter++;cureq/.giWienerVar-> glWienerFunc[[counter]][gGrammarTimeVar] , cureq]
],timeDependEqArr]
,
timeDependEqArr
]

]


SetAttributes[updateWiener,ReadProtected]


findNextRuleExecWithAccel[maxDerivTimeBetweenSteps_]:= Module[{timeDerivLimit,ndsolution,maxNumDerivIterations,curStartVal,bracketRange,bFound,maxNumIterFindTime,retVal,iRuleIndex,iPoolPosForRuleIndex,arrIndexesInPosition,sumProbs,posOfRndChosenEntry,randomNumber,arrProbs,tempProbVal,diffEqOfAllVariables,solDiffEq,curLHSDiscRule,replaceAllSec,timingNDsolve,totDervForCurVar,bReachedMaxDerivTime,curTotRateExp,totRateProbFunc,curTotalProbRateVar,bFoundTimeOfEvent,timeEventOccured,bCurRuleIsDelayed,typeVarsArr,newContEqArr,cureqType,curvartype,diffVarsEqsArr,algVarsEqsArr,curtotDiffEq,curtotAlgEq,curtotDiffEqIniDerv,timeDependEqArr,cureqvec,cureqvarsLocs,iniValsEqArr,varsStrctArr,varsIntegrateArr,varsIntegratePosArr,regDiscRulesPos,rulesVarsToValsArr,solVarTimeArr,groundedAccelRateArr,curTau},

If[debug,Print["start findNextRuleExecWithAccel"];];

bFoundTimeOfEvent = False;
timeEventOccured = 0;

randomNumberTime = RandomReal[];

If[debug,Print["randomNumberTime = ",randomNumberTime];];

(*in this case we have a function of rho that depends on time \[Tau]:
 the diff equation :
 d (1-p)/dt=-rho(t)(1-p)
solve it numerically and find the time t that 
	1-p (t) = randomNumberTime
*)
(* We iterate between two steps: 
a. integrate the ODE (or SDE) for each continuous rule up to time ti, replace the variables in each term of the rate function (which is on Hold) with the a new function of the variable given t
 
b. sum all the rate functions together , and integrate up to time ti. the result is the probability function given time t -  Rp (t). if the Rp (ti)< r (the random number between 0 and 1) then inverse the function in order to find 
t == Pr_-1(r) and finish,
   
  c. ti = ti*2, return to a.  
*)


(*first lets check that the total rate currently is not above the threshold. If it is , there is no need for continous rules integration. This is done only for efficiency*)
regDiscRulesPos = getRegDiscRulesPos[];

totalRateFunc = calcTotalRegRate[];

If[debug,
Print["regDiscRulesPos = ",regDiscRulesPos];
Print["totalRateFunc = ",totalRateFunc];
];


(*there are continuous rule-elements or accelerated rules*)
If[(Length[gPositionOfContRules]>0 && Length[Flatten[glmatchingPoolRuleVecsProb[[gPositionOfContRules]]]]>0 )|| (Length[gPositionOfAcceleratedRules]>0 && Length[Flatten[glmatchingPoolRuleVecsProb[[gPositionOfAcceleratedRules]]]]>0),

If[debug,
Print["gPositionOfDiscRules = ",gPositionOfDiscRules];
Print["gPositionOfContRules = ",gPositionOfContRules];
Print["glmatchingPoolRuleVectorsOfRegElems = ",glmatchingPoolRuleVectorsOfRegElems];
Print["glMatchingPoolRuleVectorsValid = ",glMatchingPoolRuleVectorsValid];
Print["glmatchingPoolRuleVecsProb = ",glmatchingPoolRuleVecsProb];
];

(*Print["timingTemp1 1 =",timingTemp1];*)


If [totalRateFunc< gContIntegrateRateThreshold,

timingTemp = Timing[

If[debug,Print["1 diffEqOfAllVariables = ",diffEqOfAllVariables];];
If[debug,Print["gPoolVariables = ",gPoolVariables];];

{typeVarsArr,diffVarsEqsArr,algVarsEqsArr} = createVarsEqsStructs[];

(*gather all the variables to integrate and their positions*)
varsStrctArr = Flatten[MapThread[Function[{curPoolItemVars,curItemTypeVars,curItemInd},

DeleteCases[MapThread[Function[{curVar,curtypevar,curVarInd},

If[curtypevar === typeVarDervTime || curtypevar === typeVarFuncTime,{curVar,{curItemInd,curVarInd}},0]

],{Apply[List,curPoolItemVars],curItemTypeVars,Range[1,Length[curPoolItemVars]]}],0]

],{gPoolVariables,typeVarsArr,Range[1,Length[gPoolVariables]]}],1];

If[debug,Print["varsStrctArr = ",varsStrctArr];];

varsIntegrateArr = varsStrctArr[[All,1]];
varsIntegratePosArr = varsStrctArr[[All,2]];
If[debug,Print["varsIntegrateArr  = ",varsIntegrateArr];];

rulesVarsToValsArr = MapThread[Function[{curItemVals,curPoolItemVars,curItemTypeVars},

MapThread[Function[{curVal,curVar,curtypevar},

If[curtypevar == typeVarConstant,
curVar-> curVal,curVar-> Null]

],{Apply[List,curItemVals],Apply[List,curPoolItemVars],curItemTypeVars}]

],{thePool,gPoolVariables,typeVarsArr}];

If[debug,Print["rulesVarsToValsArr = ",rulesVarsToValsArr];];

];
(*Print["timingTemp total =",timingTemp];*)

totalRateODE = {};
totalRateIniCond = {};

curTotalProbRateVar =  {};

maxNumDerivIterations = 200;
totalTimeIntegration = 0;

bReachedMaxDerivTime = False;
(***********************)

For[iterNum=1,iterNum<= maxNumDerivIterations && !bFoundTimeOfEvent && !bReachedMaxDerivTime ,iterNum++,

iniValsEqArr = getIniValsEq[typeVarsArr];
If[debug,Print["iniValsEqArr  = ",iniValsEqArr];];

timeDependEqArr = getTimeDependetEqArr[diffVarsEqsArr,algVarsEqsArr,typeVarsArr];
If[debug,Print["timeDependEqArr  = ",timeDependEqArr];];

If[gbUnlimitedTau,
curTau = \[Infinity];
,
groundedAccelRateArr = groundAccelRates[];
If[debug,Print["groundedAccelRateArr  = ",groundedAccelRateArr];];

curTotalDiscRate = calcTotalDiscreteRate[];
If[debug,Print["curTotalDiscRate = ",curTotalDiscRate];];

curTau = calcNextTau[groundedAccelRateArr,diffVarsEqsArr,algVarsEqsArr,typeVarsArr,curTotalDiscRate];
];

If[debug,Print["after calcNextTau : curTau = ",curTau];];


If[iterNum>1,
totalRateFunc = calcTotalRegRate[];
];

If[debug,Print["after calcTotalRegRate : totalRateFunc = ",totalRateFunc];];

(**********************initialization of time derivation limit *)
(*The following is deduced from :
randomNumberTime == E^(-totalRateFunc t)
we multiply by 0.9 so that integration will continue 10% more
*)

If[Length[varsIntegrateArr]>0 && randomNumberTime< 1,

timeDerivLimit =  Log[randomNumberTime*0.9]/-totalRateFunc;
,
timeDerivLimit =  Log[randomNumberTime]/-totalRateFunc;
];

If[timeDerivLimit>maxDerivTimeBetweenSteps -totalTimeIntegration || !NumericQ[timeDerivLimit],
timeDerivLimit=maxDerivTimeBetweenSteps -totalTimeIntegration;
];

If[curTau < timeDerivLimit,
timeDerivLimit = curTau;
];

If[debug,Print["after calcNextTau : timeDerivLimit = ",timeDerivLimit];];

If[Length[varsIntegrateArr]>0,
timingNDsolve = Timing[

If[debug,
Print["eqs = ",Flatten[{timeDependEqArr,iniValsEqArr,totalRateODE,totalRateIniCond,
\!\(\*SuperscriptBox["dummyVartemp", "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar]==1,dummyVartemp[0]== 0 }]];
Print["vars = ",Flatten[{varsIntegrateArr,curTotalProbRateVar,dummyVartemp}]];
Print["rng = ",{gGrammarTimeVar,0,timeDerivLimit}];
];

(*Print["before NDSolve "];*)
(*REMARK -  we add dummyVartemp variable here because NDSolve can solve equations only if there is at least one differential equation . If there are only algebraic equations , NDSolve can not solve. *)
solDiffEq=NDSolve[Flatten[{timeDependEqArr,iniValsEqArr,totalRateODE,totalRateIniCond,
\!\(\*SuperscriptBox["dummyVartemp", "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar]==1,dummyVartemp[0]== 0 }],Flatten[{varsIntegrateArr,curTotalProbRateVar,dummyVartemp}],{gGrammarTimeVar,0,timeDerivLimit}];
(*Print["after NDSolve "];*)

If[Length[solDiffEq]!= 1,
Print["findNextRuleExecWithAccel: Error - invalid ODE - Flatten[{timeDependEqArr,iniValsEqArr,totalRateODE,totalRateIniCond}]  = ",Flatten[{timeDependEqArr,iniValsEqArr,totalRateODE,totalRateIniCond}]];
Print["varsIntegrateArr = ",varsIntegrateArr];
Print["{gGrammarTimeVar,0,timeDerivLimit} = ",{gGrammarTimeVar,0,timeDerivLimit}];
Print["solDiffEq = ",solDiffEq];

];

(*take the first solution*)
solDiffEq = First[solDiffEq];
];

If[debugTiming,Print["inside findNextRuleExecWithAccel timingNDsolve = ",timingNDsolve];];

If[debug,Print["solDiffEq = ",solDiffEq];];

solDiffEq = solDiffEq/. (x_->y_)-> (x-> y[gGrammarTimeVar]);
If[debug,Print["solDiffEq 2 = ",solDiffEq];];

solVarTimeArr = solDiffEq[[Range[1,Length[varsIntegrateArr]]]];
soltotalProbRateVar = If[Length[solDiffEq]>Length[varsIntegrateArr], solDiffEq[[Length[varsIntegrateArr]+1]],0];

MapThread[Function[{curPos,solVarTime},
If[gPoolVariables[[curPos[[1]],curPos[[2]]]] === solVarTime[[1]],
thePool[[curPos[[1]],curPos[[2]]]] = solVarTime[[2]];
,
Print["ERROR - No matching!!  gPoolVariables[[curPos[[1]],curPos[[2]]]]  = ",gPoolVariables[[curPos[[1]],curPos[[2]]]], "  solVarTime = ",solVarTime];
]
],{varsIntegratePosArr,solVarTimeArr}];

(*now go over all the discrete valid vectors and compute their rate function with the new functions*)
glmatchingPoolRuleVecsProb[[regDiscRulesPos]] = MapThread[Function[{curprobOfRegElemsArr,curposRegElemsDiscRuleArr,rule,indexRule},

MapThread[Function[{probOfRegElems,posRegElemsDiscRule},

(*first assign to the derivative variables their function*)
curLHSDiscRule = thePool[[posRegElemsDiscRule]];
If[debug,Print["curLHSDiscRule 1 = ",curLHSDiscRule];];

If[rule[[indexComplexParamsExp]]==1,

eqTermParams = Flatten[MapThread[Function[{curterm,curpoolitem},
If[Length[curterm]>0,
MapThread[Function[{termParam,poolItemParam},If[Head[termParam]===Pattern,typeTermReg[termParam[[1]]-> poolItemParam],typeTermComplex[termParam==poolItemParam]]],{Apply[List,curterm],Apply[List,curpoolitem]}]
,{}]
],{Flatten[rule[[indexOfAppliedPartOfLHS]]],curLHSDiscRule}]];

If[debug,Print["eqTermParams = ",eqTermParams];];

typeTermRegArr = Cases[eqTermParams,typeTermReg[_]];
If[Length[typeTermRegArr]>0,typeTermRegArr = typeTermRegArr[[All,1]];];

tempEqParams = Flatten[{Cases[eqTermParams,typeTermComplex[_]][[All,1]],
Flatten[Map[Function[{curTermRegRule},If[NumericQ[curTermRegRule[[2]]] , curTermRegRule[[1]] == (curTermRegRule[[1]]/.curTermRegRule),{}]],typeTermRegArr]]
}];

solTermParams = Solve[tempEqParams,rule[[indexOfLHSVars]]];

If[debug,Print["solTermParams = ",solTermParams];];

If[Length[solTermParams]>0,

solTermParams2 = Flatten[{First[solTermParams],typeTermRegArr}];
If[debug,Print["solTermParams2 = ",solTermParams2]];

{tempProb, tempConstraintsRules,replaceAllSec} = 
gRateFuncsStruct[[indexRule]][rule[[indexOfLHSVars]]/.solTermParams2];

,
Print["findNextRuleExecWithAccel: ERROR - no solTermParams ,  {eqTermParams,rule[[indexOfLHSVars]]} ",{eqTermParams,rule[[indexOfLHSVars]]}]
]
,
{tempProb, tempConstraintsRules,replaceAllSec} = 
gRateFuncsStruct[[indexRule]][curLHSDiscRule];

];

If[debug,Print["{tempProb, tempConstraintsRules} = ",{tempProb, tempConstraintsRules}];];

{tempProb, tempConstraintsRules}
],{curprobOfRegElemsArr,curposRegElemsDiscRuleArr}]

],{glmatchingPoolRuleVecsProb[[regDiscRulesPos]],glmatchingPoolRuleVectorsOfRegElems[[regDiscRulesPos]],preReleasegramtrans[[regDiscRulesPos]],regDiscRulesPos}];

If[debug,Print["glmatchingPoolRuleVecsProb = ",glmatchingPoolRuleVecsProb];];

totalRateFunc = Total[
MapThread[Function[{probVec,validVec},
If[validVec,probVec[[1]],0]
],{Flatten[glmatchingPoolRuleVecsProb[[regDiscRulesPos]],1],Flatten[glMatchingPoolRuleVectorsValid[[regDiscRulesPos]]]}]];

If[debug,Print["totalRateFunc = ",totalRateFunc];];
If[debug,Print["totalRateFunc/.gGrammarTimeVar->0 = ",totalRateFunc/.gGrammarTimeVar->0];];

timingNDsolve = Timing[
ndsolution = NDSolve[{
\!\(\*SuperscriptBox["curProbFunc", "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar]==-totalRateFunc*curProbFunc[gGrammarTimeVar],curProbFunc[0]==1},curProbFunc,{gGrammarTimeVar,0,timeDerivLimit},Method->{ EventLocator,"Event"-> (curProbFunc[gGrammarTimeVar]-randomNumberTime)}];

timeEventOccured = (curProbFunc/.First[ndsolution])[[1,1,2]];
(*if NDSolve integrated until less then the limit then we now that the event has occured*)
If[timeEventOccured <  timeDerivLimit,
(*Print["found event time:  timeEventOccured = ",timeEventOccured];*)
bFoundTimeOfEvent = True;
,
Print["Did not Find Event yet, integrated until timeDerivLimit = ",timeDerivLimit]
];
];

If[debugTiming,Print["inside findNextRuleExecWithAccel timingNDsolve 2 = ",timingNDsolve];];

If[debug,
Print["ndsolution = ",ndsolution];
];

totRateProbFunc = (curProbFunc/.First[ndsolution]);


If[bFoundTimeOfEvent && Chop[totRateProbFunc[timeEventOccured]-randomNumberTime,defPrecisionNDSolve] !=  0,
bFoundTimeOfEvent = False;
Print["ERROR : totRateProbFunc[timeEventOccured] = ",totRateProbFunc[timeEventOccured]," randomNumberTime = ",randomNumberTime];
];

randomNumberTime =randomNumberTime/totRateProbFunc[timeEventOccured];

updatePoolAfterIntegration[timeEventOccured];
(*change the values of all the affected discrete elements*)
regDiscRulesPos = getRegDiscRulesPos[];
glmatchingPoolRuleVecsProb[[regDiscRulesPos]] = N[glmatchingPoolRuleVecsProb[[regDiscRulesPos]]/.gGrammarTimeVar-> timeEventOccured];

(*end of continuous rules integration code*)
,
(*ONLY Accelerated Rules, NO continuous rules*)

timeEventOccured = timeDerivLimit;

randomNumberTime = randomNumberTime/Exp[-totalRateFunc*timeEventOccured];

If[randomNumberTime == 1,
bFoundTimeOfEvent = True;
];

];

bPoolChanged = setDelayedVariables[timeEventOccured];

If[debug,Print["updatePoolAfterIntegration: thePool after = ",thePool];];

If[guseAcceleratedRules,
updateAccelratedRules[timeEventOccured];
];

If[bPoolChanged || guseAcceleratedRules,
(*update the glmatchingPoolRuleVecsProb for next iteration . this is only required when there is no integration of continuous rules. and only if there is a next iteration*)
updatePoolRuleVecsProb[];
];

totalTimeIntegration += timeEventOccured;

If[!bFoundTimeOfEvent,

If[debug,Print["!bFoundTimeOfEvent  -  totalTimeIntegration =  ",totalTimeIntegration];];
If[debug,Print[" !bFoundTimeOfEvent -  maxDerivTimeBetweenSteps =  ",maxDerivTimeBetweenSteps];];

If[totalTimeIntegration>= maxDerivTimeBetweenSteps,
bReachedMaxDerivTime = True;
,
timeDerivLimit *=2;

If[timeDerivLimit> maxDerivTimeBetweenSteps,
timeDerivLimit=maxDerivTimeBetweenSteps;
];
];
If[debug,Print[" !bFoundTimeOfEvent -  timeDerivLimit =  ",timeDerivLimit];];
];

];

If[iterNum-1> gmaxTauiterNum,
gmaxTauiterNum = iterNum-1;
];

If[debug,Print["total num iterations = ",iterNum-1];];

gGrammarTimeFinalVal = totalTimeIntegration;

If[bReachedMaxDerivTime,

gCurSimulationTime += gGrammarTimeFinalVal;

Return[{fnreStatusMaxDeriv,0,0,maxDerivTimeBetweenSteps}];

];

If[!bFoundTimeOfEvent,
Print["findNextRuleExecWithAccel: did not find derivRange after timeDerivLimit = ",timeDerivLimit/2];
Print["findNextRuleExecWithAccel: maxNumDerivIterations = ",maxNumDerivIterations];
Print["findNextRuleExecWithAccel: totalRateFunc = ",totalRateFunc];
Print["findNextRuleExecWithAccel: randomNumberTime = ",randomNumberTime];

Return[{fnreStatusFailed,0,0,0}];
];

,
If[debug,Print["totalRateFunc >=  gContIntegrateRateThreshold!! "];];

If[debug,Print["totalRateFunc = ",totalRateFunc];];

gGrammarTimeFinalVal =  1/totalRateFunc*Log[1/randomNumberTime];

If[debug,Print["gGrammarTimeFinalVal = ",gGrammarTimeFinalVal];];

];
,

If[debug,Print["No Continuous rules!! "];];

If[debug,Print["totalRateFunc = ",totalRateFunc];];
If[totalRateFunc == 0,
Return[{fnreStatusFailed,0,0,0}];
];

gGrammarTimeFinalVal =  1/totalRateFunc*Log[1/randomNumberTime];

If[debug,Print["gGrammarTimeFinalVal = ",gGrammarTimeFinalVal];];

];

(*Print["guy remove gGrammarTimeFinalVal = ",gGrammarTimeFinalVal];*)
gCurSimulationTime += gGrammarTimeFinalVal;

(*choose which discrete rule to fire *)

arrProbs = MapThread[Function[{probVec,validVec},
If[validVec,probVec[[1]],0]
],{Flatten[glmatchingPoolRuleVecsProb,1],Flatten[glMatchingPoolRuleVectorsValid]}];

sumProbs = Apply[Plus,Flatten[arrProbs]];

If[debug,Print["sumProbs = ",sumProbs];];

If[sumProbs == 0,
Return[{fnreStatusFailed,0,0,0}];
];

(* make a random choice of rule firing *)
randomNumber = RandomReal[{0,sumProbs}];

If[debug,Print["randomNumber = ",randomNumber];];

tempProbVal = 0;
posOfRndChosenEntry = 0;
MapIndexed[Function[{curProb,indexCurProb},
tempProbVal+=curProb;

If[posOfRndChosenEntry == 0 && tempProbVal>= randomNumber,
posOfRndChosenEntry = indexCurProb[[1]];
];

],Flatten[arrProbs]];

arrIndexesInPosition = Flatten[
MapIndexed[Function[{vecElems,indexVec},
indexVec
],glmatchingPoolRuleVecsProb,{2}],1];

If[debug,Print["posOfRndChosenEntry = ",posOfRndChosenEntry];];

iRuleIndex = arrIndexesInPosition[[posOfRndChosenEntry]][[1]] ;
iPoolPosForRuleIndex = arrIndexesInPosition[[posOfRndChosenEntry]][[2]] ;

If[debug,
Print["iRuleIndex = ",iRuleIndex];
Print["iPoolPosForRuleIndex = ",iPoolPosForRuleIndex];
Print["exit findNextRuleExecWithAccel"];
];

{fnreStatusDiscreteEvent,iRuleIndex,iPoolPosForRuleIndex,gGrammarTimeFinalVal}
]


SetAttributes[findNextRuleExecWithAccel,ReadProtected]


updatePoolRuleVecsProb[]:=Module[{regDiscRulesPos},

regDiscRulesPos = getRegDiscRulesPos[];

glmatchingPoolRuleVecsProb[[regDiscRulesPos]] = MapThread[Function[{curprobOfRegElemsArr,curposRegElemsDiscRuleArr,rule,indexRule},

MapThread[Function[{probOfRegElems,posRegElemsDiscRule},

(*first assign to the derivative variables their function*)
curLHSDiscRule = thePool[[posRegElemsDiscRule]];
If[debug,Print["curLHSDiscRule 1 = ",curLHSDiscRule];];

If[rule[[indexComplexParamsExp]]==1,

eqTermParams = Flatten[MapThread[Function[{curterm,curpoolitem},
If[Length[curterm]>0,
MapThread[Function[{termParam,poolItemParam},If[Head[termParam]===Pattern,typeTermReg[termParam[[1]]-> poolItemParam],typeTermComplex[termParam==poolItemParam]]],{Apply[List,curterm],Apply[List,curpoolitem]}]
,{}]
],{Flatten[rule[[indexOfAppliedPartOfLHS]]],curLHSDiscRule}]];

If[debug,Print["eqTermParams = ",eqTermParams];];

typeTermRegArr = Cases[eqTermParams,typeTermReg[_]];
If[Length[typeTermRegArr]>0,typeTermRegArr = typeTermRegArr[[All,1]];];

tempEqParams = Flatten[{Cases[eqTermParams,typeTermComplex[_]][[All,1]],
Flatten[Map[Function[{curTermRegRule},If[NumericQ[curTermRegRule[[2]]] , curTermRegRule[[1]] == (curTermRegRule[[1]]/.curTermRegRule),{}]],typeTermRegArr]]
}];

solTermParams = Solve[tempEqParams,rule[[indexOfLHSVars]]];

If[debug,Print["solTermParams = ",solTermParams];];

If[Length[solTermParams]>0,

solTermParams2 = Flatten[{First[solTermParams],typeTermRegArr}];
If[debug,Print["solTermParams2 = ",solTermParams2]];

{tempProb, tempConstraintsRules,replaceAllSec} = 
gRateFuncsStruct[[indexRule]][rule[[indexOfLHSVars]]/.solTermParams2];

,
Print["findNextRuleExecWithAccel: ERROR - no solTermParams ,  {eqTermParams,rule[[indexOfLHSVars]]} ",{eqTermParams,rule[[indexOfLHSVars]]}]
]
,
{tempProb, tempConstraintsRules,replaceAllSec} = 
gRateFuncsStruct[[indexRule]][curLHSDiscRule];

];

If[debug,Print["{tempProb, tempConstraintsRules} = ",{tempProb, tempConstraintsRules}];];

{tempProb, tempConstraintsRules}
],{curprobOfRegElemsArr,curposRegElemsDiscRuleArr}]

],{glmatchingPoolRuleVecsProb[[regDiscRulesPos]],glmatchingPoolRuleVectorsOfRegElems[[regDiscRulesPos]],preReleasegramtrans[[regDiscRulesPos]],regDiscRulesPos}];


]


SetAttributes[updatePoolRuleVecsProb,ReadProtected]


getRegDiscRulesPos[]:=Module[{regDiscRulesPos},
If[Length[gPositionOfDiscRules]!= Length[gPositionOfAcceleratedRules],
regDiscRulesPos = Complement[gPositionOfDiscRules,gPositionOfAcceleratedRules];
,
regDiscRulesPos = gPositionOfDiscRules;
];
regDiscRulesPos
];


updatePoolAfterIntegration[timeEventOccured_]:= Module[{regDiscRulesPos},

(* change the values of all the values in the pool*)

thePool = thePool/. gGrammarTimeVar-> timeEventOccured;

]


SetAttributes[updatePoolAfterIntegration,ReadProtected]


calcTotalRegRate[]:=Module[{regDiscRulesPos},
regDiscRulesPos = getRegDiscRulesPos[];

Apply[Plus,
MapThread[Function[{probVec,validVec},
If[validVec,probVec[[1]],0]
],{Flatten[glmatchingPoolRuleVecsProb[[regDiscRulesPos]],1],Flatten[glMatchingPoolRuleVectorsValid[[regDiscRulesPos]]]}]]
];



SetAttributes[calcTotalRegRate,ReadProtected]


calcTotalDiscreteRate[]:=Module[{},
groundPoolVecRates[];

Apply[Plus,
MapThread[Function[{probVec,validVec},
If[validVec,probVec[[1]],0]
],{Flatten[glGroundPoolVecRates,1],Flatten[glMatchingPoolRuleVectorsValid[[gPositionOfDiscRules]]]}]]
]


SetAttributes[calcTotalDiscreteRate,ReadProtected]


groundPoolVecRates[]:=Module[{timingTemp},

timingTemp = Timing[

If[Length[gPositionOfContRules]>0,
(*now go over all the discrete valid vectors and compute their rate function with the new functions - only needed when there are continuous rules*)
glGroundPoolVecRates = MapThread[Function[{curprobOfRegElemsArr,curposRegElemsDiscRuleArr,rule},

MapThread[Function[{probOfRegElems,posRegElemsDiscRule},

probOfRegElems/.MapThread[Function[{curvar,curval},
curvar-> curval
],{Flatten[Apply[List,gPoolVariables[[posRegElemsDiscRule]],{1}]],Flatten[Apply[List,thePool[[posRegElemsDiscRule]],{1}]]}]
],{curprobOfRegElemsArr,curposRegElemsDiscRuleArr}]

],{glmatchingPoolRuleVecsProb[[gPositionOfDiscRules]],glmatchingPoolRuleVectorsOfRegElems[[gPositionOfDiscRules]],preReleasegramtrans[[gPositionOfDiscRules]]}];
,
glGroundPoolVecRates = glmatchingPoolRuleVecsProb;
];
];

If[debugTiming,Print["groundPoolVecRates: timingTemp = ",timingTemp];];
If[debug,Print["groundPoolVecRates: glGroundPoolVecRates = ",glGroundPoolVecRates]];
];



SetAttributes[groundPoolVecRates,ReadProtected]


gMaxDiffTimeDelta = 0.1;
gNumIterDiffItr = 2;


resetDiffDepFuncs[]:=Module[{},

giDiffDepFuncsTblArr = {};

];


integrateDiffusion[startTime_,endTime_]:=Module[{tempVal,diffDepStrctArr,diffDepLocArr,diffDepFuncsArr,curSourceExprArr,iter,curTime,curDiffDepFuncsArr,tempfunc,curTimeSourceFuncs,arrDeltaTimes,curGrids,diffSolArr,curdiffStructPerVar},
If[debug,
Print["integrateDiffusion : {startTime,endTime} = ",{startTime,endTime}];
];

curSourceExprArr = Table[{},{Length[giSourceFunctions]}];

If[debug,
Print["integrateDiffusion : glmatchingPoolRuleVectorsOfRegElems[[gPositionOfDiffRules]] = ",glmatchingPoolRuleVectorsOfRegElems[[gPositionOfDiffRules]]];
Print["integrateDiffusion : glDiffEqArr = ",glDiffEqArr];
Print["integrateDiffusion : gPositionOfDiffRules = ",gPositionOfDiffRules];
Print["integrateDiffusion : gGrammarDiffElmLoc = ",gGrammarDiffElmLoc];
];

diffDepStrctArr = Flatten[MapThread[Function[{curRulePoolItemsarr,curRuleDiffEqs,curPosDiffRule,curDiffRuleElmLoc},

MapThread[Function[{curRulePoolItems,curRuleVecDiffEqs},

MapThread[Function[{curdiffEq,curEqRuleElemLoc},
curPosSourceFunc = Flatten[Position[giSourceFunctions,curdiffEq[[1,1]]]];

(*go over the variables on the RHS and change them accordingly*)
curdiffEqGrounded = curdiffEq[[1,2]]/.Flatten[Map[Function[{curEqVarLoc},
gPoolVariables[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]][gGrammarTimeVar]-> thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]
],curEqRuleElemLoc[[2]]]];

If[Length[curPosSourceFunc]>0,
(*this function adds to the source term  . Note that we negate the term since its used in the RHS of the equation*)

If[Length[curdiffEqGrounded] > 0,
AppendTo[curSourceExprArr[[curPosSourceFunc[[1]]]], curdiffEqGrounded];
];

{}
,
(*this function adds a diffusion dependent variable*)
dummyHead[{curRulePoolItems[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]},curdiffEqGrounded]
]

],{curRuleVecDiffEqs,curDiffRuleElmLoc}]

],{curRulePoolItemsarr,curRuleDiffEqs}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfDiffRules]],glDiffEqArr,gPositionOfDiffRules,gGrammarDiffElmLoc}]];

If[debug,
Print["integrateDiffusion : curSourceExprArr = ",curSourceExprArr];
];

If[Length[diffDepStrctArr]>0,
diffDepLocArr = diffDepStrctArr[[All,1]];
diffDepFuncsArr = diffDepStrctArr[[All,2]];
,
(*no object is dependent on the diffusion*)
Return[];
];

If[debug,
Print["integrateDiffusion : diffDepLocArr = ",diffDepLocArr];
Print["integrateDiffusion : diffDepFuncsArr = ",diffDepFuncsArr];
];

initializeGrid[startTime,endTime];

If[endTime-startTime<gPDEDeltaTime,

arrDeltaTimes = {endTime-startTime};

,
arrDeltaTimes = Table[gPDEDeltaTime,{Floor[(endTime-startTime)/gPDEDeltaTime]}];
If[endTime-(startTime+Total[arrDeltaTimes])>0,
AppendTo[arrDeltaTimes,endTime-(startTime+Total[arrDeltaTimes])]
];
];

curTime = startTime;
(*if the Length[gPDEGridTrajec]>0 then we started the integration before and now we continue it, since we didn't reach an event *)
curGrids = If[Length[gPDEGridTrajec]>0,Last[gPDEGridTrajec][[2]],gPDEGridArr];

If[debug || debugDiff || debugPlotDiff,
Print["integrateDiffusion : initial curTime = ",curTime];
Map[Print[ListPlot3D[ #, PlotRange -> All ]]&,curGrids];
];

If[Length[giDiffDepFuncsTblArr]<= 0,

curDiffDepFuncsArr = setDiffDepFuncs[0(*curTime*),curGrids,diffDepFuncsArr];

giDiffDepFuncsTblArr = Map[Function[{curVardiffDep},{{0(*curTime*),curVardiffDep}}],curDiffDepFuncsArr];

];

If[debug,
Print["integrateDiffusion : giDiffDepFuncsTblArr = ",giDiffDepFuncsTblArr];
];

diffSolArr = Map[Function[{curDelTime},

timingTemp = Timing[
curGrids = solveOneStepDiffusion[curTime,curDelTime,curGrids,curSourceExprArr];
];
If[debugTiming,
Print["solveOneStepDiffusion timingTemp = ",timingTemp];
];

curTime += curDelTime;

If[debug || debugDiff || debugPlotDiff,
Print["integrateDiffusion : curTime = ",curTime];
Map[Print[ListPlot3D[ #, PlotRange -> All ]]&,curGrids];
];

curDiffDepFuncsArr = setDiffDepFuncs[curTime,curGrids,diffDepFuncsArr];

If[debugDiff,
Print["integrateDiffusion : curDiffDepFuncsArr = ",curDiffDepFuncsArr];
];

{curTime,curGrids,curDiffDepFuncsArr}
],arrDeltaTimes];

gPDEGridTrajec = Join[gPDEGridTrajec,diffSolArr[[All,{1,2}]]];

If[debug || debugDiff || debugPlotDiff,
Print["integrateDiffusion : gPDEGridTrajec"];
Map[Function[{curgrd},Map[Print[ListPlot3D[ #, PlotRange -> All ]]&,curgrd]],gPDEGridTrajec[[All,2]]];
];


(*we trun the structure to be a list for each variable*)
curdiffStructPerVar = Transpose[MapThread[Function[{curTime,cdiffdepfuncarr},Map[{curTime,#}&,cdiffdepfuncarr]],{diffSolArr[[All,1]],diffSolArr[[All,3]]}]];

If[debugDiff,
Print["integrateDiffusion : curdiffStructPerVar = ",curdiffStructPerVar];
];

giDiffDepFuncsTblArr = MapThread[Function[{curVardiffStrct,curVarNewdiffStrct},Join[curVardiffStrct,curVarNewdiffStrct] ],{giDiffDepFuncsTblArr,curdiffStructPerVar}];

If[debugDiff,
Print["integrateDiffusion : giDiffDepFuncsTblArr = ",giDiffDepFuncsTblArr];
];

timingTemp = Timing[
(*set the values back into the pool*)
MapThread[Function[{curDiffLoc,curDiffTblFunc},

If[debugDiff,
Print["curDiffLoc = ",curDiffLoc];
Plot[Interpolation[curDiffTblFunc][t],{t,startTime,endTime}];
];

thePool[[curDiffLoc[[1]],curDiffLoc[[2]]]] = Interpolation[curDiffTblFunc][gGrammarTimeVar];

],{diffDepLocArr,giDiffDepFuncsTblArr}];
];
If[debugTiming,
Print["integrateDiffusion:  Interpolation timingTemp = ",timingTemp];
];

If[debug,
Print["integrateDiffusion : thePool = ",thePool];
]

];


applyNextGrid[endTime_]:=Module[{indexCloseTime},

If[Length[gPDEGridTrajec]>0,

indexCloseTime = Ordering[(endTime-gPDEGridTrajec[[All,1]])^2,1][[1]];

gPDEGridArr = gPDEGridTrajec[[indexCloseTime,2]];
];

If[debug,Print["applyNextGrid: gPDEGridArr = ",gPDEGridArr]];

gPDEGridTrajec = {};
]


initializeGrid[startTime_,endTime_]:=Module[{curPoolSpaceRange,pointBL,realWid,realHi,newgridPointsX,newgridPointsY,sizeGrid,newGrid,poolSpaceSize,deltaSpaceAndGrid,newDimensions,curDimensions,newGridInTraj,numGridPointsInBound},

curPoolSpaceRange = findPoolSpaceRange[startTime,endTime];

If[Length[gPDEGridPos]>0,

pointBL = gPDEGridPos[[1]];
realWid = gPDEGridPos[[2]];
realHi = gPDEGridPos[[3]];

newgridPointsX = newgridPointsY = {0,0};

newgridPointsX[[1]] = countGridPointsToExpand[pointBL[[1]]-curPoolSpaceRange[[1,1]]];
newgridPointsX[[2]] = countGridPointsToExpand[curPoolSpaceRange[[1,2]] -(pointBL[[1]]+realWid)];
newgridPointsY[[1]] = countGridPointsToExpand[pointBL[[2]]-curPoolSpaceRange[[2,1]]];
newgridPointsY[[2]] = countGridPointsToExpand[curPoolSpaceRange[[2,2]] -(pointBL[[2]]+realHi)];

If[debug,
Print["newgridPointsY = ",newgridPointsY];
Print["newgridPointsX = ",newgridPointsX];
];

(*the new values*)
pointBL -=  {newgridPointsX[[1]],newgridPointsY[[1]]}*gDeltaGrid;
realWid +=  Total[newgridPointsX]*gDeltaGrid;
realHi +=  Total[newgridPointsY]*gDeltaGrid;

curDimensions = Dimensions[gPDEGridArr[[1(*first variable's grid*)]]];

newDimensions = curDimensions+{Total[newgridPointsY],Total[newgridPointsX]};

newGrid = createNewGrids[curDimensions,newDimensions,newgridPointsY,newgridPointsX,gPDEGridArr];

(*also change the grids in the trajectory if it exists already*)
If[Length[gPDEGridTrajec]>0,

gPDEGridTrajec = MapIndexed[Function[{curTimeGrid},

newGridInTraj = createNewGrids[curDimensions,newDimensions,newgridPointsY,newgridPointsX,curTimeGrid[[2]]];

{curTimeGrid[[1]](*time*),newGridInTraj}
],gPDEGridTrajec];

];

,

Print["initializeGrid: option 2"];

(*create a new grid per diffusion variable with initial value of 0*)
poolSpaceSize = Flatten[{Differences[curPoolSpaceRange[[1]]],Differences[curPoolSpaceRange[[2]]]}];

sizeGrid = Ceiling[poolSpaceSize/gDeltaGrid];

{realWid,realHi} = sizeGrid*gDeltaGrid;

deltaSpaceAndGrid = Abs[poolSpaceSize-sizeGrid*gDeltaGrid];
(*the Bottom Left corner is the bottom left point of the pool space ,and subtract 1/2 the difference to the grid size*)
pointBL = curPoolSpaceRange[[All,1]]-deltaSpaceAndGrid/2;

(*remeber the X is the number of coloumns, and Y  is rows. +1 because the sizeGrid is the number of deltas*)
newGrid = Table[Table[0.0,{sizeGrid[[2]]+1},{sizeGrid[[1]]+1}],{Length[giDiffVars]}];

];

gPDEGridPos = {pointBL,realWid,realHi};
gPDEGridArr = newGrid;

numGridPointsInBound = Round[gPdeBoundaryWidth/gDeltaGrid];

gPDEGridBoundIndexes = {{numGridPointsInBound,Dimensions[gPDEGridArr[[1]]][[1]]-numGridPointsInBound},{numGridPointsInBound,Dimensions[gPDEGridArr[[1]]][[2]]-numGridPointsInBound}};

If[debugDiff,
Print["initializeGrid: gPDEGridPos = ",gPDEGridPos];
Print["initializeGrid: gPDEGridArr = ",gPDEGridArr];
];

initBoundaryFuncs[];

];


createNewGrids[curDimensions_,newDimensions_,newgridPointsY_,newgridPointsX_,inPDEGridArr_]:=Module[{newGrid,bottomBoundVals,topBoundVals,leftBoundVals,rightBoundVals},

newGrid = Table[Table[0.0,{newDimensions[[1]]},{newDimensions[[2]]}],{Length[giDiffVars]}];

MapIndexed[Function[{curVarGrid,curVarInd},
newGrid[[curVarInd[[1]],Range[1+newgridPointsY[[1]],curDimensions[[1]]+newgridPointsY[[1]]],Range[1+newgridPointsX[[1]],curDimensions[[2]]+newgridPointsX[[1]]]]] = curVarGrid;

(*set the new values (on the boundaries) in the grid according to the boundaries of the old grid. This is instaed of setting them to 0 which doesnt work sometimes. *)
bottomBoundVals = Join[Table[curVarGrid[[1,1]],{newgridPointsX[[1]]}],curVarGrid[[1]],Table[curVarGrid[[1,curDimensions[[2]]]],{newgridPointsX[[2]]}]];

topBoundVals = Join[Table[curVarGrid[[curDimensions[[1]],1]],{newgridPointsX[[1]]}],curVarGrid[[curDimensions[[1]]]],Table[curVarGrid[[curDimensions[[1]],curDimensions[[2]]]],{newgridPointsX[[2]]}]];

leftBoundVals = curVarGrid[[All,1]];
rightBoundVals = curVarGrid[[All,curDimensions[[2]]]];

Table[newGrid[[curVarInd[[1]],i,All]]= bottomBoundVals,{i,1,newgridPointsY[[1]]}];
Table[newGrid[[curVarInd[[1]],i,All]]=topBoundVals,{i,curDimensions[[1]]+newgridPointsY[[1]]+1,newDimensions[[1]]}];

Table[newGrid[[curVarInd[[1]],Range[1+newgridPointsY[[1]],curDimensions[[1]]+newgridPointsY[[1]]],j]] = leftBoundVals,{j,1,newgridPointsX[[1]]}];

Table[newGrid[[curVarInd[[1]],Range[1+newgridPointsY[[1]],curDimensions[[1]]+newgridPointsY[[1]]],j]] = rightBoundVals,{j,curDimensions[[2]]+newgridPointsX[[1]]+1,newDimensions[[2]]}];

],inPDEGridArr];

newGrid

];


(*changed back to older version above
createNewGrids[curDimensions_,newDimensions_,newgridPointsY_,newgridPointsX_,inPDEGridArr_]:=Module[{newGrid,bottomBoundVals,topBoundVals,leftBoundVals,rightBoundVals,validRangeForCurGrid,posnewgridPointY,posnewgridPointX,validVarGrid,validGridDim},

newGrid = Table[Table[0.0,{newDimensions[[1]]},{newDimensions[[2]]}],{Length[giDiffVars]}];

validRangeForCurGrid = {{Max[1,1-newgridPointsY[[1]]],Min[curDimensions[[1]],curDimensions[[1]]+newgridPointsY[[2]]]},
{Max[1,1-newgridPointsX[[1]]],Min[curDimensions[[2]],curDimensions[[2]]+newgridPointsX[[2]]]}};

posnewgridPointY = {Max[0,newgridPointsY[[1]]],Max[0,newgridPointsY[[2]]]};
posnewgridPointX = {Max[0,newgridPointsX[[1]]],Max[0,newgridPointsX[[2]]]};

MapIndexed[Function[{curVarGrid,curVarInd},

curDimensions = Dimensions[curVarGrid];

validVarGrid = curVarGrid[[Range[validRangeForCurGrid[[1,1]],validRangeForCurGrid[[1,2]]],Range[validRangeForCurGrid[[2,1]],validRangeForCurGrid[[2,2]]]]];

validGridDim = Dimensions[validVarGrid];

newGrid[[curVarInd[[1]],Range[1+posnewgridPointY[[1]],validGridDim[[1]]+posnewgridPointY[[1]]],Range[1+posnewgridPointX[[1]],validGridDim[[2]]+posnewgridPointX[[1]]]]] = validVarGrid;

(*set the new values (on the boundaries) in the grid according to the boundaries of the old grid. This is instaed of setting them to 0 which doesnt work sometimes. *)
bottomBoundVals = Join[Table[validVarGrid[[1,1]],{posnewgridPointX[[1]]}],validVarGrid[[1]],Table[validVarGrid[[1,validGridDim[[2]]]],{posnewgridPointX[[2]]}]];

topBoundVals = Join[Table[validVarGrid[[validGridDim[[1]],1]],{posnewgridPointX[[1]]}],validVarGrid[[validGridDim[[1]]]],Table[validVarGrid[[validGridDim[[1]],validGridDim[[2]]]],{posnewgridPointX[[2]]}]];

leftBoundVals = validVarGrid[[All,1]];
rightBoundVals = validVarGrid[[All,validGridDim[[2]]]];

Table[newGrid[[curVarInd[[1]],i,All]]= bottomBoundVals,{i,1,posnewgridPointY[[1]]}];
Table[newGrid[[curVarInd[[1]],i,All]]=topBoundVals,{i,validGridDim[[1]]+posnewgridPointY[[1]]+1,newDimensions[[1]]}];

Table[newGrid[[curVarInd[[1]],Range[1+posnewgridPointY[[1]],validGridDim[[1]]+posnewgridPointY[[1]]],j]] = leftBoundVals,{j,1,posnewgridPointX[[1]]}];

Table[newGrid[[curVarInd[[1]],Range[1+posnewgridPointY[[1]],validGridDim[[1]]+posnewgridPointY[[1]]],j]] = rightBoundVals,{j,validGridDim[[2]]+posnewgridPointX[[1]]+1,newDimensions[[2]]}];

],inPDEGridArr];

newGrid

];
*)


initBoundaryFuncs[]:=Module[{numRows,numCols},

{numRows,numCols} = Dimensions[gPDEGridArr[[1]]];

If[debugDiff,Print["initBoundaryFuncs {numRows,numCols} = ",{numRows,numCols}];];


gDiffboundaryTypefuncX[1]= gDiffBoundTypeLeft;
gDiffboundaryTypefuncX[numCols]= gDiffBoundTypeRight;
gDiffboundaryTypefuncY[1]= gDiffBoundTypeBottom;
gDiffboundaryTypefuncY[numRows]= gDiffBoundTypeTop;

gDiffboundaryValfuncX[1]=gDiffBoundValLeft;
gDiffboundaryValfuncX[numCols]= gDiffBoundValRight;
gDiffboundaryValfuncY[1]= gDiffBoundValBottom;
gDiffboundaryValfuncY[numRows]= gDiffBoundValTop;

If[debugDiff,Print["initBoundaryFuncs gDiffboundaryValfuncY[numRows] = ",gDiffboundaryValfuncY[numRows]];
];

]


countGridPointsToExpand[posDiff_]:=If[posDiff>0,Ceiling[posDiff/gDeltaGrid],0]


(*changed back -  countGridPointsToExpand[posDiff_]:=Sign[posDiff]Ceiling[Abs[posDiff]/gDeltaGrid]*)


findPoolSpaceAxisRangeAtTime[diffSpatialParam_,inTime_]:=Module[{curPosVal,curRVal,arrVals},

arrVals = Map[Function[{curObj},
curPosVal = Null;
curRVal = 0;
Map[If[#[[1]]==Head[curObj],curPosVal = curObj[[#[[2]]]];] &, diffSpatialParam];
Map[If[#[[1]]==Head[curObj],curRVal = curObj[[#[[2]]]];] &, gArrDiffSpatialParamR];

If[curPosVal=!= Null,
{curPosVal-curRVal,curPosVal+curRVal}/. gGrammarTimeVar-> inTime
,
{\[Infinity],-\[Infinity]}
]
],thePool];

{Min[arrVals[[All,1]]],Max[arrVals[[All,2]]]}

]


findPoolSpaceRange[startTime_,endTime_]:=Module[{rangeX1,rangeX2,rangeY1,rangeY2},

rangeX1 = findPoolSpaceAxisRangeAtTime[gArrDiffSpatialParamX,startTime];
rangeX2 = findPoolSpaceAxisRangeAtTime[gArrDiffSpatialParamX,endTime];
rangeY1 = findPoolSpaceAxisRangeAtTime[gArrDiffSpatialParamY,startTime];
rangeY2 = findPoolSpaceAxisRangeAtTime[gArrDiffSpatialParamY,endTime];

{{Min[{rangeX1,rangeX2}[[All,1]]]-gPdeBoundaryWidth,Max[{rangeX1,rangeX2}[[All,2]]]+gPdeBoundaryWidth},
{Min[{rangeY1,rangeY2}[[All,1]]]-gPdeBoundaryWidth,Max[{rangeY1,rangeY2}[[All,2]]]+gPdeBoundaryWidth}}

]


SetAttributes[integrateDiffusion,ReadProtected]


solveOneStepDiffusion[curTime_,curDelTime_,curGrids_,curSourceExprArr_]:=Module[{curTimeSourceExprArr,nextVarGrid,nextGridarr,tblLHSEq,iniSourcetbl,curloc,currad, curmult,arrSourceGrid,curvarSourceTbl,arrSrcGridInd,arrGridSrc,pointBL,realWid,realHi,totWeight,standDevSource,endSrcPos,midSrcPos,radSrcPos,curwgt,distToLoc,tempdist,arrDiffGrids,arrDecayGrids},


If[debugDiff,Print["solveOneStepDiffusion : {curTime,curDelTime,curGrids,curSourceExprArr} = ",{curTime,curDelTime,curGrids,curSourceExprArr}];];

{pointBL,realWid,realHi} = gPDEGridPos;
If[debugDiff,Print["solveOneStepDiffusion : {pointBL,realWid,realHi} = ",{pointBL,realWid,realHi}];];

curTimeSourceExprArr = curSourceExprArr/.{gGrammarTimeVar-> curTime+curDelTime};

If[debugDiff,Print["solveOneStepDiffusion : curTimeSourceExprArr = ",curTimeSourceExprArr];];

iniSourcetbl = Table[0.0,{Dimensions[curGrids[[1]]][[1]]},{Dimensions[curGrids[[1]]][[2]]}];

timingTemp = Timing[

arrSourceGrid = Map[Function[{curVarSoucesExp},
curvarSourceTbl = iniSourcetbl;

Map[Function[{curSrcexp},

(* curSrcexp = {{cx,cy},cr, cr*gSrcMult[[celltype,ptype]]} *)
{curloc,currad, curmult} = curSrcexp;
curloc -= pointBL;
If[debugDiff,Print["solveOneStepDiffusion : {curloc,currad, curmult} = ",{curloc,currad, curmult}];];

standDevSource = currad/1;

endSrcPos = Round[{curloc-currad,curloc+currad}/gDeltaGrid]+1;
midSrcPos = (endSrcPos[[2]]+endSrcPos[[1]])/2;
radSrcPos = (endSrcPos[[2,1]]-endSrcPos[[1,1]])/2;

If[endSrcPos[[1,2]]< 1 ,
Print["ERROR: solveOneStepDiffusion  - dimensions of new grid are too small !!, Dimensions[iniSourcetbl] = ",Dimensions[iniSourcetbl]," endSrcPos[[1,2]] = ",endSrcPos[[1,2]]];
endSrcPos[[1,2]] = 1;
];

If[endSrcPos[[2,2]]> Dimensions[iniSourcetbl][[1]] ,
Print["ERROR: solveOneStepDiffusion  - dimensions of new grid are too small !!, Dimensions[iniSourcetbl] = ",Dimensions[iniSourcetbl]," endSrcPos[[2,2]] = ",endSrcPos[[2,2]]];
endSrcPos[[2,2]]= Dimensions[iniSourcetbl][[1]];
];

If[endSrcPos[[1,1]]< 1 ,
Print["ERROR: solveOneStepDiffusion  - dimensions of new grid are too small !!, Dimensions[iniSourcetbl] = ",Dimensions[iniSourcetbl]," endSrcPos[[1,1]] = ",endSrcPos[[1,1]]];
endSrcPos[[1,1]] = 1;
];

If[endSrcPos[[2,1]]> Dimensions[iniSourcetbl][[2]] ,
Print["ERROR: solveOneStepDiffusion  - dimensions of new grid are too small !!, Dimensions[iniSourcetbl] = ",Dimensions[iniSourcetbl]," endSrcPos[[2,1]] = ",endSrcPos[[2,1]]];
endSrcPos[[2,1]]= Dimensions[iniSourcetbl][[2]];
];

(*version 1
assume that each node in the grid has the concentration.
*)

If[gSecretionDistributionOption == 1,

arrSrcGridInd = N[Table[

distToLoc = EuclideanDistance[{xi,yi}*gDeltaGrid,curloc];

If[distToLoc+gDeltaGrid/2<currad,
curmult,
tempdist = gDeltaGrid-(distToLoc+gDeltaGrid/2-currad);
If[tempdist>0,
curmult*tempdist/gDeltaGrid
,
0
]
],
{yi,endSrcPos[[1,2]],endSrcPos[[2,2]]},
{xi,endSrcPos[[1,1]],endSrcPos[[2,1]]}
]];
(*Print["arrSrcGridInd = ",MatrixForm[arrSrcGridInd]];*)
curvarSourceTbl[[Range[endSrcPos[[1,2]],endSrcPos[[2,2]]],Range[endSrcPos[[1,1]],endSrcPos[[2,1]]]]] += arrSrcGridInd;

,

(*these ones wont work now !!! because the indexes in endSrcPos were changed , the endSrcPos = ... +1 above, there was no +1 before *)

(*version 2 of source distribution : find the grid indexs that are covered by the source. Also each point gets a weight that depends on the distance to center cell. According to Normal Distribution with radius/2 as Standard Deviation

N[PDF[NormalDistribution[curloc[[2]],standDevSource],yi*gDeltaGrid]*PDF[NormalDistribution[curloc[[1]],standDevSource],xi*gDeltaGrid]]
*)
(*version 3 :
according to euclidean distance
*)
arrSrcGridInd = Flatten[Table[{
If[gSecretionDistributionOption==2,
(*N[PDF[NormalDistribution[curloc[[2]],standDevSource],yi*gDeltaGrid]*PDF[NormalDistribution[curloc[[1]],standDevSource],xi*gDeltaGrid]]*)
(*this expression the weight will be 1 for middle point, and 0.5 for a point on the *)
curwgt  = N[-(0.5/currad^2)Total[({xi,yi}*gDeltaGrid-curloc)^2]+1];
If[curwgt>0,curwgt,0]
,
If[Sqrt[Total[({xi,yi}-midSrcPos)^2]]<= radSrcPos,1,0]
],{yi+1,xi+1}},
{yi,endSrcPos[[1,2]],endSrcPos[[2,2]]},
{xi,endSrcPos[[1,1]],endSrcPos[[2,1]]}
],1];

If[debugDiff,Print["solveOneStepDiffusion : arrSrcGridInd = ",arrSrcGridInd];];

totWeight = Total[arrSrcGridInd[[All,1]]];

If[totWeight>  0,
(*the source is distributed evenly among the grid points*)
arrGridSrc = Map[{(curmult*#[[1]])/totWeight,#[[2]]}&,arrSrcGridInd];

If[debugDiff,Print["solveOneStepDiffusion : arrGridSrc = ",arrGridSrc];];

Map[Function[{curPnt},
If[gPDEGridBoundIndexes[[1,1]]<=curPnt[[2,1]] <= gPDEGridBoundIndexes[[1,2]] && gPDEGridBoundIndexes[[2,1]]<=curPnt[[2,2]] <= gPDEGridBoundIndexes[[2,2]],
curvarSourceTbl[[curPnt[[2,1]],curPnt[[2,2]]]] += curPnt[[1]]]],arrGridSrc];
,
Print["solveOneStepDiffusion - ERROR: totWeight = ",totWeight,", endSrcPos = ",endSrcPos, " , midSrcPos = ",midSrcPos," , radSrcPos = ",radSrcPos];
];
]
],curVarSoucesExp];

curvarSourceTbl
],curTimeSourceExprArr];

];

arrSourceGrid = Chop[arrSourceGrid];

If[debugTiming,Print["solveDiffusion : arrSourceGrid   timingTemp = ",timingTemp];];
If[debugDiff,Print["solveDiffusion : arrSourceGrid = ",arrSourceGrid];];

If[gIsDiffDecayFunc,

arrDiffGrids = Map[Function[{curVarDiffConstFunc},

curVarDiffConstFunc[Dimensions[curGrids[[1]]],pointBL,gDeltaGrid]

],gValsDiffConstant];

arrDecayGrids = Map[Function[{curVarDecayFunc},

curVarDecayFunc[Dimensions[curGrids[[1]]],pointBL,gDeltaGrid]

],gValsDiffVarsDecay];


nextGridarr = MapThread[Function[{curVarGrid,curVarSourceGrid,curVarDiffGrid,curVarDecayGrid},

If[debugDiff,Print["solveDiffusion : {curVarGrid,gDeltaGrid,curDelTime,curVarDiffGrid,curVarDecayGrid,gDiffboundaryTypefuncX,gDiffboundaryTypefuncY} = ",{curVarGrid,gDeltaGrid,curDelTime,curVarDiffGrid,curVarDecayGrid,gDiffboundaryTypefuncX,gDiffboundaryTypefuncY}];];

(*Impoprtant: we apply this init function every deltatime because curDelTime may be different for the lastdelta , before endTime. We can make it more efficient by calling it only in the first and last deltaT *)
tblLHSEq = iniCrankNicolsonEquations3[curVarGrid,gDeltaGrid,curDelTime,curVarDiffGrid,curVarDecayGrid,gDiffboundaryTypefuncX,gDiffboundaryTypefuncY];

If[debugDiff,Print["solveDiffusion : {tblLHSEq,curVarGrid,gDeltaGrid,curDelTime,curVarDiffGrid,curVarDecayGrid,curVarSourceGrid,gDiffboundaryValfuncX,gDiffboundaryValfuncY} = ",{tblLHSEq,curVarGrid,gDeltaGrid,curDelTime,curVarDiffGrid,curVarDecayGrid,curVarSourceGrid,gDiffboundaryValfuncX,gDiffboundaryValfuncY}];];

nextVarGrid = pdeCrankNicolsonOneStep3[tblLHSEq,curVarGrid,gDeltaGrid,curDelTime,curVarDiffGrid,curVarDecayGrid,curVarSourceGrid,gDiffboundaryValfuncX,gDiffboundaryValfuncY, pdeCNSolveOption-> 1];


nextVarGrid
],{curGrids,arrSourceGrid,arrDiffGrids,arrDecayGrids}];

,
nextGridarr = MapThread[Function[{curVarGrid,curVarSourceGrid,curVarDiffConst,curVarDecayConst},

If[debugDiff,Print["solveDiffusion : {curVarGrid,gDeltaGrid,curDelTime,curVarDiffConst,curVarDecayConst,gDiffboundaryTypefuncX,gDiffboundaryTypefuncY} = ",{curVarGrid,gDeltaGrid,curDelTime,curVarDiffConst,curVarDecayConst,gDiffboundaryTypefuncX,gDiffboundaryTypefuncY}];];

(*Impoprtant: we apply this init function every deltatime because curDelTime may be different for the lastdelta , before endTime. We can make it more efficient by calling it only in the first and last deltaT *)
tblLHSEq = iniCrankNicolsonEquations[curVarGrid,gDeltaGrid,curDelTime,curVarDiffConst,curVarDecayConst,gDiffboundaryTypefuncX,gDiffboundaryTypefuncY];

If[debugDiff,Print["solveDiffusion : {tblLHSEq,curVarGrid,gDeltaGrid,curDelTime,curVarDiffConst,curVarDecayConst,curVarSourceGrid,gDiffboundaryValfuncX,gDiffboundaryValfuncY} = ",{tblLHSEq,curVarGrid,gDeltaGrid,curDelTime,curVarDiffConst,curVarDecayConst,curVarSourceGrid,gDiffboundaryValfuncX,gDiffboundaryValfuncY}];];

nextVarGrid = pdeCrankNicolsonOneStep[tblLHSEq,curVarGrid,gDeltaGrid,curDelTime,curVarDiffConst,curVarDecayConst,curVarSourceGrid,gDiffboundaryValfuncX,gDiffboundaryValfuncY, pdeCNSolveOption-> 1];


nextVarGrid
],{curGrids,arrSourceGrid,gValsDiffConstant,gValsDiffVarsDecay}];

];

nextGridarr = Chop[nextGridarr];

If[debugDiff,
Print["solveDiffusion : nextGridarr = ",nextGridarr];
];

nextGridarr

]


setDiffDepFuncs[inTime_,inGridArr_,diffDepFuncsArr_]:=Module[{curDiffFunctions,curDiffDepFuncsArr},

curDiffFunctions = Map[Function[{curVarGrid},
Function[{inX,inY,inR},
getDiffVal[inX,inY,inR,curVarGrid]
]

],inGridArr];

(*after integration - add to the values*)
curDiffDepFuncsArr = diffDepFuncsArr/.gGrammarTimeVar-> inTime;

curDiffDepFuncsArr = curDiffDepFuncsArr /.  MapThread[Function[{curDiffVar,curDiffFunc},curDiffVar->curDiffFunc ],{giDiffVars,curDiffFunctions}];

curDiffDepFuncsArr
]


getDiffVal[inX_,inY_,currad_,curDiffTbl_]:= Module[{curwgt,totWeight,pointBL,realWid,realHi,curloc,endSrcPos,midSrcPos,radSrcPos,arrSrcGridInd,totArea,totSub,avgSub},

curloc = {inX,inY};

{pointBL,realWid,realHi} = gPDEGridPos;

curloc -= pointBL;

endSrcPos = Round[{curloc-currad,curloc+currad}/gDeltaGrid];

midSrcPos = (endSrcPos[[2]]+endSrcPos[[1]])/2;
radSrcPos = (endSrcPos[[2,1]]-endSrcPos[[1,1]])/2;

If[endSrcPos[[1,2]]< 0 ,
Print["ERROR: getDiffVal  - dimensions of new grid are too small !!, Dimensions[curDiffTbl] = ",Dimensions[curDiffTbl]," endSrcPos[[1,2]] = ",endSrcPos[[1,2]]];
endSrcPos[[1,2]] = 0;
];

If[endSrcPos[[2,2]]> Dimensions[curDiffTbl][[1]]-1 ,
Print["ERROR: getDiffVal  - dimensions of new grid are too small !!, Dimensions[curDiffTbl] = ",Dimensions[curDiffTbl]," endSrcPos[[2,2]] = ",endSrcPos[[2,2]]];
endSrcPos[[2,2]]= Dimensions[curDiffTbl][[1]]-1;
];

If[endSrcPos[[1,1]]< 0 ,
Print["ERROR: getDiffVal  - dimensions of new grid are too small !!, Dimensions[curDiffTbl] = ",Dimensions[curDiffTbl]," endSrcPos[[1,1]] = ",endSrcPos[[1,1]]];
endSrcPos[[1,1]] = 0;
];

If[endSrcPos[[2,1]]> Dimensions[curDiffTbl][[2]]-1 ,
Print["ERROR: getDiffVal  - dimensions of new grid are too small !!, Dimensions[curDiffTbl] = ",Dimensions[curDiffTbl]," endSrcPos[[2,1]] = ",endSrcPos[[2,1]]];
endSrcPos[[2,1]]= Dimensions[curDiffTbl][[2]]-1;
];

arrSrcGridInd = Flatten[Table[{
If[gSecretionDistributionOption==1 ||gSecretionDistributionOption==2 ,
(*N[PDF[NormalDistribution[curloc[[2]],standDevSource],yi*gDeltaGrid]*PDF[NormalDistribution[curloc[[1]],standDevSource],xi*gDeltaGrid]]*)
(*this expression the weight will be 1 for middle point, and 0.5 for a point on the *)
curwgt  = N[-(0.5/currad^2)Total[({xi,yi}*gDeltaGrid-curloc)^2]+1];
If[curwgt>0,curwgt,0]
,
If[Sqrt[Total[({xi,yi}-midSrcPos)^2]]<= radSrcPos,1,0]
],{yi+1,xi+1}},
{yi,endSrcPos[[1,2]],endSrcPos[[2,2]]},
{xi,endSrcPos[[1,1]],endSrcPos[[2,1]]}
],1];

totWeight = Total[arrSrcGridInd[[All,1]]];

If[totWeight<= 0,
If[Length[arrSrcGridInd[[All,1]]]<= 0 ,
Print["ERROR: getDiffVal totWeight = ",totWeight];
Print["ERROR: getDiffVal {inX,inY,currad,curDiffTbl} = ",{inX,inY,currad,curDiffTbl}];
Print["ERROR: getDiffVal arrSrcGridInd = ",arrSrcGridInd];
];

(*then this means that the radius is so small that it falls between grid points *)
arrSrcGridInd[[All,1]] = 1/Length[arrSrcGridInd[[All,1]]];
totWeight = 1;
];


(*previous version had /(totWeight*gDeltaGrid^2) but now we assume the *)
avgSub = Total[Map[Function[{curGrdInd},curGrdInd[[1]]*curDiffTbl[[curGrdInd[[2,1]],curGrdInd[[2,2]]]]],arrSrcGridInd]]/totWeight;

avgSub


]


SetAttributes[solveDiffusion,ReadProtected]


groundDervEq[diffVarsEqsArr_,algVarsEqsArr_,typeVarsArr_,bGroundAll_]:= Module[{groundedContEqArr,totGroundedContEqArr,tempcontEq,counterReduceTerms,totalCounter,bReturnTerm},

(*replace variables for constants when typeVarConstant or a delayed rule . replace their time derivative with 0 since they do not change over time*)
totalCounter = counterReduceTerms = 0;

timingTemp = Timing[
groundedContEqArr = MapThread[Function[{curRulePoolItemsarr,curRuleContEqs,curPosContRule,curContRuleElmLoc},

(*Print["curPosContRule = ",curPosContRule];*)

bCurRuleIsDelayed = MemberQ[gPositionOfDelayedContRules,curPosContRule];
If[!bCurRuleIsDelayed,
MapThread[Function[{curRulePoolItems,curRuleVecContEqs},

(*Print["thePool[[curRulePoolItems]] = ",thePool[[curRulePoolItems]]];*)

MapThread[Function[{curcontEq,curEqRuleElemLoc},

bReturnTerm = True;

If[gReduceNumberTermsInEquation,

(*go over the variables on the RHS and change them accordingly*)
tempcontEq = curcontEq[[1,2]]/.Join[Flatten[Map[Function[{curEqVarLoc},

gPoolVariables[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]][gGrammarTimeVar]-> thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]

],curEqRuleElemLoc[[2]]]],If[bCurRuleIsDelayed,{(*gGrammarTimeVar-> 0*)},{}]];

(*Print["tempcontEq = ",tempcontEq];*)
If[(tempcontEq< gEpsilonReduceNumberTerms && tempcontEq> -gEpsilonReduceNumberTerms) ||  tempcontEq == 0,
counterReduceTerms++;
bReturnTerm = False;
]

];
totalCounter++;

(*Print["bReturnTerm = ",bReturnTerm];*)

If[bReturnTerm,
curcontEq[[1,2]]/.Join[Flatten[Map[Function[{curEqVarLoc},

If[typeVarsArr[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]] == typeVarConstant || bGroundAll,
{gPoolVariables[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]][gGrammarTimeVar]-> thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]],

\!\(\*SuperscriptBox[
RowBox[{"gPoolVariables", "[", 
RowBox[{"[", 
RowBox[{
RowBox[{"curRulePoolItems", "[", 
RowBox[{"[", 
RowBox[{"curEqVarLoc", "[", 
RowBox[{"[", "1", "]"}], "]"}], "]"}], "]"}], ",", 
RowBox[{"curEqVarLoc", "[", 
RowBox[{"[", "2", "]"}], "]"}]}], "]"}], "]"}], "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar]-> 0
},
{}
]

],curEqRuleElemLoc[[2]]]],If[bCurRuleIsDelayed,{(*gGrammarTimeVar-> 0*)},{}]]
,0]

],{curRuleVecContEqs,curContRuleElmLoc}]

],{curRulePoolItemsarr,curRuleContEqs}],
{}
]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]],glContEqArr,gPositionOfContRules,gGrammarContElmLoc}];

Print["{counterReduceTerms,totalCounter} = ",{counterReduceTerms,totalCounter}];
];

If[debugTiming,Print[" groundDervEq 1  timingTemp = ",timingTemp];];

timingTemp = Timing[
totGroundedContEqArr = MapThread[Function[{curItemVals,curItemVars,curItemVarsDiffEq,curItemVarsAlgEq,curItemTypeVars},

MapThread[Function[{curVal,curVar,curVarDiffEqs,curVarAlgEqs,curtypevar},

curtotDiffEq = Map[Function[{curVarEqLoc},

Extract[groundedContEqArr,curVarEqLoc]

],curVarDiffEqs];

curtotAlgEq = Map[Function[{curVarEqLoc},

Extract[groundedContEqArr,curVarEqLoc]

],curVarAlgEqs];

If[Length[curtotDiffEq]>0 && Length[curtotAlgEq]>0,
Print["ERROR: findNextRuleExecWithAccel - Length[curtotDiffEq]>0 && Length[curtotAlgEq]>0"];
Print["curVar = ",curVar];
];

If[Length[curtotDiffEq]>0,

If[curtypevar != typeVarDervTime ,
Print["ERROR: findNextRuleExecWithAccel - curtypevar \[NotEqual] typeVarDervTime , curtypevar = "curtypevar];
Print["curVar = ",curVar];
];

{Derivative[1][curVar] [gGrammarTimeVar] , Total[curtotDiffEq]}
,
If[Length[curtotAlgEq]>0,

If[curtypevar != typeVarFuncTime ,
Print["ERROR: findNextRuleExecWithAccel - curtypevar \[NotEqual] typeVarFuncTime , curtypevar = "curtypevar];
Print["curVar = ",curVar];
];

{curVar [gGrammarTimeVar] , Total[curtotAlgEq]}
,
0
]
]/.curVar [N[0]]-> curVal

],{Apply[List,curItemVals],Apply[List,curItemVars],curItemVarsDiffEq,curItemVarsAlgEq,curItemTypeVars}]

],{thePool,gPoolVariables,diffVarsEqsArr,algVarsEqsArr,typeVarsArr}];
];

If[debugTiming,Print[" groundDervEq 2  timingTemp = ",timingTemp];];

totGroundedContEqArr
];


SetAttributes[groundDervEq,ReadProtected]


getTimeDependetEqArr[]:=Module[{totGroundedContEqArr},

DeleteCases[Flatten[Map[Function[{curObjEqs},
Map[Function[{curEq},
If[curEq[[1]] === 0,0,curEq[[1]]== curEq[[2]]]
],curObjEqs]
],gPoolObjContEqs]],0]
];



SetAttributes[getTimeDependetEqArr,ReadProtected]


getIniValsEq[]:=Module[{},

Flatten[MapThread[Function[{curItemVals,curPoolItemVars,curItemTypeVars},

DeleteCases[MapThread[Function[{curVal,curVar,curtypevar},

If[curtypevar == typeVarDervTime,
curVar[0]== curVal,0]

],{Apply[List,curItemVals],Apply[List,curPoolItemVars],curItemTypeVars}],0]

],{thePool,gPoolVariables,gPoolObjVarTypes}]]
]


SetAttributes[getIniValsEq,ReadProtected]


createContEqsStrcuts[]:=Module[{buse},
If[debug,
Print["createContEqsStrcuts start"];
];

(*there are continuous rule-elements or accelerated rules*)
If[Length[gPositionOfContRules]>0,
createContEqs[];
];

If[(guseAcceleratedRules || gbEnforceAllRulesAccelStruct) && Length[gPositionOfAcceleratedRules]>0,
createAccelRates[];
];

If[Length[gPositionOfDiffRules]>0,
createDiffEqs[];
];

(*immediatly remove the new vectors after using them*)
glNewMatchingPoolRuleVectorsOfRegElems = Table[{},{Length[glNewMatchingPoolRuleVectorsOfRegElems]}];

]


SetAttributes[createContEqsStrcuts,ReadProtected]


createDiffEqs[]:=Module[{timingTemp1,newDiffEqArr},

timingTemp1 = Timing[
(*first create a differential equation for all the NEW vectors*)
newDiffEqArr  = MapThread[Function[{curRulePoolItemsarr,curContRuleSolving,curContRuleElmLoc,curContRuleLHS},

Map[Function[{curRulePoolItems},

MapThread[Function[{curEqInSolvingSection,curEqRuleElemLoc},

curEqInSolvingSection/. MapThread[Function[{curelem,curvar},
curelem-> curvar
],{Extract[curContRuleLHS,curEqRuleElemLoc[[2]]],
Extract[gPoolVariables[[curRulePoolItems]],curEqRuleElemLoc[[2]]]}]

],{curContRuleSolving,curContRuleElmLoc}]

],curRulePoolItemsarr]

],{glNewMatchingPoolRuleVectorsOfRegElems[[gPositionOfDiffRules]],gGrammarDiffRulesSolvingSec,gGrammarDiffElmLoc,gGrammarRulesLHS[[gPositionOfDiffRules]]}];

If[Length[glDiffEqArr]>0,

glDiffEqArr[[gPosNonSpatialDiffRules]] = MapThread[Function[{curRuleNewContEqs,curRuleContEqs},Join[curRuleNewContEqs,curRuleContEqs] ],{newDiffEqArr[[gPosNonSpatialDiffRules]],glDiffEqArr[[gPosNonSpatialDiffRules]]}];

glDiffEqArr[[gPosSpatialDiffRules]] = newDiffEqArr[[gPosSpatialDiffRules]];
,
glDiffEqArr = newDiffEqArr;
]
];
]


SetAttributes[createDiffEqs,ReadProtected]


createContEqs[]:=Module[{timingTemp1,arrNewSpatialVecs,prevPoolObjVarTypes},

(*go over 
for spatial rules  - gPoolObjSpatialConnectArr;
for nonspatial rules - glmatchingPoolRuleVectorsOfRegElems;

and for each vector has at least one gPoolObjModified[[vector]] that is True , then add it to the Equations variable gPoolObjContEqs
*)
If[debug,Print["createContEqs start"];];
If[debug,Print["createContEqs start glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]] = ",glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]]];];


arrNewSpVecsPerRule = MapIndexed[Function[{rule,indexRule},

If[MemberQ[gPositionOfContRules,indexRule[[1]]] && MemberQ[gPositionOfSpatialRules,indexRule[[1]]],

timingVar = Timing[
arrNewSpatialVecs = createNewSpatialContVecs[rule,indexRule[[1]]];
];
If[debugTiming,
Print["createNewSpatialContVecs : timingVar = ",timingVar];
];

arrNewSpatialVecs
,
{}
]
],preReleasegramtrans];

(*first initialize gPoolObjModified*)
prevPoolObjVarTypes = gPoolObjVarTypes;

timingVar = Timing[
(*
this was VERY VERY SLOW!!
MapIndexed[Function[{curObjMod,curObjInd},
If[curObjMod,
gPoolObjContEqs[[curObjInd[[1]]]] = Table[{0,methodSum},{Length[gPoolObjContEqs[[curObjInd[[1]]]]]}];
gPoolObjVarTypes[[curObjInd[[1]]]] = Table[typeVarConstant,{Length[gPoolObjContEqs[[curObjInd[[1]]]]]}];
]

],gPoolObjModified];
*)


gPoolObjContEqs = MapThread[Function[{curObjMod,curObjContEq},
If[curObjMod,
Table[{0,methodSum},{Length[curObjContEq]}]
,
curObjContEq
]

],{gPoolObjModified,gPoolObjContEqs}];

gPoolObjVarTypes = MapThread[Function[{curObjMod,curObjVarType,curObjContEq},
If[curObjMod,
Table[typeVarConstant,{Length[curObjContEq]}]
,
curObjVarType
]

],{gPoolObjModified,gPoolObjVarTypes,gPoolObjContEqs}];

];
If[debugTiming,
Print["createContEqs : 1 timingVar = ",timingVar];
];

timingVar = Timing[
MapThread[Function[{curRuleVecs,curRuleSpVecs,curContRuleSolving,curContRuleElmLoc,curContRuleInd},

setTypeVars[Join[curRuleVecs,curRuleSpVecs],curContRuleSolving,curContRuleElmLoc,curContRuleInd];

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]],arrNewSpVecsPerRule[[gPositionOfContRules]],gGrammarContRulesSolvingSec,gGrammarContElmLoc,gPositionOfContRules}];
];
If[debugTiming,
Print["createContEqs : 2 timingVar = ",timingVar];
];

timingVar = Timing[
(*HAVE to execute this function - DONT  skip it *)
steChangedObjectsAsModified[prevPoolObjVarTypes];

];
If[debugTiming,
Print["steChangedObjectsAsModified : timingVar = ",timingVar];
];

If[debug,Print["createContEqs glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]] = ",glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]]];];
If[debug,Print["createContEqs arrNewSpVecsPerRule[[gPositionOfContRules]] = ",arrNewSpVecsPerRule[[gPositionOfContRules]]];];

timingVar = Timing[
MapThread[Function[{curRuleVecs,curRuleSpVecs,curContRuleSolving,curContRuleElmLoc,curContRuleLHS,curContRuleInd},

addContVecsToEqs[Join[curRuleVecs,curRuleSpVecs],curContRuleSolving,curContRuleElmLoc,curContRuleLHS,curContRuleInd];

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]],arrNewSpVecsPerRule[[gPositionOfContRules]],gGrammarContRulesSolvingSec,gGrammarContElmLoc,gGrammarRulesLHS[[gPositionOfContRules]],gPositionOfContRules}];
];
If[debugTiming,
Print["after addContVecsToEqs : timingVar = ",timingVar];
];

sumContVecsToEqs[];

If[debug,Print["createContEqs exit"];]
];


SetAttributes[createContEqs,ReadProtected]


steChangedObjectsAsModified[prevPoolObjVarTypes_]:=Module[{planeObjIndexes},

posmod1 = Flatten[Position[gPoolObjModified,True]];

(*REMARK - this is in the future suppose to include all elements that are not changable by the grammar (constant objects) . So it should include of course the planes*)
planeObjIndexes = findPlaneObjects[];

MapThread[Function[{curObjVarTypes,prevObjVarTypes,curObjInd},
(*a variable type was Changed!! so we set it an all its neighbors as modified*)
If[curObjVarTypes!= prevObjVarTypes,
gPoolObjModified[[curObjInd]] = True;
gPoolObjContEqs[[curObjInd]] = Table[{0,methodSum},{Length[gPoolObjContEqs[[curObjInd]]]}];

(*find all its neighbors spatial and set them to modified too - only objects that can be changed*)
If[Length[gPositionOfSpatialRules]>0,
Map[Function[{curnbr},
If[!MemberQ[planeObjIndexes,curnbr],
gPoolObjModified[[curnbr]] = True;
gPoolObjContEqs[[curnbr]] = Table[{0,methodSum},{Length[gPoolObjContEqs[[curnbr]]]}];
];
],gPoolObjSpatialConnectArr[[curObjInd]]];
];

(*find all its neighbors non-spatial and set them to modified too - only objects that can be changed (so planes should not)*)

Map[Function[{curRuleVecs},
Map[Function[{curvec},
If[MemberQ[curvec,curObjInd],

Map[Function[{curnbr},
If[!MemberQ[planeObjIndexes,curnbr],
gPoolObjModified[[curnbr]] = True;
gPoolObjContEqs[[curnbr]] = Table[{0,methodSum},{Length[gPoolObjContEqs[[curnbr]]]}];
];
],curvec];

];
],curRuleVecs]

],glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]]];

];
],{gPoolObjVarTypes,prevPoolObjVarTypes,Range[1,Length[gPoolObjVarTypes]]}];

]


SetAttributes[steChangedObjectsAsModified,ReadProtected]


findPlaneObjects[]:=Module[{},

DeleteCases[MapIndexed[Function[{curObj,curObjInd},

If[MemberQ[gSpatialLeftBound,Head[curObj]]  || MemberQ[gSpatialRightBound,Head[curObj]] || MemberQ[gSpatialBottomBound,Head[curObj]]||MemberQ[gSpatialTopBound,Head[curObj]],
curObjInd[[1]]
,
0
]
],thePool],0]

]


SetAttributes[findPlaneObjects,ReadProtected]


setTypeVars[curRuleVecs_,curContRuleSolving_,curContRuleElmLoc_,curRuleInd_]:= Module[{},
(*seperate to 3 variabeles sets - {dervTimeVars, funcTimeVars, constantTimeVars} *)
If[debug,

Print["setTypeVars start {curRuleVecs,curContRuleSolving,curContRuleElmLoc,curRuleInd} = ",{curRuleVecs,curContRuleSolving,curContRuleElmLoc,curRuleInd}];

Print["setTypeVars before gPoolObjModified = ",gPoolObjModified];
Print["setTypeVars before gPoolObjVarTypes = ",gPoolObjVarTypes];
Print["setTypeVars before gPoolObjContEqs = ",gPoolObjContEqs];

];

MapThread[Function[{curVec,curVecIndex},

If[Apply[Or,gPoolObjModified[[curVec]]],

MapThread[Function[{curEqInSolvingSection,curEqRuleElemLoc,cureqindex},

curvartype = typeVarFuncTime;

If[curEqInSolvingSection[[1,1]]/. Derivative[i_][x_][t_] -> True,
curvartype = typeVarDervTime;
];

gPoolObjVarTypes[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] = curvartype;

],{curContRuleSolving,curContRuleElmLoc,Range[1,Length[curContRuleSolving]]}]
]

],{curRuleVecs,Range[1,Length[curRuleVecs]]}];

If[debug,Print["setTypeVars after gPoolObjVarTypes = ",gPoolObjVarTypes];];

]


SetAttributes[setTypeVars,ReadProtected]


sumContVecsToEqs[]:=Module[{},

If[methodSum === {},

timingVar = Timing[
gPoolObjContEqs = Map[Function[{curvec},
Map[Function[{curelem},
{curelem[[1]],If[Head[curelem[[2]]]=== List,Total[curelem[[2]]],curelem[[2]]]}
],curvec]
],gPoolObjContEqs];
];

];


];


SetAttributes[sumContVecsToEqs,ReadProtected]


(*MUST use methodSum = {} *)


methodSum = {};(*0*)


methodSum2 = 1;(*2 - has a bug , dont use*)


addContVecsToEqs[curRuleVecs_,curContRuleSolving_,curContRuleElmLoc_,curContRuleLHS_,curRuleInd_]:=Module[{currentObjCollectedEqs},

If[debug,Print["addContVecsToEqs start {curRuleVecs,curContRuleSolving,curContRuleElmLoc,curRuleInd} = ",{curRuleVecs,curContRuleSolving,curContRuleElmLoc,curRuleInd}];];
If[debug,Print["addContVecsToEqs before gPoolObjContEqs = ",gPoolObjContEqs];];
If[debug,Print["addContVecsToEqs before gPoolObjVarTypes = ",gPoolObjVarTypes];];

If[methodSum === {},

timingVar = Timing[
If[methodSum2 === 1,

Map[Function[{curVec},

If[Apply[Or,gPoolObjModified[[curVec]]],

MapThread[Function[{curEqInSolvingSection,curEqRuleElemLoc},

If[gPoolObjModified[[curVec[[curEqRuleElemLoc[[1,1]]]]]],

gPoolObjContEqs[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]],1]] = 
If[gPoolObjVarTypes[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] == typeVarFuncTime,
gPoolVariables[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]][gGrammarTimeVar]
,
 If[gPoolObjVarTypes[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] == typeVarDervTime,

\!\(\*SuperscriptBox[
RowBox[{"gPoolVariables", "[", 
RowBox[{"[", 
RowBox[{
RowBox[{"curVec", "[", 
RowBox[{"[", 
RowBox[{"curEqRuleElemLoc", "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}], "]"}], "]"}], ",", 
RowBox[{"curEqRuleElemLoc", "[", 
RowBox[{"[", 
RowBox[{"1", ",", "2"}], "]"}], "]"}]}], "]"}], "]"}], "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar],0]
];

gPoolObjContEqs[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]],2]] = Append[gPoolObjContEqs[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]],2]],  curEqInSolvingSection[[1,2]]/. MapThread[Function[{curelem,curtype,curvar,curVal},
If[curtype == typeVarConstant,curelem[gGrammarTimeVar]-> curVal,curelem-> curvar]
],{Extract[curContRuleLHS,curEqRuleElemLoc[[2]]],Extract[gPoolObjVarTypes[[curVec]],curEqRuleElemLoc[[2]]],
Extract[gPoolVariables[[curVec]],curEqRuleElemLoc[[2]]],Extract[thePool[[curVec]],curEqRuleElemLoc[[2]]]}]];
];
],{curContRuleSolving,curContRuleElmLoc}]
]

],curRuleVecs];

,

varinnerTiming = Timing[
arrCollectedEqs = Flatten[Map[Function[{curVec},

If[Apply[Or,gPoolObjModified[[curVec]]],

DeleteCases[MapThread[Function[{curEqInSolvingSection,curEqRuleElemLoc},

If[gPoolObjModified[[curVec[[curEqRuleElemLoc[[1,1]]]]]],

gPoolObjContEqs[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]],1]] = 
If[gPoolObjVarTypes[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] == typeVarFuncTime,
gPoolVariables[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]][gGrammarTimeVar]
,
 If[gPoolObjVarTypes[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] == typeVarDervTime,

\!\(\*SuperscriptBox[
RowBox[{"gPoolVariables", "[", 
RowBox[{"[", 
RowBox[{
RowBox[{"curVec", "[", 
RowBox[{"[", 
RowBox[{"curEqRuleElemLoc", "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}], "]"}], "]"}], ",", 
RowBox[{"curEqRuleElemLoc", "[", 
RowBox[{"[", 
RowBox[{"1", ",", "2"}], "]"}], "]"}]}], "]"}], "]"}], "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar],0]
];

{{curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]},curEqInSolvingSection[[1,2]]/. MapThread[Function[{curelem,curtype,curvar,curVal},
If[curtype == typeVarConstant,curelem[gGrammarTimeVar]-> curVal,curelem-> curvar]
],{Extract[curContRuleLHS,curEqRuleElemLoc[[2]]],Extract[gPoolObjVarTypes[[curVec]],curEqRuleElemLoc[[2]]],
Extract[gPoolVariables[[curVec]],curEqRuleElemLoc[[2]]],Extract[thePool[[curVec]],curEqRuleElemLoc[[2]]]}]}
,0
]
],{curContRuleSolving,curContRuleElmLoc}],0]
,
{}
]

],curRuleVecs],1];
];

If[debug,Print["addContVecsToEqs exit arrCollectedEqs = ",arrCollectedEqs];];
If[debug,Print["addContVecsToEqs exit gPoolObjModified = ",gPoolObjModified];];

varinnerTiming = Timing[
gPoolObjContEqs = MapThread[Function[{curobjEqs,curobjtypes,curobjMod,curobjid},
If[curobjMod,
currentObjCollectedEqs = arrCollectedEqs[[Flatten[Position[arrCollectedEqs[[All,1,1]],curobjid]]]];

MapThread[Function[{curObjParamEqs,curObjParamType,curparamInd},
If[curObjParamType  === typeVarFuncTime  || curObjParamType  === typeVarDervTime,

curParamCollectEqs = currentObjCollectedEqs[[Flatten[Position[currentObjCollectedEqs[[All,1,2]],curparamInd]]]][[All,2]];

If[curParamCollectEqs == {},
Print["ERROR: curParamCollectEqs = ",curParamCollectEqs];

];

{curObjParamEqs[[1]],curParamCollectEqs}
,
curObjParamEqs
]

],{curobjEqs,curobjtypes,Range[1,Length[curobjtypes]]}]

,
curobjEqs
]

],{gPoolObjContEqs,gPoolObjVarTypes,gPoolObjModified,Range[1,Length[gPoolObjModified]]}];
];
Print["varinnerTiming 1 = ",varinnerTiming];

If[debug,Print["123 gPoolObjContEqs = ",gPoolObjContEqs];];

];

];

If[debugTiming,Print["addContVecsToEqs: before total timingVar = ",timingVar];];

,
timingVar = Timing[
Map[Function[{curVec},

If[Apply[Or,gPoolObjModified[[curVec]]],

MapThread[Function[{curEqInSolvingSection,curEqRuleElemLoc},

If[gPoolObjModified[[curVec[[curEqRuleElemLoc[[1,1]]]]]],

gPoolObjContEqs[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]],1]] = 
If[gPoolObjVarTypes[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] == typeVarFuncTime,
gPoolVariables[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]][gGrammarTimeVar]
,
 If[gPoolObjVarTypes[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] == typeVarDervTime,

\!\(\*SuperscriptBox[
RowBox[{"gPoolVariables", "[", 
RowBox[{"[", 
RowBox[{
RowBox[{"curVec", "[", 
RowBox[{"[", 
RowBox[{"curEqRuleElemLoc", "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}], "]"}], "]"}], ",", 
RowBox[{"curEqRuleElemLoc", "[", 
RowBox[{"[", 
RowBox[{"1", ",", "2"}], "]"}], "]"}]}], "]"}], "]"}], "\[Prime]",
MultilineFunction->None]\)[gGrammarTimeVar],0]
];

gPoolObjContEqs[[curVec[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]],2]] +=  curEqInSolvingSection[[1,2]]/. MapThread[Function[{curelem,curtype,curvar,curVal},
If[curtype == typeVarConstant,curelem[gGrammarTimeVar]-> curVal,curelem-> curvar]
],{Extract[curContRuleLHS,curEqRuleElemLoc[[2]]],Extract[gPoolObjVarTypes[[curVec]],curEqRuleElemLoc[[2]]],
Extract[gPoolVariables[[curVec]],curEqRuleElemLoc[[2]]],Extract[thePool[[curVec]],curEqRuleElemLoc[[2]]]}];
];
],{curContRuleSolving,curContRuleElmLoc}]
]

],curRuleVecs];
];

Print["addContVecsToEqs: after += timingVar = ",timingVar];

];


If[debug,Print["addContVecsToEqs exit gPoolObjContEqs = ",gPoolObjContEqs];]

];


SetAttributes[addContVecsToEqs,ReadProtected]


createNewSpatialContVecs[ruleStruct_,indexRule_]:=Module[{nonSptialElemPos,arrNewSpatialVecs,curObjsPerElem,ruleLHSregElems},

If[debug,Print["createNewSpatialContVecs start : {ruleStruct,indexRule} = ",{ruleStruct,indexRule}];];

ruleLHSregElems  = Map[Function[{curterm},
If[Length[curterm]>0,
Map[If[Length[#]>1 && Head[#]=!= Pattern,ToExpression["_"],#]&,curterm]
,
curterm
]
],ruleStruct[[indexOfLHSElements,1]]];


arrNewSpatialVecs = {};

nonSptialElemPos = Complement[Range[1,Length[gGrammarRulesLHS[[indexRule]]]],gSpatialRulesElemPos[[indexRule]]];

MapThread[Function[{curObjMod,curObjConnct,curObjInd},
If[curObjMod,
If[Length[curObjConnct]>0,
Map[Function[{curNbr},


curObjsPerElem = Table[{},{Length[gGrammarRulesLHS[[indexRule]]]}];

If[debug,
Print["createNewSpatialContVecs : curObjsPerElem1  = ",curObjsPerElem];
];

curObjsPerElem[[gSpatialRulesElemPos[[indexRule]]]] = {{curObjInd},{curNbr}};

If[Length[nonSptialElemPos]>0,
curObjsPerElem[[nonSptialElemPos]] = glRuleMatchingPoolItemsLocations[[indexRule]][[nonSptialElemPos]]

];

If[debug,
Print["createNewSpatialContVecs : curObjsPerElem = ",curObjsPerElem];
];

Map[Function[{curObjsVec},

(* check if the rule is valid when all the elements are cosidered together *)
If[Apply[List,Part[thePool,curObjsVec]] /. ruleLHSregElems->True,
AppendTo[arrNewSpatialVecs,curObjsVec];
]

],Distribute[curObjsPerElem,List]]

],curObjConnct];
];


];

],{gPoolObjModified,gPoolObjSpatialConnectArr,Range[1,Length[gPoolObjModified]]}];

If[debug,Print["createNewSpatialContVecs exit : arrNewSpatialVecs = ",arrNewSpatialVecs];];

arrNewSpatialVecs

];



SetAttributes[createNewSpatialContVecs,ReadProtected]


createAccelRates[]:= Module[{newAccelArr,replceElemToVarRules,timingTemp1},

timingTemp1 = Timing[

newAccelArr  = MapThread[Function[{curRulePoolItemsarr,curAccelRulestrct,curAccelRuleElmLoc,curAccelRuleLHS},

Map[Function[{curRulePoolItems},

replceElemToVarRules = MapThread[Function[{curelem,curvar},
curelem-> curvar
],{Extract[curAccelRuleLHS,curAccelRuleElmLoc],
Extract[gPoolVariables[[curRulePoolItems]],curAccelRuleElmLoc]}];

{curAccelRulestrct[[1]]/. replceElemToVarRules
,
Map[Function[{curAccelRateDiff},
curAccelRateDiff/.replceElemToVarRules
],curAccelRulestrct[[2]]]
}

],curRulePoolItemsarr]

],{glNewMatchingPoolRuleVectorsOfRegElems[[gPositionOfAcceleratedRules]],gAcceleratedRulesStruct,gGrammarAccelElmLoc,gGrammarRulesLHS[[gPositionOfAcceleratedRules]]}];

If[Length[glAccelRatesArr]>0,
glAccelRatesArr[[gPosNonSpatialAccelRules]] = MapThread[Function[{curRuleNewAccel,curRuleAccel},Join[curRuleNewAccel,curRuleAccel] ],{newAccelArr[[gPosNonSpatialAccelRules]],glAccelRatesArr[[gPosNonSpatialAccelRules]]}];

glAccelRatesArr[[gPosSpatialAccelRules]] = newAccelArr[[gPosSpatialAccelRules]];
,
glAccelRatesArr = newAccelArr;
]
];

];


SetAttributes[createAccelRates,ReadProtected]


groundAccelRates[]:=Module[{},

If[Length[gPositionOfAcceleratedRules]>0,
groundedAccelRateArr = MapThread[Function[{curRulePoolItemsarr,curRuleAccelRates,curPosAccelRule,curAccelRuleElmLoc},

MapThread[Function[{curRulePoolItems,curRuleVecAccelRate},

{
curRuleVecAccelRate[[1]]/.Map[Function[{curEqVarLoc},
gPoolVariables[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]-> thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]
],curAccelRuleElmLoc]
,
Map[Function[{curDerivRate},
curDerivRate/.Map[Function[{curEqVarLoc},
gPoolVariables[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]-> thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]
],curAccelRuleElmLoc]
],curRuleVecAccelRate[[2]]]
}

],{curRulePoolItemsarr,curRuleAccelRates}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfAcceleratedRules]],glAccelRatesArr,gPositionOfAcceleratedRules,gGrammarAccelElmLoc}];

groundedAccelRateArr
,
{}]
];


SetAttributes[groundAccelRates,ReadProtected]


calcNextTau[groundedAccelRateArr_,diffVarsEqsArr_,algVarsEqsArr_,typeVarsArr_,curTotalDiscRate_]:=Module[{varsTimeDerivativeArr,rateTimeDerivativeArr,curTau},

If[Length[gPositionOfAcceleratedRules]>0,
(* create varsTimeDerivativeArr  - first only the time derivatives from the continuos rules  *)
varsTimeDerivativeArr = groundDervEq[diffVarsEqsArr,algVarsEqsArr,typeVarsArr,True];

If[debug,Print["calcNextTau: varsTimeDerivativeArr = ",varsTimeDerivativeArr];];

(*extract from varsTimeDerivativeArr only the relevant derivatives and also check that there are no algebraic equations for accelrated variabels*)
MapThread[Function[{curRulePoolItemsarr,curRuleAccelRates,curAccelRuleElmLoc},

MapThread[Function[{curRulePoolItems,curRuleVecAccelRate},

MapThread[Function[{curEqVarLoc,curEqVarStrct},

(*if there were continuous rules for this variable - check that its a DE rule and not algebraic, and then set it*)
If[Length[varsTimeDerivativeArr[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]]>0,
If[(varsTimeDerivativeArr[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]][[1]] /.Derivative[1][vv_] [tt_]-> True ) === True,
varsTimeDerivativeArr[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]= varsTimeDerivativeArr[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]][[2]];
(*,
Print["!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Error - Wrong input!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"];
Print["Error - Wrong input: An accelerated variable has an algebraic equation!"];
*)
];
];

],{curAccelRuleElmLoc,curRuleVecAccelRate[[2]]}]

],{curRulePoolItemsarr,curRuleAccelRates}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfAcceleratedRules]],groundedAccelRateArr,gGrammarAccelElmLoc}];
If[debug,Print["calcNextTau: varsTimeDerivativeArr 2 = ",varsTimeDerivativeArr];];

(*add the time derivatives for algebraic delayed rules*)
MapThread[Function[{curRulePoolItemsarr,curRuleContEqs,curPosContRule,curContRuleElmLoc},

bCurRuleIsDelayed = MemberQ[gPositionOfDelayedContRules,curPosContRule];

If[bCurRuleIsDelayed,
MapThread[Function[{curRulePoolItems,curRuleVecContEqs},

MapThread[Function[{curcontEq,curEqRuleElemLoc},

varsTimeDerivativeArr[[curRulePoolItems[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]] = 
(*calc the time derivatives at time 0*)
((curcontEq[[2]]/.Flatten[Map[Function[{curEqVarLoc},

gPoolVariables[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]][gGrammarTimeVar]-> thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]

],curEqRuleElemLoc[[2]]]])/.{gPoolVariables[[curRulePoolItems[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]][N[0]]-> thePool[[curRulePoolItems[[curEqRuleElemLoc[[1,1]]]],curEqRuleElemLoc[[1,2]]]]})/. gGrammarTimeVar-> 0;

],{curRuleVecContEqs,curContRuleElmLoc}]

],{curRulePoolItemsarr,curRuleContEqs}],
{}
]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfContRules]],glContEqArr,gPositionOfContRules,gGrammarContElmLoc}];

If[debug,Print["calcNextTau: varsTimeDerivativeArr 3 = ",varsTimeDerivativeArr];];


(*add to varsTimeDerivativeArr  the time derivative from the accelerated rules -  which is the rate multiplied by the Stoichemetry number*)
MapThread[Function[{curRulePoolItemsarr,curRuleAccelRates,curAccelRuleElmLoc},

MapThread[Function[{curRulePoolItems,curRuleVecAccelRate},

MapThread[Function[{curEqVarLoc,curEqVarStrct},

varsTimeDerivativeArr[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]+= curEqVarStrct[[1]]*curRuleVecAccelRate[[1]];

],{curAccelRuleElmLoc,curRuleVecAccelRate[[2]]}]

],{curRulePoolItemsarr,curRuleAccelRates}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfAcceleratedRules]],groundedAccelRateArr,gGrammarAccelElmLoc}] ;

If[debug,Print["calcNextTau: varsTimeDerivativeArr 4 = ",varsTimeDerivativeArr];];

(*
create rateTimeDerivativeArr
now go over groundedAccelRateArr and multiply each var derivative by the vars total time derivative from -  varsTimeDerivativeArr
then Sum the whole terms for that rate time derivative 
*)
rateTimeDerivativeArr = MapThread[Function[{curRulePoolItemsarr,curRuleAccelRates,curAccelRuleElmLoc},

MapThread[Function[{curRulePoolItems,curRuleVecAccelRate},

Total[MapThread[Function[{curEqVarLoc,curEqVarStrct},

varsTimeDerivativeArr[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]*curEqVarStrct[[2]]

],{curAccelRuleElmLoc,curRuleVecAccelRate[[2]]}]]

],{curRulePoolItemsarr,curRuleAccelRates}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfAcceleratedRules]],groundedAccelRateArr,gGrammarAccelElmLoc}];

If[debug,Print["calcNextTau: rateTimeDerivativeArr = ",rateTimeDerivativeArr];];

(*calc Tau by using rateTimeDerivativeArr and the Total rate*)
curTau = Min[Flatten[Map[Function[{curRuleRateTimeDerivArr},
Map[Function[{curItemVecRateTimeDeriv},

If[curItemVecRateTimeDeriv!=  0,Abs[(gTauLeapEpsilon*curTotalDiscRate)/curItemVecRateTimeDeriv],\[Infinity]]

],curRuleRateTimeDerivArr]
],rateTimeDerivativeArr]]];

curTau
,
\[Infinity]
]
];



SetAttributes[calcNextTau,ReadProtected]


updateAccelratedRules[curIntegratedTime_]:=Module[{curPoissonRate,rndNumevents},

(*go over each accelerated reaction (groundedAccelRateArr) and sample from the Poisson distribution rate*curIntegratedTime  . The random number of reaction is multiplied by the change of each paramter (soichemetry number) . This change is added to the affected variable in thePool*)

MapThread[Function[{curRulePoolItemsarr,curRuleAccelRates,curAccelRuleElmLoc},

MapThread[Function[{curRulePoolItems,curRuleVecAccelRate},

curPoissonRate = curRuleVecAccelRate[[1]]*curIntegratedTime;

If[curPoissonRate>0,
rndNumevents = RandomInteger[PoissonDistribution[curPoissonRate]];
(*can be aproximated by  -
Random[NormalDistribution[curPoissonRate,curPoissonRate]];
when curPoissonRate>>0
this is much faster
*)

MapThread[Function[{curEqVarLoc,curEqVarStrct},

thePool[[curRulePoolItems[[curEqVarLoc[[1]]]],curEqVarLoc[[2]]]]+= curEqVarStrct[[1]]*rndNumevents;

],{curAccelRuleElmLoc,curRuleVecAccelRate[[2]]}]
,
If[curPoissonRate<0,
Print["updateAccelratedRules: ERROR curPoissonRate<0   , curPoissonRate = ",curPoissonRate];
];
];

],{curRulePoolItemsarr,curRuleAccelRates}]

],{glmatchingPoolRuleVectorsOfRegElems[[gPositionOfAcceleratedRules]],groundedAccelRateArr,gGrammarAccelElmLoc}];

];


SetAttributes[updateAccelratedRules,ReadProtected]


maxNumIterSolveNonPoly = 100;


(*the input equations must be of the form : LHS is a variable and RHS is an expression. eg. var1 == 90var2+var3^2*)


solveEqWithNonPolynomials[inEqs_]:=Module[{curEqs,bSolvedEqs,posPolyEq,posNonPolyEq,totSolArr,sol1},

curEqs = inEqs;
bSolvedEqs = False;

totSolArr = {};

For[numIter = 1, numIter<= maxNumIterSolveNonPoly && !bSolvedEqs, numIter++,

posPolyEq = Flatten[Position[Map[Function[{cureq},PolynomialQ[cureq[[2]]]],curEqs],True]];

If[Length[posPolyEq] == 0,
(*if all equations are not polynomials then we can not solve it here!*)
Print["solveEqWithNonPolynomials: Fails to solve the equations , curEqs =  ",curEqs];
Print["inEqs = ",inEqs];
Return[False];
];

sol1 = Solve[curEqs[[posPolyEq]],curEqs[[posPolyEq]][[All,1]]];

If[Length[sol1]<=0,
(*stop this calculation and return false*)
Return[False];
];

sol1 = First[sol1];

totSolArr = Join[totSolArr,sol1];

posNonPolyEq = Flatten[Position[Map[Function[{cureq},PolynomialQ[cureq[[2]]]],curEqs],False]];

If[Length[posNonPolyEq] >0,
curEqs = curEqs[[posNonPolyEq]]/. sol1;
,
bSolvedEqs = True;
];


];

totSolArr

]


SetAttributes[solveEqWithNonPolynomials,ReadProtected]


(* these two functions are similiar*)
HandleDeleteInRuleMatchingPoolItemsLocs[ruleMatchingPoolItemsLocationsStruct_,sortArrDeletedPoolItemsIndexes_]:=Module[{},

iNumDeletedItems = Length[sortArrDeletedPoolItemsIndexes];
iMinDelItem = sortArrDeletedPoolItemsIndexes[[1]];
iMaxDelItem = sortArrDeletedPoolItemsIndexes[[iNumDeletedItems]];

iCurShift = 0;
iStartArrIndex = 1;
shiftArray  = Flatten[{Map[Function[{delItem},

curShiftTbl =Table[iCurShift,{i,iStartArrIndex,delItem}];
iStartArrIndex = delItem+1;
iCurShift++;

curShiftTbl
],sortArrDeletedPoolItemsIndexes],

If[iMaxDelItem < Length[thePool],
Table[iNumDeletedItems,{i,iMaxDelItem+1,Length[thePool]}]
,
{}
]}
];

Map[Function[{curRuleMatchingPoolItemsLocations},
Map[Function[{curRElemMatchPoolItemLocs},
Map[Function[{curRElemMatchPoolItem},

tempItemIndex = curRElemMatchPoolItem[[1]];

{tempItemIndex - shiftArray[[tempItemIndex]], curRElemMatchPoolItem[[2]]}

],curRElemMatchPoolItemLocs]
],curRuleMatchingPoolItemsLocations]
],ruleMatchingPoolItemsLocationsStruct]

];



SetAttributes[HandleDeleteInRuleMatchingPoolItemsLocs,ReadProtected]


HandleDeleteInMatchRuleVectorsStruct[matchingRuleVectorsStruct_,sortArrDeletedPoolItemsIndexes_]:=Module[{},

iNumDeletedItems = Length[sortArrDeletedPoolItemsIndexes];
iMinDelItem = sortArrDeletedPoolItemsIndexes[[1]];
iMaxDelItem = sortArrDeletedPoolItemsIndexes[[iNumDeletedItems]];

iCurShift = 0;
iStartArrIndex = 1;
shiftArray  = Flatten[{Map[Function[{delItem},

curShiftTbl =Table[iCurShift,{i,iStartArrIndex,delItem}];
iStartArrIndex = delItem+1;
iCurShift++;

curShiftTbl
],sortArrDeletedPoolItemsIndexes],

If[iMaxDelItem < Length[thePool],
Table[iNumDeletedItems,{i,iMaxDelItem+1,Length[thePool]}]
,
{}
]}
];

Map[Function[{curMatchingPoolRuleVectors},
Map[Function[{curMatchingPoolRuleVector},
Map[Function[{curMatchingPoolRuleVectorItem},

tempItemIndex = curMatchingPoolRuleVectorItem[[1]];

{tempItemIndex - shiftArray[[tempItemIndex]], curMatchingPoolRuleVectorItem[[2]]}

],curMatchingPoolRuleVector]
],curMatchingPoolRuleVectors]
],matchingRuleVectorsStruct]
];


SetAttributes[HandleDeleteInMatchRuleVectorsStruct,ReadProtected]


HandleInactiveElementsPool[totalElementsPool_,activeElementsPool_,gramtrans_,newelements_] := Module[{poolPositionsForNewElements,activeNewElements,inactiveNewElements,totalElementsPool1,activeElementsPool1},

poolPositionsForNewElements = Flatten[Map[Function[{gramElem},

Map[Position[newelements,#]&,Flatten[{gramElem[[indexOfLHSElements,1]],If[Length[gramElem[[indexOfLHSElements,2]]]>0,gramElem[[indexOfLHSElements,2,All,2]],{}]}]]

],gramtrans]];

poolPositionsForNewElements = Union[poolPositionsForNewElements];

activeNewElements = Part[newelements,poolPositionsForNewElements];
inactiveNewElements =Complement[newelements,activeNewElements];

 (* add the active element/s to active pool *)
activeElementsPool1= Flatten[{activeElementsPool,activeNewElements}];

(* add the inactive element/s to inactive pool *)
totalElementsPool1= Flatten[{totalElementsPool,inactiveNewElements}];

{totalElementsPool1,activeElementsPool1}
]


SetAttributes[HandleInactiveElementsPool,ReadProtected]


grammarDiscreteDistributionFunc[probTbl_,probVars_]:=Module[{},

(* IMPORTANT - this code supports only one unknown variable*) 

curprobVars= If[ArrayQ[probVars],
probVars,
{probVars}];

{curprobTblValuesPerVars,curprobTbl} = Symbol[probTbl];

dimOfcurprobTbl = Dimensions[curprobTbl];

(*dimOfcurprobTbl should be the same size as curprobVars*)

MapThread[Function[{curpVar,curdimInTbl,curprobtblValsperVar},

If[NumberQ[curpVar],

posOfCurVarInTable = Position[curprobtblValsperVar,Round[curpVar]];

If[Length[posOfCurVarInTable]>0,
posOfCurVarInTable = posOfCurVarInTable[[1,1]];
,
(* is there is no such value then we pick the first value, THIS IS WRONG , but it should not affect the with part since we use this only in the subjectto section , currently*)
posOfCurVarInTable = 1;
];
curprobTbl = curprobTbl[[posOfCurVarInTable]];

,
curVarvectorValues = Round[curpVar/. Variables[curpVar][[1]]-> curprobtblValsperVar];

curprobTbl = Map[Function[{curVarVal},

curposVal = Position[curprobtblValsperVar,curVarVal];
If[Length[curposVal]>0,
curprobTbl[[curposVal[[1,1]]]]
,
curprobTbl[[1]]*0(*just return a zeroed vector*)
]

],curVarvectorValues];

(*global variable for refering to the values of the active variable*)
glProbTblValuesOfUnknownVar = curprobtblValsperVar;


]],{curprobVars,dimOfcurprobTbl,curprobTblValuesPerVars}];

curprobTbl
]


SetAttributes[grammarDiscreteDistributionFunc,ReadProtected]



probtrans[{lhs_->rhs_,prob_,constraints_,gram_,elimvbls_,whereElimvbls_,lhsSeperatedToPart_,lhsAppliedPart_,lhsVars_ ,
rhsVars_,rateFuncStruc_,isComplexParamsExp_,replaceAllSec1_}]:=Module[{},

Clear[tempfun];

(* Remark - this used to be tempfun[lhs]... but since adding the quantifiers we only need to compute the probability using the regular elements*)

(*remark - important  - dont use any gloabl or local variables inside probtrans , only use the parameters of probtrns !!!! it justv doesn't work with this dynamic function*)

gtempfun = Unique[tempfun];

gtempfun[If[isComplexParamsExp==0, lhsSeperatedToPart[[1]],Map[ToExpression[StringJoin[ToString[#],"_"]] &,lhsVars]]]:=Module[{cs,rlArrGrammarPDF,inputParamsRateFunc,arrGrammarPDF,condProbCDFArr,arrDistValsRulesArr,randomNumber,rateFuncValueArr},

cs = {};
rlconstraints = ReleaseHold[ constraints];
{inputParamsRateFunc,{arrGrammarPDF,condProbCDFArr}} = rateFuncStruc;

If[rlconstraints=!=Null,

curconstraints = rlconstraints;
(* now handle discrete distribution*)
If[MemberQ[curconstraints,grammarDiscreteDistribution[__],Infinity],

curconstraints = Map[Function[{curconst},

tempcurconst = curconst /. grammarDiscreteDistribution[probTbl_,probVars_]:> grammarDiscreteDistributionFunc[probTbl,probVars];

(* note that tempcurconst should be of this form
var == {probval1,probval2...}
or just 
	var== val
*)

(* only if the values part is an array then we need to choose randomly between all the members*)
If[ArrayQ[tempcurconst[[2]]],
tempProbValsVec = tempcurconst[[2]];

sumProbs = Apply[Plus,tempProbValsVec];
(*If[sumProbs!= 1,
Print["tempProbValsVec is not normalized!!!!"]; 
];*)
randomNumber = RandomReal[{0,sumProbs}];

tempProbVal = 0;
posOfRndChosenEntry = 0;
MapIndexed[Function[{curProb,indexCurProb},
tempProbVal+=curProb;

If[posOfRndChosenEntry == 0 && tempProbVal>= randomNumber,
posOfRndChosenEntry = indexCurProb[[1]];
];

],tempProbValsVec];

tempcurconst = tempcurconst[[1]]==glProbTblValuesOfUnknownVar[[posOfRndChosenEntry]];
];

tempcurconst
],curconstraints];

];

cs=Solve[curconstraints,elimvbls];
];

rateFuncValueArr = inputParamsRateFunc /. cs;

(* in most cases there is only one solution to Solve , so we take the first position in the list. If there are multiple solutions we randomly pick accoding to their weight*)

(*if there is only one solution*)
If[Head[rateFuncValueArr]===List && Length[rateFuncValueArr]==1 ,rateFuncValueArr = rateFuncValueArr[[1]] ;cs = cs[[1]];];

(* if there are multiple solutions then randomly pick according to their weight *)
If[Head[rateFuncValueArr]===List,

sumProbs = Apply[Plus,rateFuncValueArr];

(* make a random choice of rule firing *)
randomNumber = RandomReal[{0,sumProbs}];

tempProbVal = 0;
posOfRndChosenEntry = 0;
MapIndexed[Function[{curProb,indexCurProb},
tempProbVal+=curProb;

If[posOfRndChosenEntry == 0 && tempProbVal>= randomNumber,
posOfRndChosenEntry = indexCurProb[[1]];
];

],rateFuncValueArr];

rateFuncValueArr = rateFuncValueArr[[posOfRndChosenEntry]];
cs = cs[[posOfRndChosenEntry]];

];

If[Length[arrGrammarPDF ]>0,

arrGrammarPDF = arrGrammarPDF/. cs;

rlArrGrammarPDF = ReleaseHold[arrGrammarPDF];

cs = Flatten[{cs,rlArrGrammarPDF}];
,

If[Length[condProbCDFArr]>0,

(*Print["condProbCDFArr = ",condProbCDFArr];
Print["cs = ",cs];
*)

condProbCDFArr = condProbCDFArr/. cs;

arrDistValsRulesArr = sampleFromMultiVariateDist[condProbCDFArr];

cs = Flatten[{cs,arrDistValsRulesArr}];

];
];

N[{inputParamsRateFunc /. cs , cs,replaceAllSec1/.cs}]];

gtempfun]


SetAttributes[probtrans,ReadProtected]


createRateFuncStruct[]:=Module[{},
gRateFuncsStruct = Map[Function[{curRl},
probtrans[ curRl ]
],preReleasegramtrans];

];


SetAttributes[createRateFuncStruct,ReadProtected]


grammarNumberOfDynamicObjID = 0;


HandleDynamicVariable[ElementInList_] := Module[{tempListVars,UpdateElementInList,maxNumberNewVars}, 

tempListVars = Cases[ElementInList,grammarCreateObjectID[x_],Infinity];

tempListVars = tempListVars /. grammarCreateObjectID[x_]-> x;

maxNumberNewVars=0;
If[Length[tempListVars] =!= 0,
maxNumberNewVars = Max[tempListVars]];

UpdateElementInList = ElementInList /.grammarCreateObjectID[iTemp_]->(iTemp+grammarNumberOfDynamicObjID);(*grammarDynamicObjID[iTemp+grammarNumberOfDynamicObjID];*)

grammarNumberOfDynamicObjID+=maxNumberNewVars;

UpdateElementInList
];


SetAttributes[HandleDynamicVariable,ReadProtected]


HandleDynamicVarInLHSOfRule[rule_] := Module[{tempListVars,tempListValues,ruleslst1,ruleslst2}, 

cutempRule = rule;

tempListVars = Cases[cutempRule[[indexOfAppliedPartOfLHS]],grammarCreateObjectID[x_],Infinity];

tempListValues= tempListVars /. grammarCreateObjectID[x_]-> x;

If[Length[tempListVars] =!= 0,

ruleslst1 = MapThread[Function[{curVar,curValue},
curVar-> ToExpression["dynamicObj"<>ToString[curValue]<>"_"]

],{tempListVars,tempListValues}];
ruleslst2 = MapThread[Function[{curVar,curValue},
curVar-> ToExpression["dynamicObj"<>ToString[curValue]]

],{tempListVars,tempListValues}];


cutempRule[[1,1]] = cutempRule[[1,1]]/.ruleslst1;
cutempRule[[1,2]] = cutempRule[[1,2]]/.ruleslst2;
cutempRule[[indexOfLHSElements]] = cutempRule[[indexOfLHSElements]]/.ruleslst1;
cutempRule[[indexOfAppliedPartOfLHS]] = cutempRule[[indexOfAppliedPartOfLHS]]/.ruleslst1;

cutempRule
,
cutempRule
]

]


SetAttributes[HandleDynamicVarInLHSOfRule,ReadProtected]


findTimeOfNextRuleExec[curRateFunc_,probVal_]:= Module[{curProbFunc,derivRange,bFound,ndsolution,bracketRange,index,retVal},

(*in this case we have a function of rho that depends on time \[Tau]:
 the diff equation :
 d (1-p)/dt=-rho(t)(1-p)
solve it numerically and find the time t that 
	1-p (t) = randomNumberTime
*)


(* We iterate between two steps: 
a. integrate the ODE (or SDE) for each continuous rule up to time ti, replace the variables in each term of the rate function (which is on Hold) with the a new function of the variable given t
 
b. sum all the rate functions together , and integrate up to time ti. the result is the probability function given time t -  Rp (t). if the Rp (ti)< r (the random number between 0 and 1) then inverse the function in order to find 
t == Pr_-1(r) and finish,
   
  c. ti = ti*2, return to a.  
*)

maxNumIterFindTime = 30;

derivRange = {0,5};
bFound =False;
For[index = 1, index<= maxNumIterFindTime && !bFound,index++,

ndsolution=NDSolve[{
\!\(\*SuperscriptBox["curProbFunc", "\[Prime]",
MultilineFunction->None]\)[\[Tau]]==-curRateFunc*curProbFunc[\[Tau]],curProbFunc[0]==1},curProbFunc,{\[Tau],derivRange[[1]],derivRange[[2]]}];

If[(curProbFunc/.First[ndsolution])[derivRange[[2]]] <=  probVal,
bFound = True;
,
derivRange[[2]] *=2;
];
];


If[!bFound,
Print["findTimeOfNextRuleExec: did not find derivRange after maxNumIterFindTime = ",maxNumIterFindTime];
Print["findTimeOfNextRuleExec: curRateFunc = ",curRateFunc];
Print["findTimeOfNextRuleExec: probVal = ",probVal];

Return[\[Infinity]];
];

(*Print["derivRange final = ",derivRange];*)

curStartVal = N[Apply[Plus,derivRange]/2];
bracketRange = derivRange;

bFound =False;
For[index = 1, index<= maxNumIterFindTime && !bFound,index++,

retVal = Check[FindRoot[(curProbFunc/.First[ndsolution])[\[Tau]]==probVal,{\[Tau],curStartVal,bracketRange[[1]],bracketRange[[2]]}],err];
If[retVal === err,

If[(curProbFunc/.First[ndsolution])[curStartVal]>probVal,
bracketRange[[1]] = curStartVal;
,
bracketRange[[2]] = curStartVal;
];

curStartVal = N[Apply[Plus,bracketRange]/2];

,
bFound = True;
];

];

If[!bFound,
Print["findTimeOfNextRuleExec: ERROR - did not FindRoot after maxNumIterFindTime = ",maxNumIterFindTime];
Print["findTimeOfNextRuleExec: curRateFunc = ",curRateFunc];
Print["findTimeOfNextRuleExec: probVal = ",probVal];

Return[False];
];

retVal
]


SetAttributes[findTimeOfNextRuleExec,ReadProtected]


idefineNoNeedForAll = -1;(* must be a negative number , so it will be different from the array indexes that apear in the struct*)


(* second version of execute - the grammar can be context-sensitive , i.e mutliple symbols in the left hand side of the rule, the multiple symbols are in a list *)


findTimeOfNextRuleExec[curRateFunc_,probVal_]:= Module[{curProbFunc,derivRange,bFound,ndsolution,bracketRange,index,retVal},

(*in this case we have a function of rho that depends on time \[Tau]:
 the diff equation :
 d (1-p)/dt=-rho(t)(1-p)
solve it numerically and find the time t that 
	1-p (t) = randomNumberTime
*)

maxNumIterFindTime = 30;

derivRange = {0,5};
bFound =False;
For[index = 1, index<= maxNumIterFindTime && !bFound,index++,

ndsolution=NDSolve[{
\!\(\*SuperscriptBox["curProbFunc", "\[Prime]",
MultilineFunction->None]\)[\[Tau]]==-curRateFunc*curProbFunc[\[Tau]],curProbFunc[0]==1},curProbFunc,{\[Tau],derivRange[[1]],derivRange[[2]]}];

If[(curProbFunc/.First[ndsolution])[derivRange[[2]]] <=  probVal,
bFound = True;
,
derivRange[[2]] *=2;
];
];


If[!bFound,
Print["findTimeOfNextRuleExec: did not find derivRange after maxNumIterFindTime = ",maxNumIterFindTime];
Print["findTimeOfNextRuleExec: curRateFunc = ",curRateFunc];
Print["findTimeOfNextRuleExec: probVal = ",probVal];

Return[\[Infinity]];
];

(*Print["derivRange final = ",derivRange];*)

curStartVal = N[Apply[Plus,derivRange]/2];
bracketRange = derivRange;

bFound =False;
For[index = 1, index<= maxNumIterFindTime && !bFound,index++,

retVal = Check[FindRoot[(curProbFunc/.First[ndsolution])[\[Tau]]==probVal,{\[Tau],curStartVal,bracketRange[[1]],bracketRange[[2]]}],err];
If[retVal === err,

If[(curProbFunc/.First[ndsolution])[curStartVal]>probVal,
bracketRange[[1]] = curStartVal;
,
bracketRange[[2]] = curStartVal;
];

curStartVal = N[Apply[Plus,bracketRange]/2];

,
bFound = True;
];

];

If[!bFound,
Print["findTimeOfNextRuleExec: ERROR - did not FindRoot after maxNumIterFindTime = ",maxNumIterFindTime];
Print["findTimeOfNextRuleExec: curRateFunc = ",curRateFunc];
Print["findTimeOfNextRuleExec: probVal = ",probVal];

Return[False];
];

retVal
];



handleRHSRulesRecurs[curLHSItemsIndexes_,curruleLHS_,curruleRHS_]:=Module[{curConcreteElemsInRHS,curNewItems,curSubRule,curLHSItems,cursubVector,curMatchingVecIndexes,curNewItemsFromSub,cursubVectorIndexesArr,retHandleRulesRecurs,tempRuleLHS},

(*Print["handleRHSRulesRecurs: curLHSItemsIndexes = ",curLHSItemsIndexes];
Print["handleRHSRulesRecurs: curruleLHS = ",curruleLHS];
Print["handleRHSRulesRecurs: curruleRHS = ",curruleRHS];
*)

curLHSItems = gCurTempPool[[curLHSItemsIndexes]];

(*Print["handleRHSRulesRecurs: curLHSItems = ",curLHSItems];*)

(*first find all the elements that are in the RHS*)
curConcreteElemsInRHS = DeleteCases[Map[Function[{curElemRHS},
If[Head[curElemRHS] === Rule,
0
,
curElemRHS
]
],curruleRHS],0];

(*Print["handleRHSRulesRecurs: curConcreteElemsInRHS = ",curConcreteElemsInRHS];*)

tempRuleLHS = curruleLHS;

curNewItems = curLHSItems/. tempRuleLHS -> curConcreteElemsInRHS;

gCurTempPool = Join[gCurTempPool,curNewItems];
gHRRPoolStatusArr = Join[gHRRPoolStatusArr,Table[1,{Length[curNewItems]}]];

Map[Function[{curElemRHS},
If[Head[curElemRHS] === Rule,

curSubRule = curElemRHS;

(*Print["handleRHSRulesRecurs: curSubRule = ",curSubRule];*)

cursubVectorIndexesArr = {curLHSItemsIndexes};

(*Print["handleRHSRulesRecurs: cursubVectorIndexesArr = ",cursubVectorIndexesArr];*)

MapIndexed[Function[{cursubruleLhsElem,cursubruleLhsElemInd},

cursubVectorIndexesArr = Flatten[DeleteCases[Map[Function[{cursubVectorInd},

cursubVector = gCurTempPool[[cursubVectorInd]];

(*Print["handleRHSRulesRecurs: cursubVectorInd = ",cursubVectorInd];
Print["handleRHSRulesRecurs: cursubVector = ",cursubVector];
*)

curMatchingVecIndexes = DeleteCases[MapIndexed[Function[{curPoolItem,curPoolIndex},
If[(curPoolItem/. cursubruleLhsElem-> True) &&  gHRRPoolStatusArr[[curPoolIndex[[1]]]] == 1 &&  !MemberQ[cursubVectorInd,curPoolIndex[[1]]],
If[Flatten[{cursubVector,curPoolItem}]/. Flatten[{tempRuleLHS,curSubRule[[1,Range[1,cursubruleLhsElemInd[[1]]]]]}]-> True,Flatten[{cursubVectorInd,curPoolIndex[[1]]}],0,0],0,0]
],gCurTempPool],0];


If[Length[curMatchingVecIndexes] > 0,
curMatchingVecIndexes
,
0
]

],cursubVectorIndexesArr],0],1];

],curSubRule[[1]] (*go over the LHS elements*)];

(*Print["handleRHSRulesRecurs: after cursubVectorIndexesArr = ",cursubVectorIndexesArr];*)

Map[Function[{curVecIndexes},

(*check that these items were not used already*)
If[!MemberQ[gHRRPoolStatusArr[[curVecIndexes]],0] ,

handleRHSRulesRecurs[curVecIndexes,Flatten[{tempRuleLHS,curSubRule[[1]]}],curSubRule[[2]]];

(*mark as used all the items that were found here*)
gHRRPoolStatusArr[[curVecIndexes[[Range[Length[curLHSItemsIndexes]+1,Length[curVecIndexes]]]]]] = 0;
]

],cursubVectorIndexesArr];
]
],curruleRHS];


]


SetAttributes[handleRHSRulesRecurs,ReadProtected]


gHRRMaxNumIterations = 100;


handleRHSRules[posElementsInLHS_,curruleLHS_,curRHSRules_]:=Module[{curNewItems,curTotNewItems,validNewItems},

gCurTempPool = thePool;

gHRRPoolStatusArr = Table[1,{Length[gCurTempPool]}];

handleRHSRulesRecurs[posElementsInLHS,curruleLHS,curRHSRules];

curTotNewItems = gCurTempPool[[Range[Length[thePool]+1,Length[gCurTempPool]]]];

(*return only the new items that were not removed *)
validNewItems =  Delete[curTotNewItems,Position[gHRRPoolStatusArr[[Range[Length[thePool]+1,Length[gHRRPoolStatusArr]]]],0]];

(*return the position of deleted items for only items that were already in thePool*)
{Flatten[Position[gHRRPoolStatusArr[[Range[1,Length[thePool]]]],0]],validNewItems}
]


SetAttributes[handleRHSRules,ReadProtected]


preProcessSpatial[gr_Grammar]:=Module[{curSpatialGram,temppos,tempposL,tempposR,tempposB,tempposT},

curSpatialGram = spatialGrammar/. Apply[List,gr];
gSpatialRulesElemPos = {};

gPositionOfSpatialRules = {};

gPosSpatialContRules = {};
gPosSpatialDiscRules = {};
gPosSpatialDelayedRules = {};
gPosSpatialAccelRules = {};
gPosSpatialDiffRules = {};

gPositionOfNonSpatialRules = Range[1,Length[gGrammarRulesLHS]];

gPosNonSpatialContRules = {};
gPosNonSpatialDiscRules = {};
gPosNonSpatialDelayedRules = {};
gPosNonSpatialAccelRules = {};
gPosNonSpatialDiffRules = {};

If[Length[curSpatialGram]>0,
gSpatialObject = spatialObject/.curSpatialGram;
gSpatialObjCoordParams = spatialObjCoordParamters/.curSpatialGram;
gSpatialObjRadParam = spatialObjRadParam/.curSpatialGram;
gSpObjConnectionDistance = spatialObjDistance/. curSpatialGram;
gSpPlaneConnectionDistance = spatialBoundaryDistance /. curSpatialGram;

Print["gSpatialObjCoordParams = ",gSpatialObjCoordParams];

gbIsSpatialLeftBound = gbIsSpatialRightBound = gbIsSpatialBottomBound = gbIsSpatialTopBound = False;

If[Length[Cases[curSpatialGram[[All,1]],spatialLeftBoundary]]>0,
gbIsSpatialLeftBound = True;
gSpatialLeftBound= spatialLeftBoundary/.curSpatialGram;
];
If[Length[Cases[curSpatialGram[[All,1]],spatialRightBoundary]]>0,
gbIsSpatialRightBound = True;
gSpatialRightBound= spatialRightBoundary/.curSpatialGram;
];
If[Length[Cases[curSpatialGram[[All,1]],spatialBottomBoundary]]>0,
gbIsSpatialBottomBound = True;
gSpatialBottomBound= spatialBottomBoundary/.curSpatialGram;
];
If[Length[Cases[curSpatialGram[[All,1]],spatialTopBoundary]]>0,
gbIsSpatialTopBound = True;
gSpatialTopBound= spatialTopBoundary/.curSpatialGram;
];

(*find the sptial element in each rule*)
gSpatialRulesElemPos = Map[Function[{curLHSRule},

temppos = Flatten[Position[curLHSRule,gSpatialObject[__]]];
tempposL = tempposR = tempposB = tempposT = {};

If[gbIsSpatialLeftBound,
tempposL = Flatten[Map[Position[curLHSRule,#[__]]&,gSpatialLeftBound]];
];
If[gbIsSpatialRightBound,
tempposR = Flatten[Map[Position[curLHSRule,#[__]]&,gSpatialRightBound]];
];
If[gbIsSpatialBottomBound,
tempposB = Flatten[Map[Position[curLHSRule,#[__]]&,gSpatialBottomBound]];
];
If[gbIsSpatialTopBound,
tempposT = Flatten[Map[Position[curLHSRule,#[__]]&,gSpatialTopBound]];
];

temppos = Sort[Join[temppos,tempposL,tempposR,tempposB,tempposT]];

If[Length[temppos]>1,temppos,0]

],gGrammarRulesLHS];

Print["gSpatialRulesElemPos = ",gSpatialRulesElemPos];

gPositionOfSpatialRules = Flatten[Position[gSpatialRulesElemPos,{__}]];

gPosSpatialContRules = Flatten[Map[Position[gPositionOfContRules,#]&,gPositionOfSpatialRules]];
gPosSpatialDiscRules = Flatten[Map[Position[gPositionOfDiscRules,#]&,gPositionOfSpatialRules]];
gPosSpatialDelayedRules = Flatten[Map[Position[gPositionOfDelayedContRules,#]&,gPositionOfSpatialRules]];
gPosSpatialAccelRules = Flatten[Map[Position[gPositionOfAcceleratedRules,#]&,gPositionOfSpatialRules]];
gPosSpatialDiffRules = Flatten[Map[Position[gPositionOfDiffRules,#]&,gPositionOfSpatialRules]];

gPositionOfNonSpatialRules = Complement[Range[1,Length[gSpatialRulesElemPos]],gPositionOfSpatialRules];

gPosNonSpatialContRules = Complement[Range[1,Length[gPositionOfContRules]],gPosSpatialContRules];
gPosNonSpatialDiscRules = Complement[Range[1,Length[gPositionOfDiscRules]],gPosSpatialDiscRules];
gPosNonSpatialDelayedRules = Complement[Range[1,Length[gPositionOfDelayedContRules]],gPosSpatialDelayedRules];
gPosNonSpatialAccelRules = Complement[Range[1,Length[gPositionOfAcceleratedRules]],gPosSpatialAccelRules];
gPosNonSpatialDiffRules = Complement[Range[1,Length[gPositionOfDiffRules]],gPosSpatialDiffRules];

If[debug,
Print["preProcessSpatial: gSpatialRulesElemPos = ",gSpatialRulesElemPos];
Print["preProcessSpatial: gPositionOfSpatialRules = ",gPositionOfSpatialRules];
Print["preProcessSpatial: gPosSpatialContRules = ",gPosSpatialContRules];
Print["preProcessSpatial: gPosSpatialDiscRules = ",gPosSpatialDiscRules];
Print["preProcessSpatial: gPosSpatialDelayedRules = ",gPosSpatialDelayedRules];
Print["preProcessSpatial: gPosSpatialAccelRules = ",gPosSpatialAccelRules];
Print["preProcessSpatial: gPosSpatialDiffRules = ",gPosSpatialDiffRules];
];

];
]


SetAttributes[preProcessSpatial,ReadProtected]


preProcessWiener[gr_Grammar]:= Module[{curGrammar,curWienerVar,newWienerVar},

curGrammar = gr;
curWienerVar = grammarWienerVariable/. Apply[List,gr];
giWienerVar = Null;

If[curWienerVar =!= grammarWienerVariable,

giWienerVar = Unique["giWienerVar"<>ToString[indexIteration]];

curGrammar = curGrammar/.curWienerVar-> giWienerVar;
];

curGrammar
]


SetAttributes[preProcessWiener,ReadProtected]


preProcessDiffusion[gr_Grammar]:=Module[{diffParams,curGrammar,curDiffVars,curSourceFunctions},
diffParams = gDiffusion/. Apply[List,gr];
curGrammar = gr;

giDiffVars = {};

If[Length[diffParams]>0,

curDiffVars = gDiffVariable/.diffParams;
curSourceFunctions = gDiffSource/. diffParams;
gValsDiffVarsDecay = gDiffDecay/.diffParams;
gValsDiffConstant = gDiffConstant/.diffParams;

gIsDiffDecayFunc = gDiffDecayFunc/.diffParams;
If[gIsDiffDecayFunc === gDiffDecayFunc, gIsDiffDecayFunc = False;];

gArrDiffSpatialParamX =gDiffSpatialParamX/.diffParams;
gArrDiffSpatialParamY =gDiffSpatialParamY/.diffParams;
gArrDiffSpatialParamR =gDiffSpatialParamR/.diffParams;

gDiffBoundTypeLeft = gDiffBoundaryTypeLeft/.diffParams;
gDiffBoundTypeRight = gDiffBoundaryTypeRight/.diffParams;
gDiffBoundTypeBottom = gDiffBoundaryTypeBottom/.diffParams;
gDiffBoundTypeTop = gDiffBoundaryTypeTop/.diffParams;

gDiffBoundValLeft = gDiffBoundaryValLeft/.diffParams;
gDiffBoundValRight = gDiffBoundaryValRight/.diffParams;
gDiffBoundValBottom = gDiffBoundaryValBottom/.diffParams;
gDiffBoundValTop = gDiffBoundaryValTop/.diffParams;

If[Length[curDiffVars]== 0,
curDiffVars = {curDiffVars};
curSourceFunctions = {curSourceFunctions};
gValsDiffVarsDecay = {gValsDiffVarsDecay};
gValsDiffConstant = {gValsDiffConstant};
];

giDiffVars = Table[Unique["giDiffVar"<>ToString[i]],{i,1,Length[curDiffVars]}];
giSourceFunctions = Table[Unique["giSourceFunction"<>ToString[i]],{i,1,Length[curSourceFunctions]}];

If[Length[Union[{Length[giDiffVars],Length[giSourceFunctions],Length[gValsDiffVarsDecay],Length[gValsDiffConstant]}]]!= 1,

Print["ERROR: preProcessDiffusion invalid input. All diffusion arrays should be of same length "];
Print["{giDiffVars,giSourceFunctions,gValsDiffVarsDecay,gValsDiffConstant} = ",{giDiffVars,giSourceFunctions,gValsDiffVarsDecay,gValsDiffConstant}];
];

curGrammar = curGrammar/. MapThread[Function[{curVar,curgiVar},curVar-> curgiVar],{curDiffVars,giDiffVars}];
curGrammar = curGrammar/. MapThread[Function[{curVar,curgiVar},curVar-> curgiVar],{curSourceFunctions,giSourceFunctions}];

];

curGrammar
];


SetAttributes[preProcessDiffusion,ReadProtected]


processGrammar[gr_Grammar]:=Module[{curGrammar},

curGrammar = preProcessDiffusion[N[gr]];
curGrammar = preProcessWiener[curGrammar];

grpp=preProcessRules2[curGrammar] ;

preProcessSpatial[curGrammar];

(*Print[gMappedRegLHStoRHSelems];*)

If[debug,Print["guy- grpp = ",grpp]];

(*guy - add this line to keep the hold in grammer after the releaseHold of the NameExt2*)
grpp= grpp /. Hold[x_] -> Hold[Hold[x]];

If[debug,Print["guy- grpp 2 = ",grpp]];

(* now Hold only the where part - that will be released when expnading the list of right hand elements*)
(*grpp = grpp /. where[x___] -> Hold[where[x]];*)
(*Remark - since I changed the code that handles the probability there is no need for this additional hold over the where. the realse of the where section will be done when calculating the rule-vector probability of execution BUT it will not affect it. the where will be release also as usual in the loop over the dynalic list creation*)

If[debug,Print["guy- grpp 3 = ",grpp]];

(* translate the grammar into a set of substitution rules *)
rg7=(lhs_->rhs_)->Hold[NameExt2[lhs]]->rhs;
preReleasegramtrans=ReleaseHold[getter[grpp,processedRules]/.rg7];

If[debug,Print["guy- the Grammer rules (preReleasegramtrans) = ",preReleasegramtrans]];

gRHSRulesArr = ReleaseHold[Replace[gRHSRulesArr,rg7,Infinity]];
If[debug,Print["guy- gRHSRulesArr = ",gRHSRulesArr]];

(* now trnaslate the LHS elements to a template name*)
preReleasegramtrans[[All,indexOfLHSElements]] = Map[Function[{ruleLHSItem},
NameExt2[ruleLHSItem]
], preReleasegramtrans[[All,indexOfLHSElements]]];

preReleasegramtrans[[All,indexOfAppliedPartOfLHS]] = Map[Function[{ruleLHSItem},
NameExt2[ruleLHSItem]
], preReleasegramtrans[[All,indexOfAppliedPartOfLHS]]];

If[debug,Print["guy- the Grammer rules after LHS elements change (preReleasegramtrans) = ",preReleasegramtrans]];

(*now handle replace all section*)
preReleasegramtrans[[All,indexReplaceAll]] = Map[Function[{repAllSec},
If[Length[repAllSec]>0,
{Map[#[[1]]-> True &,repAllSec],Map[#[[1]]-> #[[2]] &,repAllSec]}
,repAllSec]],preReleasegramtrans[[All,indexReplaceAll]]];

preReleasegramtrans = Map[Function[{currule},
HandleDynamicVarInLHSOfRule[currule]
],preReleasegramtrans];

If[debug,Print["guy- preReleasegramtrans after HandleDynamicVarInLHSOfRule = ",preReleasegramtrans]];

gProcessedGrammarStruct = {gGrammarRulesLHS,gGrammarContRulesSolvingSec,gPositionOfContRules,gPositionOfDiscRules,gMappedRegLHStoRHSelems,preReleasegramtrans,gContParamStruct,gPDEs,gMonotoneRulesArr,gRHSRulesArr,gPositionOfDelayedContRules,gPositionOfAcceleratedRules,gGrammarContElmLoc,gAcceleratedRulesStruct,gGrammarAccelElmLoc,gGrammarDiffRulesSolvingSec,gGrammarDiffElmLoc,gPositionOfDiffRules};

gProcessedGrammarStruct
]


SetAttributes[processGrammar,ReadProtected]


recalcRateOfRule[iRuleIndex_,iPoolPosForRuleIndex_,bForceRecalc_]:=Module[{tempProb, tempConstraintsRules,replaceAllSec},
(*This function is intended to recalculate the rate of only rules that all their LHS elements are not removed in the execution.
When the rule is monotone , all LHS elements are kept, then we need to recalculate the random variables of the RHS elements
*) 

If[gMonotoneRulesArr[[iRuleIndex]] || bForceRecalc,

{tempProb, tempConstraintsRules,replaceAllSec}  = gRateFuncsStruct[[iRuleIndex]][gPoolVariables[[glmatchingPoolRuleVectorsOfRegElems[[iRuleIndex,iPoolPosForRuleIndex]]]]];
(*{tempProb, tempConstraintsRules,replaceAllSec} = 
probtrans[ preReleasegramtrans[[iRuleIndex]] ][gPoolVariables[[glmatchingPoolRuleVectorsOfRegElems[[iRuleIndex,iPoolPosForRuleIndex]]]]]*)


glmatchingPoolRuleVecsProb[[iRuleIndex,iPoolPosForRuleIndex]] = {tempProb, tempConstraintsRules};

];


]


SetAttributes[recalcRateOfRule,ReadProtected]


recalcRatesForModifiedVec[iRuleIndex_,iPoolPosForRuleIndex_]:=Module[{},

If[debug,
Print["recalcRatesForModifiedVec before glmatchingPoolRuleVecsProb =  ",glmatchingPoolRuleVecsProb];
];

(*go over the modified vector's overlapping vectors and modify their rates *)
Map[Function[{curvecPos},
If[MemberQ[gPositionOfContRules,curvecPos[[1]]],
gPoolObjModified[[glmatchingPoolRuleVectorsOfRegElems[[curvecPos[[1]],curvecPos[[2]]]]]] = True;
,
recalcRateOfRule[curvecPos[[1]],curvecPos[[2]],True];
];
],gStaticPoolVecsToVecs[[iRuleIndex,iPoolPosForRuleIndex]]];

If[debug,
Print["recalcRatesForModifiedVec after glmatchingPoolRuleVecsProb =  ",glmatchingPoolRuleVecsProb];
];

];


SetAttributes[recalcRatesOfModifiedVec,ReadProtected]


CreateTerminalElemLocs[]:=Module[{},
grammarTerminalElemLocs = Map[Function[{rule},
Partition[
Flatten[Position[
Map[Function[{curRHSElem},

If[Length[Flatten[Map[Function[{rule2},

Map[Function[{curLHSElem},

If[curRHSElem/. curLHSElem -> True,
1,{},{}]

],rule2[[1]]]

],grammarRulesArr]]] > 0,1,0]

],rule[[2]]],0]
],1]

],grammarRulesArr];

]





findMinSimulationTimPoint[curarrSimulationTimePoints_,curSimulationTime_] :=Module[{},

Min[Map[Function[{curTimePoint},

If[curTimePoint>curSimulationTime,curTimePoint-curSimulationTime,\[Infinity]]
],curarrSimulationTimePoints]]

]


SetAttributes[findMinSimulationTimPoint,ReadProtected]


gBStartNewSimulation = True;
gbLoadProcessedGrammar = False;





createRealGrid[inGrid_,inGridBLPos_,inGridDelta_,opt___?OptionQ]:=Module[{bplotRealGrid,realGrid},

bplotRealGrid = plotRealGrid/.{opt}/.Options[createRealGrid];

realGrid = Flatten[MapIndexed[Function[{curRow,curRowInd},
MapIndexed[Function[{curVal,curColInd},
realPos = inGridBLPos+({curColInd[[1]],curRowInd[[1]]}-1)*inGridDelta;

{realPos[[1]],realPos[[2]],curVal}
],curRow]],inGrid],1];

If[bplotRealGrid,
Print[ListPlot3D[realGrid]];
];

realGrid
]


getSimulationStruct[]:=Module[{},
gSimStruct
]


SetAttributes[getSimulationStruct,ReadProtected]


loadSimulationStruct[]:=Module[{},
<<gSimStruct
]


SetAttributes[loadSimulationStruct,ReadProtected]


executeGrammar[gr_Grammar,init_,depth_,saveChoices_,opt___?OptionQ]:=Module[ 
{i,p,positions,ps,mi,rulenums,probvector,rr,epsilon,tempProb,
t,tn,intervals,r,boollist,pos,choice,choices,tempMaxProbArr,iPoolRuleCandidateIndex,iPosPoolForRuleIndex,positionsOfPoolForRule,iRuleIndex,iDiscRuleIndex,iPoolPosForRuleIndex,currentPoolElements,numElementsIntheList,ConstraintsOfElementInList,ElementInList,CnstOfElementInListUnhold,solutionsOfCnstElmntList,ElementInListTemplate,indexOfElementInList,randomNumberTime,deltaTime,numSimulationIterations,sumRhoFunctions,retValTime,curchosenRule,curchosenRuleStruct,bReachedStopCriteria,curStatusNextRuleExec,curSimStopCriteriaArr,curMeasureDynamics,curMeasureDynamicsForEveryDiscreteStep,curDerivTimeToMeasureDynamics,curTimeBetweenMeasureDynamicsSteps,maxDerivTimeBetweenSteps,curderivTimeBetweenSteps,curDynamicsPoolPair,curendIterationDisplayFunction,posElementsInLHS,newposElementsToDelete,newTerminalItems,curScreenPoolItems,curScreenItemsPosInPool,curarrSimulationTimePoints,curMinSimulationTimPoint,curmaxDerivTimeBetweenSteps,cursaveAllSimulation,curiterFunctionsHandle,posModifiedElements,curSimStructMaxSize,bPDEGridSave},
(* open up the variables for debugging: *)

curSimStopCriteriaArr = simStopCriteriaArr/.{opt}/.Options[executeGrammar];
curMeasureDynamics = measureDynamics/.{opt}/.Options[executeGrammar];
curMeasureDynamicsForEveryDiscreteStep = measureDynamicsForEveryDiscreteStep/.{opt}/.Options[executeGrammar];
curDerivTimeToMeasureDynamics = derivTimeToMeasureDynamics/.{opt}/.Options[executeGrammar];
curTimeBetweenMeasureDynamicsSteps = timeBetweenMeasureDynamicsSteps/.{opt}/.Options[executeGrammar];
curendIterationDisplayFunction = endIterationDisplayFunction/. {opt}/.Options[executeGrammar];
guseDelayedRules = useDelayedRules/. {opt}/.Options[executeGrammar];
guseAcceleratedRules = useAcceleratedRules/. {opt}/.Options[executeGrammar];
gmaxTotalSimulationTime = maxTotalSimulationTime/. {opt}/.Options[executeGrammar];
curScreenPoolItems = screenPoolItems /. {opt}/.Options[executeGrammar];
cursaveAllSimulation = saveAllSimulation  /. {opt}/.Options[executeGrammar];
curiterFunctionsHandle = iterFunctionsHandle  /. {opt}/.Options[executeGrammar];
gIsStaticStructurePool = isStaticStructurePool  /. {opt}/.Options[executeGrammar];
giMGlevel = multiGridLevel  /. {opt}/.Options[executeGrammar];
bPDEGridSave = pdeGridSave  /. {opt}/.Options[executeGrammar];
gPDEGridArr = pdeGridsIniVal  /. {opt}/.Options[executeGrammar];
gPDEGridPos = pdeGridPosIniVal  /. {opt}/.Options[executeGrammar];
gDeltaGrid = pdeDeltaGrid  /. {opt}/.Options[executeGrammar];
gPDEDeltaTime = pdeDeltaTime  /. {opt}/.Options[executeGrammar];
gPdeBoundaryWidth = pdeBoundaryWidth /. {opt}/.Options[executeGrammar];

gSecretionDistributionOption = pdeSecretionDistributionOption  /. {opt}/.Options[executeGrammar];

(*gPDEGridPos - {posBL,width,height}  - BL - bottom left point*)
gPDEGridTrajec = {};

(*arrSimulationTimePoints DOES NOT WORK WITH measureDynamics== True !!!!!!!!!!!!!!!*)
curarrSimulationTimePoints = arrSimulationTimePoints/. {opt}/.Options[executeGrammar];

gTimingRes = Table[0,{20}];

gValidSimulation = True;

gPoolItemCounter = 0;

If[guseDelayedRules,
(*when delayed rules - all discrete rules must be Accelerated. But if useAcceleratedRules-> False then the only rules that will be accelerated are the delayed rules. *)
gbEnforceAllRulesAccelStruct = True;
,
gbEnforceAllRulesAccelStruct = False;
];

If[curMeasureDynamics,
maxDerivTimeBetweenSteps = curTimeBetweenMeasureDynamicsSteps;
,
maxDerivTimeBetweenSteps = maxDerivationTimeBetweenSimSteps/.{opt}/.Options[executeGrammar];
];

gDynamicsPoolsArr = {};

gmaxTauiterNum = 0;

gArrTerminalItems = {};

(* smallest probability for unlikely rules *)
epsilon = 1.  10^-6;

numSimulationIterations = 0;

initialTiming = Timing[
If[gBStartNewSimulation,

gCurSimulationTime = 0;

If[debug,Print["guy- gr = ",gr]];

preprocessTiming = Timing[
(* preprocess the grammar into an internal data structure *)
If[gbLoadProcessedGrammar,
Print["Load Processed grammar"];

gGrammarRulesLHS = gProcessedGrammarStruct[[1]];
gGrammarContRulesSolvingSec = gProcessedGrammarStruct[[2]];
gPositionOfContRules = gProcessedGrammarStruct[[3]];
gPositionOfDiscRules = gProcessedGrammarStruct[[4]];
gMappedRegLHStoRHSelems = gProcessedGrammarStruct[[5]];
preReleasegramtrans = gProcessedGrammarStruct[[6]];
gContParamStruct = gProcessedGrammarStruct[[7]];
gPDEs = gProcessedGrammarStruct[[8]];
gMonotoneRulesArr = gProcessedGrammarStruct[[9]];
gRHSRulesArr = gProcessedGrammarStruct[[10]];
gPositionOfDelayedContRules = gProcessedGrammarStruct[[11]];
gPositionOfAcceleratedRules = gProcessedGrammarStruct[[12]];
gGrammarContElmLoc = gProcessedGrammarStruct[[13]];
gAcceleratedRulesStruct = gProcessedGrammarStruct[[14]];
gGrammarAccelElmLoc = gProcessedGrammarStruct[[15]];
gGrammarDiffRulesSolvingSec = gProcessedGrammarStruct[[16]];
gGrammarDiffElmLoc = gProcessedGrammarStruct[[17]];
gPositionOfDiffRules = gProcessedGrammarStruct[[18]];
,
processGrammar[gr];
];

thePool = N[init];
gPoolVariables={};

If[debug,Print["guy initial active pool = ",thePool]];

(* initialize the matching rule-pool items structure*)
glRuleMatchingPoolItemsLocations = Map[Function[{rule},Table[{},{Length[rule[[indexOfLHSElements,1]]]}]],preReleasegramtrans];
glRuleForAllMatchingPoolItemsLocations = Map[Function[{rule},Table[{},{Length[rule[[indexOfLHSElements,2]]]}]],preReleasegramtrans];
glmatchingPoolRuleVectorsOfRegElems = Table[{},{i,Length[preReleasegramtrans]}];
glmatchingPoolRuleVecsProb = Table[{},{i,Length[preReleasegramtrans]}];
glmatchingPoolRuleVecReplaceAll = Table[{},{i,Length[preReleasegramtrans]}];
glmatchingPoolRuleCorrespondingForAllElems = Table[{},{i,Length[preReleasegramtrans]}];
glRuleNotExistsMatchingPoolItemsLocations = Map[Function[{rule},Table[{},{Length[rule[[indexOfLHSElements,3]]]}]],preReleasegramtrans];
glmatchingPoolRuleCorrespondingNotExistsElems = Table[{},{i,Length[preReleasegramtrans]}];

glNewMatchingPoolRuleVectorsOfRegElems = Table[{},{i,Length[preReleasegramtrans]}];
glContEqArr = {};
glAccelRatesArr = {};
glDiffEqArr = {};
];

If[debugTiming1,Print["preprocessTiming = ",preprocessTiming];];

preprocessTiming2 = Timing[
createVariablesToNewPoolElements[thePool];
];
If[debugTiming1,Print["preprocessTiming2 = ",preprocessTiming2];];

preprocessTiming2 = Timing[
gPoolObjModified = {};
gPoolObjContEqs = {};
gPoolObjVarTypes = {};
gPoolObjSpatialConnectArr = {};
gPoolObjSpatialDiscRateArr = {};

addNewPoolItemsToStructs[thePool];
];
If[debugTiming1,Print["addNewPoolItemsToStructs , preprocessTiming2 = ",preprocessTiming2]];


timingRes = Timing[
createRateFuncStruct[];
];
If[debugTiming1,Print[" createRateFuncStruct finish , timingRes = ",timingRes]];

preprocessTiming3 = Timing[
(* go over all the initial pool and initialize the matching arrays*)
MapIndexed[Function[{rule,indexRule},
If[!MemberQ[gPositionOfSpatialRules,indexRule[[1]]],
HandleNewPoolItemInRule[thePool,1,rule,indexRule[[1]]];
];
],preReleasegramtrans];

If[gIsStaticStructurePool,
setStaticPoolStruct[];
createStaticPoolItemsConstParams[];
];

];

If[debugTiming1,Print["preprocessTiming3 = ",preprocessTiming3];];

timingRes = Timing[
If[Length[gPositionOfSpatialRules]>0,
createSpatialConnections[];
];
];
If[debugTiming1,Print["preprocessTiming3 createSpatialConnections finish , timingRes = ",timingRes]];
];

];

If[debugTiming1,Print["initialTiming = ",initialTiming];];

(*createMapFromContToDiscRules[];*)

grammarRulesArr = Map[Function[{currule},currule[[indexOfAppliedPartOfLHS]]->currule[[1,2]] ],preReleasegramtrans];

(*terminal elements are elements on the RHS of some rule that have no matching LHS element in any other rule*)
CreateTerminalElemLocs[];

createContEqsStrcuts[];

(*calcSpatialDiscRulesRates needs to be after createContEqsStrcuts since it uses the modified structure*)
timingRes = Timing[
If[Length[gPositionOfSpatialRules]>0,
calcSpatialDiscRulesRates[];
];
];
If[debugTiming1,Print["preprocessTiming3 calcSpatialDiscRulesRates finish , timingRes = ",timingRes]];


curSimStructMaxSize = 1000;
If[cursaveAllSimulation,
gSimStruct= Table[{},{curSimStructMaxSize}];
gSimStruct[[1]]= {0,thePool,If[bPDEGridSave,gPDEGridArr,{}],gPDEGridPos};

curSimStructSize = 1;
,
gSimStruct = {};
];

curtimer = 0;
bReachedStopCriteria = False;
(* execute the grammar to the given depth of derivation *)
(*Print["curSimStopCriteriaArr = ",curSimStopCriteriaArr];*)

For[indexIteration=1;choices={}, indexIteration<= depth, indexIteration++, 

If[Mod[indexIteration,1] == 0 && debugIndexIteration,
Print["$$$$$$$$$$$$$$$$$$$$$$$$$$$$ iteration Num = ",indexIteration ," gCurSimulationTime = ",gCurSimulationTime];
Print["length pool = ",Length[thePool]];
];

iterationTime = Timing[

MapIndexed[Function[{curFuncHandle,indexFuncHandle},

ReleaseHold[curFuncHandle]

],curiterFunctionsHandle];

MapIndexed[Function[{curStopCrt,indexStopCrt},

If[ReleaseHold[curStopCrt],
Print["*****************************************************"];
Print["Reached stopping criteria #",indexStopCrt[[1]]];
Print[" iteration Num = ",indexIteration ," gCurSimulationTime = ",gCurSimulationTime];
Print["curStopCrt = ",curStopCrt];
bReachedStopCriteria = True;
]

],curSimStopCriteriaArr];

If[bReachedStopCriteria,
Break[];
];

If[Mod[indexIteration,1000] == 0,
Print["indexIteration = ",indexIteration];
(*Print["save the pool "];
thePool>>("thePool"<>ToString[indexIteration]);
*)
];

(*
temptimer = Cases[thePool,timer[__]];
If[Length[temptimer]>0 && curtimer !=  temptimer[[1,1]],
curtimer =  temptimer[[1,1]];
Print["curtimer = ",curtimer];
];
*)

loopTiming = Timing[

numSimulationIterations++;

If[debug,
Print["-------------------------------"];
Print["current depth = ",indexIteration];
];

If[debug,Print["guy- The current Pool (thePool) = ",thePool]];
If[debug,Print["Length of Pool = ",Length[thePool]]];
(*If[debugSaveInterRes,thePool>>("thePool"<>ToString[indexIteration])];*)

If[gIsTreeGraphGrammarExec,
tempTreenodesArr= Cases[thePool, _tnode];
currentNumTreeNodes = Length[tempTreenodesArr];
If[debug,Print["Number of Tree Nodes In Pool = ",currentNumTreeNodes]];

If[(glDoSimulationUntilExactSizeTree && currentNumTreeNodes >  gMaxNumberOfTreeNode) ||
(!glDoSimulationUntilExactSizeTree && currentNumTreeNodes >=  gMaxNumberOfTreeNode),
If[debug,Print["The simulation Reached max number of Tree Nodes  , ",gMaxNumberOfTreeNode,", exit the loop "]];
Break[];
];

];

(*If[debugSaveInterRes,glRuleMatchingPoolItemsLocations>>("glRuleMatchingPoolItemsLocations"<>ToString[indexIteration]);
glRuleForAllMatchingPoolItemsLocations >>("glRuleForAllMatchingPoolItemsLocations"<>ToString[indexIteration]);
glmatchingPoolRuleVectorsOfRegElems >>("glmatchingPoolRuleVectorsOfRegElems"<>ToString[indexIteration]);
glmatchingPoolRuleVecsProb >>("glmatchingPoolRuleVecsProb"<>ToString[indexIteration]);
glmatchingPoolRuleVecReplaceAll>>("glmatchingPoolRuleVecReplaceAll"<>ToString[indexIteration]);
glmatchingPoolRuleCorrespondingForAllElems >>("glmatchingPoolRuleCorrespondingForAllElems"<>ToString[indexIteration]);
glRuleNotExistsMatchingPoolItemsLocations >>("glRuleNotExistsMatchingPoolItemsLocations"<>ToString[indexIteration]);
glmatchingPoolRuleCorrespondingNotExistsElems >>("glmatchingPoolRuleCorrespondingNotExistsElems"<>ToString[indexIteration]);
];
*)

(*
Print["glmatchingPoolRuleVectorsOfRegElems = ",glmatchingPoolRuleVectorsOfRegElems];
Print["glmatchingPoolRuleCorrespondingForAllElems = ",glmatchingPoolRuleCorrespondingForAllElems];
*)

bIsThereAtLeastOneValid = False;

timingRes = Timing[
glMatchingPoolRuleVectorsValid =MapThread[Function[{rule,mtchPoolRuleVectorArr,mtchPoolRuleVecsProbArr,mtchPoolRuleVectorCorspondForAllArr,mtchPoolRuleVectorCorspondNotExistsArr},

If[Length[rule[[indexOfLHSElements,2]]]>0 &&   Length[rule[[indexOfLHSElements,3]]]>0 ,

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVecsProb,mtchPoolRuleVectorCorspondForAll,mtchPoolRuleVectorCorspondNotExists},
If[Length[mtchPoolRuleVectorCorspondForAll] == 0 || Length[mtchPoolRuleVectorCorspondNotExists] > 0
,False,bIsThereAtLeastOneValid=True;True]
],{mtchPoolRuleVectorArr,mtchPoolRuleVecsProbArr,mtchPoolRuleVectorCorspondForAllArr,mtchPoolRuleVectorCorspondNotExistsArr}]
,

If[Length[rule[[indexOfLHSElements,2]]]>0  ,

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVecsProb,mtchPoolRuleVectorCorspondForAll},
If[Length[mtchPoolRuleVectorCorspondForAll] == 0 
,False,bIsThereAtLeastOneValid=True;True]
],{mtchPoolRuleVectorArr,mtchPoolRuleVecsProbArr,mtchPoolRuleVectorCorspondForAllArr}]

,

If[ Length[rule[[indexOfLHSElements,3]]]>0 ,

MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVecsProb,mtchPoolRuleVectorCorspondNotExists},
If[Length[mtchPoolRuleVectorCorspondNotExists] > 0
,False,bIsThereAtLeastOneValid=True;True]
],{mtchPoolRuleVectorArr,mtchPoolRuleVecsProbArr,mtchPoolRuleVectorCorspondNotExistsArr}]

,
MapThread[Function[{mtchPoolRuleVector,mtchPoolRuleVecsProb},
bIsThereAtLeastOneValid=True;True
],{mtchPoolRuleVectorArr,mtchPoolRuleVecsProbArr}]
]
]
]

],{preReleasegramtrans,glmatchingPoolRuleVectorsOfRegElems,glmatchingPoolRuleVecsProb,glmatchingPoolRuleCorrespondingForAllElems,glmatchingPoolRuleCorrespondingNotExistsElems}];
];

If[debug,Print["glMatchingPoolRuleVectorsValid = ",glMatchingPoolRuleVectorsValid];];

(* if no rule firings, we are done executing *)
If[!bIsThereAtLeastOneValid,Break[]];

gTimingRes[[1]] += timingRes[[1]];
If[debugTiming1,Print["glMatchingPoolRuleVectorsValid finish , timingRes = ",timingRes]];

timingRes = Timing[

curMinSimulationTimPoint = findMinSimulationTimPoint[curarrSimulationTimePoints,gCurSimulationTime];
If[debug,Print["findMinSimulationTimPoint finish , curMinSimulationTimPoint = ",curMinSimulationTimPoint]];

curmaxDerivTimeBetweenSteps = Min[maxDerivTimeBetweenSteps , gmaxTotalSimulationTime - gCurSimulationTime,curMinSimulationTimPoint];
If[debug,Print["curmaxDerivTimeBetweenSteps = ",curmaxDerivTimeBetweenSteps]];

If[guseAcceleratedRules || guseDelayedRules,
{curStatusNextRuleExec,iRuleIndex,iPoolPosForRuleIndex,curderivTimeBetweenSteps} = findNextRuleExecWithAccel[curmaxDerivTimeBetweenSteps];
,
{curStatusNextRuleExec,iDiscRuleIndex,iPoolPosForRuleIndex,curderivTimeBetweenSteps} = findNextRuleExec[curmaxDerivTimeBetweenSteps];
If[debug,
Print["{curStatusNextRuleExec,iDiscRuleIndex,iPoolPosForRuleIndex,curderivTimeBetweenSteps} = ",{curStatusNextRuleExec,iDiscRuleIndex,iPoolPosForRuleIndex,curderivTimeBetweenSteps}];
];
iRuleIndex = gPositionOfDiscRules[[iDiscRuleIndex ]];

];

];
gTimingRes[[2]] += timingRes[[1]];
If[debugTiming1,Print["timingRes of findNextRuleExec = ",timingRes];];

If[debug || debug1,
Print["after findNextRuleExec:  iRuleIndex = ",iRuleIndex];
Print["after findNextRuleExec:  iPoolPosForRuleIndex = ",iPoolPosForRuleIndex];
];

resetPoolObjModified[];

If[curStatusNextRuleExec == fnreStatusFailed ,
Break[];
];

If[curStatusNextRuleExec == fnreStatusDiscreteEvent,

If[debug,Print[" iRuleIndex= ",iRuleIndex]]; 
If[debug,Print[" iPoolPosForRuleIndex = ",iPoolPosForRuleIndex]]; 

posOfForAllElemsForChosenRule = If[Length[preReleasegramtrans[[iRuleIndex,indexOfLHSElements,2]]]===0 ,
(*we use an empty list iside an empty list so that the coming Map will work at least once with an empty list *)
{   {}   },
glmatchingPoolRuleCorrespondingForAllElems[[iRuleIndex,iPoolPosForRuleIndex]]];

(* record the sequence of rule choices, for debugging or tracing *)
If[saveChoices,
choices=Append[choices, iRuleIndex];

];


curchosenRule = grammarRulesArr[[iRuleIndex]];
curchosenRuleStruct = preReleasegramtrans[[iRuleIndex]];

If[debug,Print["curchosenRule = ",curchosenRule]];
If[debug,Print["curchosenRuleStruct = ",curchosenRuleStruct]];

If[debug,Print["posOfForAllElemsForChosenRule = ",posOfForAllElemsForChosenRule];];

timingRes = Timing[
newPoolItems = Flatten[Map[Function[{curPosOfForAllElem},

(*Remark  - we should chnag here to handle multiple ForAll elements*)
If[Length[curPosOfForAllElem]>0,
currentPoolElements  = Flatten[{thePool[[glmatchingPoolRuleVectorsOfRegElems[[iRuleIndex,iPoolPosForRuleIndex]]]],thePool[[curPosOfForAllElem]]}];
,
currentPoolElements  = thePool[[glmatchingPoolRuleVectorsOfRegElems[[iRuleIndex,iPoolPosForRuleIndex]]]];
];

If[debug,Print["currentPoolElements = ",currentPoolElements];];

If[curchosenRuleStruct[[indexComplexParamsExp]]==1,

eqTermParams = Flatten[MapThread[Function[{curterm,curpoolitem},
If[Length[curterm]>0,
MapThread[Function[{termParam,poolItemParam},If[Head[termParam]===Pattern,typeTermReg[termParam[[1]]-> poolItemParam],typeTermComplex[termParam==poolItemParam]]],{Apply[List,curterm],Apply[List,curpoolitem]}]
,{}]
],{Flatten[curchosenRuleStruct[[indexOfAppliedPartOfLHS]]],currentPoolElements}]];

If[debug,Print["eqTermParams = ",eqTermParams];];

typeTermRegArr = Cases[eqTermParams,typeTermReg[_]];
If[Length[typeTermRegArr]>0,typeTermRegArr = typeTermRegArr[[All,1]];];

tempEqParams = Flatten[{Cases[eqTermParams,typeTermComplex[_]][[All,1]],
Flatten[Map[Function[{curTermRegRule},If[NumericQ[curTermRegRule[[2]]] , curTermRegRule[[1]] == (curTermRegRule[[1]]/.curTermRegRule),{}]],typeTermRegArr]]
}];

solTermParams = Solve[tempEqParams,curchosenRuleStruct[[indexOfLHSVars]]];

If[debug,Print["solTermParams = ",solTermParams];];

solTermParams2 = Flatten[{First[solTermParams],typeTermRegArr}];
If[debug,Print["solTermParams2 = ",solTermParams2]];

curnewelements = curchosenRule[[2]]/.solTermParams2;
,
curnewelements=currentPoolElements /. curchosenRule;
];

If[debug,Print["curnewelements = ",curnewelements];];

If[Head[curnewelements] === List,
curnewelements = Flatten[curnewelements];
,
curnewelements = {curnewelements};
];

If[debug,Print["guy curnewelements before  constraints Rules= ",curnewelements]]; 
If[debug,Print["guy glGroundPoolVecRates= ",glGroundPoolVecRates]];
If[debug,Print["guy {iDiscRuleIndex,iPoolPosForRuleIndex}= ",{iDiscRuleIndex,iPoolPosForRuleIndex}]];
curnewelements = curnewelements /. glGroundPoolVecRates[[iDiscRuleIndex,iPoolPosForRuleIndex]][[2]];
If[debug,Print["guy curnewelements After  constraints Rules= ",curnewelements]]; 

newTerminalItems = curnewelements[[Flatten[grammarTerminalElemLocs[[iRuleIndex]]]]];

gArrTerminalItems = Flatten[{gArrTerminalItems,newTerminalItems}];

(*remove the RHS elements that are matched in the LHS - meaning they have a matching LHS element that we will not remove from the pool therefore there is no need to add them to the pool
Also remove the terminal elements , meaning elements that will not be used in any of the rules*)
curnewelements = Delete[curnewelements, Join[gMappedRegLHStoRHSelems[[iRuleIndex,2]],grammarTerminalElemLocs[[iRuleIndex]]]];

(* handle the dynamic list - *)
numElementsIntheList = getElementInList[curnewelements,grammarNumElementsInList];
If[numElementsIntheList =!= Null , 
	
ConstraintsOfElementInList = getElementInList[curnewelements,where];

If[debug,Print["guy- ConstraintsOfElementInList = ",ConstraintsOfElementInList]];

ElementInListTemplate = curnewelements[[1]];

curnewelements = {};


For[indexOfElementInList  = 1  , indexOfElementInList <= numElementsIntheList[[1]] , indexOfElementInList++ , 

CnstOfElementInListUnhold = ReleaseHold[ConstraintsOfElementInList];

solutionsOfCnstElmntList = {};

CnstOfElementInListUnhold = CnstOfElementInListUnhold /. {grammarIndexOfElementInList->indexOfElementInList};

If[debug,Print["guy- CnstOfElementInListUnhold = ",CnstOfElementInListUnhold]];
If[debug,Print["guy- preReleasegramtrans[[iRuleIndex]][[6]] = ",preReleasegramtrans[[iRuleIndex]][[6]] ]];

If[preReleasegramtrans[[iRuleIndex]][[6]] =!= Null && CnstOfElementInListUnhold =!= Null,
solutionsOfCnstElmntList = Solve[Apply[List,CnstOfElementInListUnhold] ,  preReleasegramtrans[[iRuleIndex]][[6]]]];

(* if there is a list of different solutions then pick the first one*)
If[Length[solutionsOfCnstElmntList]=!=0,
If[Head[solutionsOfCnstElmntList[[1]]]===List,
solutionsOfCnstElmntList = solutionsOfCnstElmntList[[1]]]];

(*If[debug,Print["guy- solutionsOfCnstElmntList = ",solutionsOfCnstElmntList]];*)

ElementInList = ElementInListTemplate;
(*If[debug,Print["guy- before ElementInList = ",ElementInList]];*)

solutionsOfCnstElmntList = Append[solutionsOfCnstElmntList,grammarIndexOfElementInList->indexOfElementInList];

ElementInList = ElementInList /. solutionsOfCnstElmntList;

(*If[debug,Print["guy- after ElementInList = ",ElementInList]];*)

curnewelements  = Append[curnewelements , ElementInList];
]];

curnewelements
],posOfForAllElemsForChosenRule]];
];
gTimingRes[[3]] += timingRes[[1]];
If[debugTiming1,Print["creating the new items finish , timingRes = ",timingRes]];

timingRes = Timing[
posElementsInLHS = Flatten[{glmatchingPoolRuleVectorsOfRegElems[[iRuleIndex,iPoolPosForRuleIndex]],posOfForAllElemsForChosenRule}];

(* delete the elements of the lhs rule in pool *);
posElementsToDelete = posElementsInLHS;

(*remove the LHS elements that are matched in the RHS - meaning they have a matching RHS element that we will not add to the pool therefore there is no need to remove them from the pool*)
posElementsToDelete = Delete[posElementsToDelete, gMappedRegLHStoRHSelems[[iRuleIndex,1]]];

If[Length[glmatchingPoolRuleVecReplaceAll[[iRuleIndex,iPoolPosForRuleIndex]]]>0,

(*Print["glmatchingPoolRuleVecReplaceAll[[iRuleIndex,iPoolPosForRuleIndex]] = ",glmatchingPoolRuleVecReplaceAll[[iRuleIndex,iPoolPosForRuleIndex]]];*)

replaceAllStrct = DeleteCases[MapIndexed[Function[{curItem,indexItem},
If[curItem/.glmatchingPoolRuleVecReplaceAll[[iRuleIndex,iPoolPosForRuleIndex,1]],
{curItem/.glmatchingPoolRuleVecReplaceAll[[iRuleIndex,iPoolPosForRuleIndex,2]],indexItem[[1]]},
0,0]
],thePool],0];

replaceAllNewItems = replaceAllStrct[[All,1]];
posReplaceAllElemToDelete = replaceAllStrct[[All,2]];

(*Print["replaceAllNewItems = ",replaceAllNewItems];
Print["posReplaceAllElemToDelete = ",posReplaceAllElemToDelete];
*)

newPoolItems = Flatten[{newPoolItems,replaceAllNewItems}];
posElementsToDelete = Flatten[{posElementsToDelete,posReplaceAllElemToDelete}];

];

If[gIsStaticStructurePool,
posModifiedElements = posElementsToDelete;
posElementsToDelete = {};
];
];
gTimingRes[[4]] += timingRes[[1]];
If[debugTiming1,Print["deleting elements 1 , timingRes = ",timingRes]];

timingRes = Timing[
recalcRateOfRule[iRuleIndex,iPoolPosForRuleIndex,False];
];
gTimingRes[[5]] += timingRes[[1]];
If[debugTiming1,Print["recalcRateOfRule , timingRes = ",timingRes]];

(*
Print["guyPrint- before handleRHSRules iRuleIndex: ",iRuleIndex];
Print["guyPrint- before handleRHSRules removed elems : ",thePool[[posElementsToDelete]]];
Print["guyPrint- before handleRHSRules new elems: ",newPoolItems];
*)

(*now we apply the RHS rules with the current elements and *)
(*should add code to support ForAll rules . meaning , this code does not support rules that have ForAll and also RHS rules*)
timingRes = Timing[
{newposElementsToDelete,rhsRulesnewItems} = handleRHSRules[posElementsInLHS,curchosenRule[[1]],gRHSRulesArr[[iRuleIndex]]];
];
gTimingRes[[6]] += timingRes[[1]];
If[debugTiming1,Print["handleRHSRules , timingRes = ",timingRes]];

If[debug,Print["After handleRHSRules , {newposElementsToDelete,rhsRulesnewItems} = ",{newposElementsToDelete,rhsRulesnewItems}]];

posElementsToDelete = Flatten[{posElementsToDelete,newposElementsToDelete}];
If[debug,Print["After handleRHSRules , posElementsToDelete 1 = ",posElementsToDelete]];

newPoolItems = Flatten[{newPoolItems,rhsRulesnewItems}];

If[debug,Print["After handleRHSRules , newPoolItems = ",newPoolItems]];

timingRes = Timing[
newPoolItems = HandleDynamicVariable[newPoolItems];
];
gTimingRes[[7]] += timingRes[[1]];
If[debugTiming1,Print["HandleDynamicVariable , timingRes = ",timingRes]];

(*Print["before HandleDeletedPoolItems"];
Print["Length[thePool] = ",Length[thePool]];
Print["Length[posElementsToDelete] = ",Length[posElementsToDelete]];*)

(*If[debugSaveInterRes,posElementsToDelete>>("posElementsToDelete"<>ToString[indexIteration])];*)

If[debug || debug1,
Print["before HandleDeletedPoolItems:  posElementsToDelete = ",posElementsToDelete];
Print["before HandleDeletedPoolItems:  thePool[[posElementsToDelete]] = ",thePool[[posElementsToDelete]]];
];

timingRes = Timing[HandleDeletedPoolItems[posElementsToDelete]];
gTimingRes[[8]] += timingRes[[1]];
If[debugTiming1,Print["HandleDeletedPoolItems finish , timingRes = ",timingRes]];

If[debug || debug1,
Print["before adding newPoolItems = ",newPoolItems];
];

timingRes = Timing[
thePool = Delete[thePool, Partition[posElementsToDelete,1]];

removeFreePoolVars[posElementsToDelete];

iLenOfPoolPriorAddingNewItems = Length[thePool];

If[gIsStaticStructurePool,
(*reshuffle the items in the vector according to the mapping and *)
thePool[[posModifiedElements]] = newPoolItems[[gFullMapRegLHStoRHSelems[[iRuleIndex]]]];
,
thePool = Flatten[{thePool,newPoolItems},1];
];
];
gTimingRes[[9]] += timingRes[[1]];
If[debugTiming1,Print["delete 2 finish , timingRes = ",timingRes]];

timingRes = Timing[
If[gIsStaticStructurePool,
updateVariablesInStaticPool[posModifiedElements];
,
createVariablesToNewPoolElements[newPoolItems];
];
];
gTimingRes[[10]] += timingRes[[1]];
If[debugTiming1,Print["createVariablesToNewPoolElements , timingRes = ",timingRes]];


timingRes = Timing[
If[!gIsStaticStructurePool,
addNewPoolItemsToStructs[newPoolItems];
];
];
gTimingRes[[11]] += timingRes[[1]];
If[debugTiming1,Print["addNewPoolItemsToStructs , timingRes = ",timingRes]];

(*Print["before HandleNewPoolItemInRule"];
Print["Length[thePool] = ",Length[thePool]];
Print["Length[newPoolItems] = ",Length[newPoolItems]];*)

If[!gIsStaticStructurePool,
timingRes = Timing[MapIndexed[Function[{rule,indexRule},

(*if there are spatial objects in this rule (more then 1) then we will do the matching thru the delaunayTriangulation *)
If[!MemberQ[gPositionOfSpatialRules,indexRule[[1]]],
HandleNewPoolItemInRule[Apply[List,newPoolItems],iLenOfPoolPriorAddingNewItems+1,rule,indexRule[[1]]]
];

],preReleasegramtrans]];
gTimingRes[[12]] += timingRes[[1]];
If[debugTiming1,Print["HandleNewPoolItemInRule finish , timingRes = ",timingRes]];
];

If[gIsStaticStructurePool,
timingRes = Timing[
recalcRatesForModifiedVec[iRuleIndex,iPoolPosForRuleIndex];
];
gTimingRes[[14]] += timingRes[[1]];
];

If[debug,

Print["glRuleMatchingPoolItemsLocations = ",glRuleMatchingPoolItemsLocations];
Print["glmatchingPoolRuleVectorsOfRegElems = ",glmatchingPoolRuleVectorsOfRegElems];
Print["glmatchingPoolRuleVecsProb = ",glmatchingPoolRuleVecsProb];
Print["glRuleForAllMatchingPoolItemsLocations = ",glRuleForAllMatchingPoolItemsLocations];
Print["glmatchingPoolRuleCorrespondingForAllElems = ",glmatchingPoolRuleCorrespondingForAllElems];
Print["glRuleNotExistsMatchingPoolItemsLocations = ",glRuleNotExistsMatchingPoolItemsLocations];
Print["glmatchingPoolRuleCorrespondingNotExistsElems = ",glmatchingPoolRuleCorrespondingNotExistsElems];
];

If[debug,Print["guy the active pool after adding the term (thePool) = ",thePool]];

];(*end If[curStatusNextRuleExec == fnreStatusDiscreteEvent *)

(*this should be done here outside the If , because the spatial connections might change even if there is no discrete event*)
timingRes = Timing[
If[Length[gPositionOfSpatialRules]>0,
createSpatialConnections[];
];
];
gTimingRes[[13]] += timingRes[[1]];
If[debugTiming1,Print["createSpatialConnections finish , timingRes = ",timingRes]];

timingRes = Timing[
createContEqsStrcuts[];
];
gTimingRes[[15]] += timingRes[[1]];
If[debugTiming1,Print["createContEqsStrcuts , timingRes = ",timingRes]];


(*calcSpatialDiscRulesRates needs to be after createContEqsStrcuts since it uses the modified structure*)
timingRes = Timing[
If[Length[gPositionOfSpatialRules]>0,
calcSpatialDiscRulesRates[];
];
];
gTimingRes[[16]] += timingRes[[1]];
If[debugTiming1,Print["calcSpatialDiscRulesRates finish , timingRes = ",timingRes]];

];

timingRes = Timing[
If[cursaveAllSimulation,

curSimStructSize++;
If[curSimStructSize>curSimStructMaxSize,
gSimStruct = Join[gSimStruct,Table[{},{curSimStructMaxSize}]];
curSimStructMaxSize*= 2;
];
gSimStruct[[curSimStructSize]] = {gCurSimulationTime,Join[thePool,gArrTerminalItems],If[bPDEGridSave,gPDEGridArr,{}],gPDEGridPos};

(*If[Mod[indexIteration,100]==0,
Print["GUY REMOVE"];
gSimStruct[[Range[1,indexIteration]]]>>("gSimStruct"<>ToString[indexIteration]);
];
*)
,
gSimStruct = {gCurSimulationTime,Join[thePool,gArrTerminalItems],If[bPDEGridSave,gPDEGridArr,{}],choices};
];
];
gTimingRes[[18]] += timingRes[[1]];

timingRes = Timing[
If[curMeasureDynamics,
If[curderivTimeBetweenSteps< maxDerivTimeBetweenSteps,
(*a discrete event happend*)
If[curMeasureDynamicsForEveryDiscreteStep,
(*put this pool as the first in the pair*)
curDynamicsPoolPair = {thePool,Null};

maxDerivTimeBetweenSteps = curDerivTimeToMeasureDynamics;
,
maxDerivTimeBetweenSteps -=  curderivTimeBetweenSteps;
];
,
If[curderivTimeBetweenSteps == curDerivTimeToMeasureDynamics,
(*put this pool as the second in the pair and add to the dynamics array*)
curDynamicsPoolPair[[2]] = thePool;
Print["curDynamicsPoolPair = ",curDynamicsPoolPair];
AppendTo[gDynamicsPoolsArr,{gCurSimulationTime,curDynamicsPoolPair}];

maxDerivTimeBetweenSteps = curTimeBetweenMeasureDynamicsSteps;
,
(*put this pool as the first in the pair*)
curDynamicsPoolPair = {thePool,Null};

maxDerivTimeBetweenSteps = curDerivTimeToMeasureDynamics;
];

];
];
];
gTimingRes[[19]] += timingRes[[1]];

];

If[debugTiming1,
Print["iterationTime = ",iterationTime];
Print["loopTiming = ",loopTiming];
];
gTimingRes[[20]] += iterationTime[[1]];
If[debugTiming2,
Print["indexIteration : ",indexIteration," gTimingRes = ",gTimingRes];
If[Mod[indexIteration,100]==0,
Print["thePool = ",thePool];
];
];

If[gCurSimulationTime >=  gmaxTotalSimulationTime,
Break[];
];

];

If[cursaveAllSimulation,
gSimStruct = If[curSimStructSize>0,gSimStruct[[Range[1,curSimStructSize]]],{}];
];
gSimStruct>>gSimStruct;

(*cleanup before exiting*)
removeFreePoolVars[Range[1,Length[gPoolVariables]]];

(* output *)
(*{thePool,choices,probvector,gCurSimulationTime,numSimulationIterations}*)
gValidSimulation
];


SetAttributes[executeGrammar,ReadProtected]


plot2Dgrammar[p_]:=ListPlot[Apply[List,Map[{#[[1]],#[[2]]}&,p]],PlotStyle->{PointSize[0.01]}]

iterativeExecuteGrammar[gr_Grammar,init_,depth_,debug_,saveChoices_,numOfIterations_]:=Module[ {thepool,choices,problast,k},For[k=0,k<numOfIterations,k++,{thepool,choices,problast}=executeGrammar[gr,init,depth,debug,saveChoices];Print[thepool];Print[choices];Print[problast];plot2Dgrammar[thepool]]]


theListOfOutputElements = Null;


(* VRP - viewing reference point *)
theVRP = {1.3,-2.4,2};


(* PRP - projection reference point , is defined in the VRC (viewing-reference coordiantes) *)
thePRP = theVRP*2;

thePRPLength = (thePRP.thePRP)^0.5;
Null


createBlobPoints[blobPosition_blobPos] := Module[{k,thetaAngle,phiAngle,pointRadius,pointCoordiante,pointsArray,xCoordiante,yCoordiante,zCoordiante},

pointsArray = {};
For[k=0,k<1,k++,
thetaAngle = RandomReal[{0,2Pi}];
phiAngle      = RandomReal[{0,Pi}];
pointRadius = RandomReal[{0,blobPosition[[4]]}];

xCoordiante = pointRadius*Cos[thetaAngle]*Sin[phiAngle];
yCoordiante = pointRadius*Sin[thetaAngle]*Sin[phiAngle];
zCoordiante = pointRadius*Cos[phiAngle];

pointCoordiante = {xCoordiante,yCoordiante,zCoordiante}+{blobPosition[[1]],blobPosition[[2]],blobPosition[[3]]};

pointsArray = Append[pointsArray ,pointCoordiante];
];
Map[Point,pointsArray]
];


(* Rotation matrices  - according to the book - guy note that the matrices differ from grammar matrices since these are the right handed coordinate system while the grammar's are left handed  - need to change this.*)

(* left handed : *)

(*
theRotationMatrixX[cosAngle_,sinAngle_] := {{1,0,0},{0,cosAngle,-sinAngle},{0,sinAngle,cosAngle}};

theRotationMatrixY[cosAngle_,sinAngle_] := {{cosAngle,0,sinAngle},{0,1,0},{-sinAngle,0,cosAngle}};

theRotationMatrixZ[cosAngle_,sinAngle_] := {{cosAngle,-sinAngle,0},{sinAngle,cosAngle,0},{0,0,1}};*)

(* right handed : *)
theRotationMatrixX[cosAngle_,sinAngle_] := {{1,0,0},{0,cosAngle,sinAngle},{0,-sinAngle,cosAngle}};

theRotationMatrixY[cosAngle_,sinAngle_] := {{cosAngle,0,-sinAngle},{0,1,0},{sinAngle,0,cosAngle}};

theRotationMatrixZ[cosAngle_,sinAngle_] := {{cosAngle,sinAngle,0},{-sinAngle,cosAngle,0},{0,0,1}};


plot3Dgrammar[inputStarList_List,inputBlobList_List]:=  
Module[{transformedCoordinatesList,cosThetaAngleRotation,sinThetaAngleRotation,cosPhiAngleRotation,sinPhiAngleRotation,rotationAroundY,rotationAroundX,transformedPRP,lengthTransformPRPOnZX,starGraphics,blobPointsList,starList,blobList},

Print["Projection of the 3D by Mathematica built in function"];

(*ScatterPlot3D[Map[{#[[1]],#[[2]], #[[3]]}&,p ],PlotStyle->{PointSize[0.0005]},AxesLabel->{"x","y","z"}(*,Boxed->False,Axes->False*)];*)

Print[" Dimensions[inputStarList] = " ,Dimensions[inputStarList]];
Print[" Dimensions[inputBlobList] = " ,Dimensions[inputBlobList]];

starList = Map[Point,Apply[List,inputStarList,{1}]];

starList = Map[{PointSize[0.001],RGBColor[1,0,0],#}&,starList];

starGraphics = Graphics3D[starList,{AxesLabel->{"x","y","z"},Axes->True}];

blobList = inputBlobList;

blobPointsList = Map[createBlobPoints,blobList ];

blobPointsList = Flatten[blobPointsList,1];

blobPointsList = Map[{PointSize[0.000001],RGBColor[0.5,0.5,0.1],#}&,blobPointsList];

blobGraphics = Graphics3D[blobPointsList,{AxesLabel->{"x","y","z"},Axes->True}];

Print["the blob graph"];
Show[ blobGraphics];

Print["the star graph"];
Show[ starGraphics];

Print["the graphs combined"];
Show[ {starGraphics,blobGraphics}];

Print["post Show "];

(*

Print["Projection of the 3D by own function"]; 
theListOfOutputElements = p;

(* first - translate VRP to the origin *)
transformedCoordinatesList = Map[{#[[1]],#[[2]],#[[3]]} -theVRP &, p];
transformedPRP = thePRP -theVRP;

(*Print["transformedCoordinatesList1 = ",transformedCoordinatesList];*)

(* Second - rotate to the zy plane  around the y axis (to the -z side) - 
	we move the by Pi/2+theta to -z 
	cos (Pi/2+theta) = -sin(theta) = -transformedPRP[[3]]/theLengthPRPOnZX 
	   sin (Pi/2+theta) = cos (theta) = transformedPRP[[1]]/theLengthPRPOnZX 	*)

lengthTransformPRPOnZX = ( (transformedPRP[[3]]^2) +  (transformedPRP[[1]]^2) )^0.5;

cosThetaAngleRotation = -transformedPRP[[3]]/lengthTransformPRPOnZX;
sinThetaAngleRotation = transformedPRP[[1]]/lengthTransformPRPOnZX;

rotationAroundY = theRotationMatrixY[cosThetaAngleRotation,sinThetaAngleRotation];

transformedPRP = rotationAroundY.transformedPRP;

transformedCoordinatesList =  Map[rotationAroundY.{#[[1]],#[[2]],#[[3]]} &, transformedCoordinatesList];
(*Print["transformedCoordinatesList around Y  = ",transformedCoordinatesList];*)

(*third - rotate around x axis to the -z *)
cosPhiAngleRotation = transformedPRP[[3]]/thePRPLength;
sinPhiAngleRotation = transformedPRP[[2]]/thePRPLength;

rotationAroundX = theRotationMatrixX[cosPhiAngleRotation,sinPhiAngleRotation];

rotationMatrix = rotationAroundX.rotationAroundY;

transformedCoordinatesList =  Map[rotationMatrix.{#[[1]],#[[2]],#[[3]]} &, transformedCoordinatesList];

(*Print["transformedCoordinatesList3 around X = ",transformedCoordinatesList];*)

(* Now translate to 2D coordinates *)

transformedCoordinatesList =  Map[{#[[1]]/( #[[3]]/thePRPLength + 1 ),#[[2]]/( #[[3]]/thePRPLength + 1 )}&, transformedCoordinatesList];

ListPlot[transformedCoordinatesList, PlotStyle->{PointSize[0.0005]}];

*)

];

(*
graphTable=Table[ScatterPlot3D[Map[{#[[1]],#[[2]], #[[3]]}&,Select[p,#[[4]]==n& ]],PlotStyle->{PointSize[0.01*n]}],{n,2}];
Show[StackGraphics[graphTable]];
*)



plot2Dgrammar[inputStarList_List,inputBlobList_List,useDiffenretColor_,useAxes_]:=  
Module[{transformedCoordinatesList,cosThetaAngleRotation,sinThetaAngleRotation,cosPhiAngleRotation,sinPhiAngleRotation,rotationAroundY,rotationAroundX,transformedPRP,lengthTransformPRPOnZX,starGraphics,blobPointsList,starList,blobList},

Print["Projection of the 3D by Mathematica built in function"];

(*ScatterPlot3D[Map[{#[[1]],#[[2]], #[[3]]}&,p ],PlotStyle->{PointSize[0.0005]},AxesLabel->{"x","y","z"}(*,Boxed->False,Axes->False*)];*)

Print[" Dimensions[inputStarList] = " ,Dimensions[inputStarList]];
Print[" Dimensions[inputBlobList] = " ,Dimensions[inputBlobList]];

starList2 = Map[Function[{star},If[star[[3]] <= 1 || useDiffenretColor == False, {PointSize[0.001],RGBColor[1,0,0],Point[{star[[1]],star[[2]]}]},{PointSize[0.001],RGBColor[0,0,1],Point[{star[[1]],star[[2]]}]} ]],inputStarList];

starGraphics = Graphics[starList2,{AxesLabel->{"x","y"},If[useAxes,Axes->True,Axes-> False],AspectRatio->Automatic}];

blobList = inputBlobList;

numOfPointsInBlob = 5;
tempPointsInBlobArr = Table[0,{i,numOfPointsInBlob}];

blobPointsList = Map[Function[{blobPos},

Map[Function[{tempPt},

thetaAngle = RandomReal[{0,2Pi}];
radiusFromBlobCenterX = RandomReal[{0,blobPos[[4]]}];
radiusFromBlobCenterY = RandomReal[{0,blobPos[[4]]}];

If[blobPos[[3]] <= 1 || useDiffenretColor == False,
{PointSize[0.000001],RGBColor[1,0,0],Point[{blobPos[[1]]+ radiusFromBlobCenterX*Cos[thetaAngle], blobPos[[2]]+ radiusFromBlobCenterY*Sin[thetaAngle]}]},
{PointSize[0.000001],RGBColor[0,0,1],Point[{blobPos[[1]]+ radiusFromBlobCenterX*Cos[thetaAngle], blobPos[[2]]+ radiusFromBlobCenterY*Sin[thetaAngle]}]}
]

],tempPointsInBlobArr]

],blobList ];

blobPointsList>>blobPointsList;

blobPointsList = Flatten[blobPointsList,1];

blobGraphics = Graphics[blobPointsList,{AxesLabel->{"x","y"},If[useAxes,Axes->True,Axes-> False],AspectRatio->Automatic}];

Print["the blob graph"];
Show[ blobGraphics];

Print["the star graph"];
Show[ starGraphics];

Print["the graphs combined"];
Show[ {starGraphics,blobGraphics}];

Print["post Show "];

];

(*
graphTable=Table[ScatterPlot3D[Map[{#[[1]],#[[2]], #[[3]]}&,Select[p,#[[4]]==n& ]],PlotStyle->{PointSize[0.01*n]}],{n,2}];
Show[StackGraphics[graphTable]];
*)



iterativeExecuteGrammar3D2[gr_Grammar,init_,totalDepth_, depthEachTime_,debug_,saveChoices_, numOfIterations_]:=Module[ {thepool,choices,problast,k,currentDepth},For[k=0,k<numOfIterations,k++,
thepool = init;
For[currentDepth=0, currentDepth< totalDepth, currentDepth = currentDepth+depthEachTime, 
{thepool,choices,problast}=executeGrammar[gr,thepool,depthEachTime,debug,saveChoices];Print["guy post execute"];(*Print[choices];Print[problast];*)
plot3Dgrammar[ Cases[thepool, _star], Cases[thepool, _blobPos] ]]
]]


iterativeExecuteGrammar2D[gr_Grammar,init_,totalDepth_, depthEachTime_,debug_,saveChoices_, numOfIterations_]:=Module[ {thepool,choices,problast,k,currentDepth},For[k=0,k<numOfIterations,k++,
thepool = init;
For[currentDepth=0, currentDepth< totalDepth, currentDepth = currentDepth+depthEachTime, 
{thepool,choices,problast}=executeGrammar[gr,thepool,depthEachTime,debug,saveChoices];

(*Print["guy post execute"];Print[choices];Print[problast];Print[Cases[thepool, _NullElement]];Print[thepool];*)

plot2Dgrammar[ Cases[thepool, _star], Cases[thepool, _blobPos],True ,True];
plot2Dgrammar[ Cases[thepool, _star], Cases[thepool, _blobPos],False,False];

If[currentDepth  !=  0 ,
If[Length[thepool] == Length[lastthepool],
Print["no change in the Pool"];
Break[];
];
];

lastthepool = thepool;

];



]]


iterativeExecuteGraphGrammar[gr_Grammar,init_,totalDepth_, depthEachTime_,saveChoices_, numOfIterations_,inMaxSimulationTime_]:=
Module[ {thepool,choices,problast,k,currentDepth,res,curtime},For[k=0,k<numOfIterations,k++,
thepool = init;
curtime = 0;

gMaxSimulationTime = inMaxSimulationTime;

prevGrammar = Null;
For[currentDepth=0, currentDepth<  totalDepth, currentDepth = currentDepth+depthEachTime, 
resGrammar=executeGrammar[gr,thepool,depthEachTime,saveChoices];

If[prevGrammar=!= Null,
resGrammar[[2]] = Flatten[Append[prevGrammar[[2]],resGrammar[[2]]]];
];
prevGrammar = resGrammar;

thepool = resGrammar[[1]];

Print["depth = ",currentDepth+depthEachTime];
(*Print["thepool = ",thepool];*)

curtime += resGrammar[[4]];

Print["Stochastic Process virtual time = ",curtime, " num iterations = ",currentDepth+depthEachTime];


nodesArr= Cases[thepool, _node];
edgesArr = Cases[thepool, _edge];
indexedEdgeArr = edgesArr;

MapIndexed[Function[{curNode,indexNode},

MapIndexed[Function[{curEdge,indexEdge},

If[curEdge[[1]] === curNode[[1]],
indexedEdgeArr[[indexEdge[[1]],1]] = indexNode[[1]]];

If[curEdge[[2]] === curNode[[1]],
indexedEdgeArr[[indexEdge[[1]],2]] = indexNode[[1]]];

],edgesArr];


],nodesArr];

indexedEdgeArr = Flatten[Map[Function[{curedge},If[Head[curedge[[1]]]=== Integer && Head[curedge[[2]]]=== Integer,curedge,{}] ],indexedEdgeArr]];

Show[Graphics[

Flatten[{Map[Function[{curEdge},

Line[{{nodesArr[[curEdge[[1]],2]],nodesArr[[curEdge[[1]],3]]},{nodesArr[[curEdge[[2]],2]],nodesArr[[curEdge[[2]],3]]}}]

],indexedEdgeArr],
Map[Function[{curNode},
(*If[Head[curNode[[1]]] === grammarDynamicObjID,
Text["g"<>ToString[curNode[[1,1]]],{curNode[[2]],curNode[[3]]}],
Text[curNode[[1]],{curNode[[2]],curNode[[3]]}]
]*)
{RGBColor[0,0,0],Disk[{curNode[[2]],curNode[[3]]},0.05]}
],nodesArr],{{RGBColor[1,1,1],Disk[{2,2},0.01]},{RGBColor[1,1,1],Disk[{-2,2},0.01]},{RGBColor[1,1,1],Disk[{2,-2},0.01]},{RGBColor[1,1,1],Disk[{-2,-2},0.01]}}},1],(*,AspectRatio->Automatic*)Frame->True]];


lastthepool = thepool;

If[curtime> gMaxSimulationTime,
Break[];
];

];

]]



iterativeExecuteTreeGraphGrammar[gr_Grammar,init_,totalDepth_, debug_,saveChoices_, numOfIterations_,bDoSimulationUntilExactSizeTree_]:=
Module[ {thepool,choices,problast,k,currentDepth},

gIsTreeGraphGrammarExec=True;

Print["deftotalnumTreeNodes = ",deftotalnumTreeNodes];
If[gr===gTreeStrctGeneratorLimited,
Print["Limited Tree Grammar version"];
,
Print["Regular Tree Grammar version"];
];

glDoSimulationUntilExactSizeTree = bDoSimulationUntilExactSizeTree;

gMaxNumberOfTreeNode = deftotalnumTreeNodes;
If[gr ===gTreeStrctGeneratorLimited,
gMaxNumberOfTreeNode = \[Infinity];
];

iNumFailedExecs=0;

For[iExpNum=0,iExpNum<numOfIterations,iExpNum++,
thepool = init;
grammarNumberOfDynamicObjID = 0;

{thepool,choices,problast}=executeGrammar[gr,thepool,totalDepth,debug,saveChoices];

(*Print["thepool = ",thepool];*)

(*the tree node is : tnode[nodeid,parentnodeid,posX,posY]*)

nodesArr= Cases[thepool, _tnode];

TotalNumTrNodes = Length[nodesArr];
(*Print[" The total number of Tree nodes = ",TotalNumTrNodes];*)

If[TotalNumTrNodes ==  deftotalnumTreeNodes,

Print[ "number failed Executions = ",iNumFailedExecs];
iNumFailedExecs=0;

linesArr = Flatten[MapIndexed[Function[{curNode,indexNode},

curLine = {};
MapIndexed[Function[{curNode2,indexNode2},

If[curNode[[2]] === curNode2[[1]],
(*curNode2 is the parent of curNode*)
curLine = Line[{{curNode2[[3]],curNode2[[4]]},{curNode[[3]],curNode[[4]]}}];

];

],nodesArr];

curLine
],nodesArr]];


Show[Graphics[

Flatten[{linesArr,
Map[Function[{curNode},

If[curNode[[1]] === TREEROOTNODE,
Text["T",{curNode[[3]],curNode[[4]]}],
Text["g"<>ToString[curNode[[1,1]]],{curNode[[3]],curNode[[4]]}]
]

],nodesArr]},1]
(*,AspectRatio->Automatic*)]];


lastthepool = thepool;

(* now  we print the tree in the formal shape . We obtain this shape by printing the children nodes accordig to decreasing order of subtree height , decreasing order of # childern per node , decreasing order of # nodes in subtree*)

arrTreeNodeLevel = Table[0,{Length[nodesArr]}];
arrTreeParentalLinks = Table[0,{Length[nodesArr]}];

MapIndexed[Function[{curNode,indexNode},

MapIndexed[Function[{curNode2,indexNode2},

If[curNode[[2]] === curNode2[[1]],
(*curNode2 is the parent of curNode*)

If[curNode2[[1]] === TREEROOTNODE,
arrTreeParentalLinks[[curNode[[1,1]]+1]] = 1;
,
arrTreeParentalLinks[[curNode[[1,1]]+1]] = curNode2[[1,1]]+1;
];

];

],nodesArr];
],nodesArr];

MapIndexed[Function[{trParent,indexOfTreeNode},
If[indexOfTreeNode[[1]]>1,
arrTreeNodeLevel[[indexOfTreeNode[[1]] ]] = arrTreeNodeLevel[[trParent]]+1;
];

 ],arrTreeParentalLinks];

treeHeight = Max[arrTreeNodeLevel];

arrNodeNumberOfChildren = Table[0,{Length[arrTreeNodeLevel]}];
arrSubTreeNodeHeight = Table[0,{Length[arrTreeNodeLevel]}];
arrNodeNumberOfDescendents = Table[0,{Length[arrTreeNodeLevel]}];

For[indexOfNode=Length[arrTreeNodeLevel] , indexOfNode>= 1 , indexOfNode--,

If[indexOfNode>1,
arrNodeNumberOfChildren[[arrTreeParentalLinks[[indexOfNode]]]]++;

If[arrSubTreeNodeHeight[[arrTreeParentalLinks[[indexOfNode]]]] < arrSubTreeNodeHeight[[indexOfNode]]+1,
arrSubTreeNodeHeight[[arrTreeParentalLinks[[indexOfNode]]]] = arrSubTreeNodeHeight[[indexOfNode]]+1;
];

arrNodeNumberOfDescendents[[indexOfNode]]++;

arrNodeNumberOfDescendents[[arrTreeParentalLinks[[indexOfNode]]]] +=  arrNodeNumberOfDescendents[[indexOfNode]];

,
arrNodeNumberOfDescendents[[indexOfNode]]++;
];

];


arrTreeNodesOrdering = MapThread[Function[{elem1,elem2,elem3},
{elem1,elem2,elem3}
],{arrSubTreeNodeHeight,arrNodeNumberOfChildren,arrNodeNumberOfDescendents}];


(*now we actually create the tree according to the orderings*)

(*each node element have a- index in the arrays , b- position in the output display , c- range that it can spread his children on the x coordinate *)
graphicsLinesArr = {};
graphicsNodesArr = {};
nodesStack={{1,{0,0},10}};
While[Length[nodesStack]>0,


curHeadNode = nodesStack[[1]];
(*now remove the head element from the stack*)
If[Length[nodesStack]<=1,
nodesStack={};
,
nodesStack = nodesStack[[Range[2,Length[nodesStack]]]];
];

posCurNodeChildrenArr = Flatten[Position[arrTreeParentalLinks,curHeadNode[[1]] ]];

sortedPosCurNodeChildrenArr = Sort[posCurNodeChildrenArr,
arrTreeNodesOrdering[[#1,1]]>arrTreeNodesOrdering[[#2,1]] || 
(arrTreeNodesOrdering[[#1,1]]==arrTreeNodesOrdering[[#2,1]] && arrTreeNodesOrdering[[#1,2]]>arrTreeNodesOrdering[[#2,2]]) ||
(arrTreeNodesOrdering[[#1,1]]==arrTreeNodesOrdering[[#2,1]] && arrTreeNodesOrdering[[#1,2]]==arrTreeNodesOrdering[[#2,2]] && arrTreeNodesOrdering[[#1,3]]>= arrTreeNodesOrdering[[#2,3]])&];

curNodeNumChildren = Length[sortedPosCurNodeChildrenArr];

If[curNodeNumChildren>0,

rangeXCoordForEachChild = curHeadNode[[3]]/curNodeNumChildren;
xCoordForFirstChild = curHeadNode[[2,1]] + curHeadNode[[3]]/2 - rangeXCoordForEachChild/2;
xCoordForNextChild = xCoordForFirstChild;

xCoordChildrenArr = Table[xCoordForCurChild = xCoordForNextChild; xCoordForNextChild -= rangeXCoordForEachChild; xCoordForCurChild  , {i,1,curNodeNumChildren}];

childrenNodesElemesArr = MapThread[Function[{srtposCurNodeChild,xCoordCh},

{srtposCurNodeChild,{xCoordCh,curHeadNode[[2,2]]-2},rangeXCoordForEachChild}

],{sortedPosCurNodeChildrenArr,xCoordChildrenArr}];

linesArr = Map[Function[{chNodeelem},

Line[{{curHeadNode[[2,1]],curHeadNode[[2,2]]},{chNodeelem[[2,1]],chNodeelem[[2,2]]}}]

],childrenNodesElemesArr];

graphicsLinesArr = Flatten[{graphicsLinesArr,linesArr}];

nodesStack = Flatten[{nodesStack,childrenNodesElemesArr},1];

];


graphicsNodesArr = Flatten[{graphicsNodesArr,
(*If[curHeadNode[[1]]==1,
Text["T",{curHeadNode[[2,1]],curHeadNode[[2,2]]}],

Text["g"<>ToString[curHeadNode[[1]]-1],{curHeadNode[[2,1]],curHeadNode[[2,2]]}]
]
*)

Text["o",{curHeadNode[[2,1]],curHeadNode[[2,2]]}]

}];



];


Show[Graphics[

Flatten[{graphicsLinesArr,
graphicsNodesArr
},1]
(*,AspectRatio->Automatic*)]];

,
iNumFailedExecs++;
If[Mod[iNumFailedExecs,100]==0,
Print["Experiment ",iExpNum ," failed ",iNumFailedExecs];
];

iExpNum--;
];
];
];


experimentTreeGraphGrammarManage[ totalDepth_,debug_,saveChoices_,numOfTreeSizes_,numOfSamplesPerTreeSize_]:=
Module[{},

glDoSimulationUntilExactSizeTree = True;

gIsTreeGraphGrammarExec=True;

Print["Start gTreeStrctGenerator experiment"];

deftotalnumTreeNodes = numOfTreeSizes;

ArrTreeHeight = Table[Table[0,{numOfSamplesPerTreeSize}],{numOfTreeSizes}];
ArrNumNodesInEachLevel = Table[Table[0,{numOfSamplesPerTreeSize}],{numOfTreeSizes}];
ArravgNumChildrenInEachLevel =  Table[Table[0,{numOfSamplesPerTreeSize}],{numOfTreeSizes}];

ArrCurrentIndexOfTreeSize = Table[0,{numOfTreeSizes}];

gMaxNumberOfTreeNode = deftotalnumTreeNodes;
(*REMARK - the question is if we stop the grammar after generating the required number of tree nodes then we still generate trees from the P (tree|defualtNumNodes) distribution . *)
experimentTreeGraphGrammar[gTreeStrctGenerator,{start}, totalDepth,debug,saveChoices,numOfSamplesPerTreeSize,deftotalnumTreeNodes, False];

ArrTreeHeight1 = ArrTreeHeight;
ArrNumNodesInEachLevel1 = ArrNumNodesInEachLevel;
ArravgNumChildrenInEachLevel1 =  ArravgNumChildrenInEachLevel;
ArrCurrentIndexOfTreeSize1 = ArrCurrentIndexOfTreeSize;

Print["End gTreeStrctGenerator experiment"];

Print["Start gTreeStrctGeneratorLimited experiment"];

ArrTreeHeight = Table[Table[0,{numOfSamplesPerTreeSize}],{numOfTreeSizes}];
ArrNumNodesInEachLevel = Table[Table[0,{numOfSamplesPerTreeSize}],{numOfTreeSizes}];
ArravgNumChildrenInEachLevel =  Table[Table[0,{numOfSamplesPerTreeSize}],{numOfTreeSizes}];

ArrCurrentIndexOfTreeSize = Table[0,{numOfTreeSizes}];


For[indexNumTreeNodes=5,indexNumTreeNodes<= numOfTreeSizes , indexNumTreeNodes++,

(*we have to reproduce the grammar since deftotalnumTreeNodes has changed*)
deftotalnumTreeNodes = indexNumTreeNodes;
curGrammer = gTreeStrctGeneratorLimited;

Print["Start gTreeStrctGeneratorLimited for Tree size = ",deftotalnumTreeNodes];

gMaxNumberOfTreeNode = \[Infinity];

experimentTreeGraphGrammar[curGrammer,{start},totalDepth,debug,saveChoices,numOfSamplesPerTreeSize,deftotalnumTreeNodes, True];

Print["Finish gTreeStrctGeneratorLimited for Tree size = ",deftotalnumTreeNodes];
];

ArrTreeHeight2 = ArrTreeHeight;
ArrNumNodesInEachLevel2 = ArrNumNodesInEachLevel;
ArravgNumChildrenInEachLevel2 =  ArravgNumChildrenInEachLevel;
ArrCurrentIndexOfTreeSize2 = ArrCurrentIndexOfTreeSize;

Print["End gTreeStrctGeneratorLimited experiment"]

];


MAXNUMITERATIONS = 1000000;


experimentTreeGraphGrammar[gr_Grammar,init_,totalDepth_, debug_,saveChoices_,numOfSamplesPerTreeSize_,maxTreeSize_, bOnlySingleTreeSize_]:=
Module[ {thepool,choices,problast,k,currentDepth},

iNumFailedExecs=0;

For[iExpNum=1,iExpNum<= MAXNUMITERATIONS,iExpNum++,
thepool = init;
grammarNumberOfDynamicObjID = 0;

If[(bOnlySingleTreeSize && ArrCurrentIndexOfTreeSize[[maxTreeSize]] >= numOfSamplesPerTreeSize) || 
(!bOnlySingleTreeSize && Apply[Plus,ArrCurrentIndexOfTreeSize] >= numOfSamplesPerTreeSize*maxTreeSize),
Print["Finish experimentTreeGraphGrammar success"];
Return[];
];

{thepool,choices,problast}=executeGrammar[gr,thepool,totalDepth,debug,saveChoices];

(*Print["depth = ",currentDepth+depthEachTime];*)
(*Print["thepool = ",thepool];*)

(*the tree node is : tnode[nodeid,parentnodeid,posX,posY]*)

nodesArr= Cases[thepool, _tnode];

TotalNumTrNodes = Length[nodesArr];
(*Print[" The total number of Tree nodes = ",TotalNumTrNodes];*)

If[Mod[iExpNum,1000]==0,
Print["iExpNum = ",iExpNum];
Print["TotalNumTrNodes = ",TotalNumTrNodes];
Print["ArrCurrentIndexOfTreeSize = ",ArrCurrentIndexOfTreeSize];
];

If[(TotalNumTrNodes <= maxTreeSize && !bOnlySingleTreeSize) || (TotalNumTrNodes == maxTreeSize && bOnlySingleTreeSize),

If [ArrCurrentIndexOfTreeSize[[TotalNumTrNodes]] < numOfSamplesPerTreeSize,
ArrCurrentIndexOfTreeSize[[TotalNumTrNodes]]++;

currentIndexOfTreeSize = ArrCurrentIndexOfTreeSize[[TotalNumTrNodes]];

iNumFailedExecs = 0;

arrTreeNodeLevel = Table[0,{Length[nodesArr]}];
arrTreeParentalLinks = Table[0,{Length[nodesArr]}];

MapIndexed[Function[{curNode,indexNode},

MapIndexed[Function[{curNode2,indexNode2},

If[curNode[[2]] === curNode2[[1]],
(*curNode2 is the parent of curNode*)

If[curNode2[[1]] === TREEROOTNODE,
arrTreeParentalLinks[[curNode[[1,1]]+1]] = 1;
,
arrTreeParentalLinks[[curNode[[1,1]]+1]] = curNode2[[1,1]]+1;
];

];

],nodesArr];
],nodesArr];

MapIndexed[Function[{trParent,indexOfTreeNode},
If[indexOfTreeNode[[1]]>1,
arrTreeNodeLevel[[indexOfTreeNode[[1]] ]] = arrTreeNodeLevel[[trParent]]+1;
];

 ],arrTreeParentalLinks];

treeHeight = Max[arrTreeNodeLevel];
ArrTreeHeight[[TotalNumTrNodes,currentIndexOfTreeSize]] = treeHeight;


(*number of nodes in each tree level*)
curarrNumNodesInEachLevel = Table[
Count[arrTreeNodeLevel,i]
,{i,0,treeHeight}];

ArrNumNodesInEachLevel[[TotalNumTrNodes,currentIndexOfTreeSize]]  = curarrNumNodesInEachLevel;
ArravgNumChildrenInEachLevel[[TotalNumTrNodes,currentIndexOfTreeSize]] = curarrNumNodesInEachLevel[[Range[1,treeHeight]]]/curarrNumNodesInEachLevel[[Range[2,treeHeight+1]]];

(*
linesArr = Flatten[MapIndexed[Function[{curNode,indexNode},

curLine = {};
MapIndexed[Function[{curNode2,indexNode2},

If[curNode[[2]] === curNode2[[1]],
(*curNode2 is the parent of curNode*)
curLine = Line[{{curNode2[[3]],curNode2[[4]]},{curNode[[3]],curNode[[4]]}}];

];

],nodesArr];

curLine
],nodesArr]];

Show[Graphics[

Flatten[{linesArr,
Map[Function[{curNode},
If[curNode[[1]] === TREEROOTNODE,
Text["T",{curNode[[3]],curNode[[4]]}],
Text["g"<>ToString[curNode[[1,1]]],{curNode[[3]],curNode[[4]]}]
]

],nodesArr]},1]
(*,AspectRatio->Automatic*)]];
*)

lastthepool = thepool;

];
,
iNumFailedExecs++;
If[Mod[iNumFailedExecs,1000]==0,
Print["Experiment ",iExpNum ," failed ",iNumFailedExecs];
];

];

];

Print["Finish experimentTreeGraphGrammar failed"]
]


plotSierpinskiGasket[p_List]:= Module[{}, 
Show[
Graphics[Map[Line[{#[[1]],
#[[2]],
#[[3]],
#[[1]]
}]&,p],{\!\(TraditionalForm\`Axes\)->True,ImageSize->{250,250}}]]]


(*plotSierpinskiGasket3D[p_List]:= Module[{}, Show[
Graphics3D[Map[Line[{#[[1]],
#[[2]],
#[[3]],
#[[4]],
#[[1]],
#[[5]],
#[[2]],
#[[3]],
#[[5]],
#[[4]]
}]&,p],{Axes->True,ImageSize->{250,250}}]]]*)

plotSierpinskiGasket3DPyramid[p_List]:= Module[{polygons},
polygons = Map[{
Polygon[{#[[1]],#[[2]],#[[3]],#[[4]]}],
Polygon[{#[[1]],#[[2]],#[[5]]}],
Polygon[{#[[2]],#[[3]],#[[5]]}],
Polygon[{#[[3]],#[[4]],#[[5]]}],
Polygon[{#[[4]],#[[1]],#[[5]]}]}&,p];

 Show[
Graphics3D[polygons,{\!\(TraditionalForm\`Axes\)->True,ImageSize->{250,250}}]]]


plotSierpinskiGasket3DCube[p_List]:= Module[{polygons},
polygons = Map[{
Polygon[{#[[1]],#[[2]],#[[3]],#[[4]]}],
Polygon[{#[[5]],#[[6]],#[[7]],#[[8]]}],
Polygon[{#[[1]],#[[2]],#[[6]],#[[5]]}],
Polygon[{#[[2]],#[[3]],#[[7]],#[[6]]}],
Polygon[{#[[3]],#[[4]],#[[8]],#[[7]]}],
Polygon[{#[[4]],#[[1]],#[[5]],#[[8]]}]
}&,p];

 Show[
Graphics3D[polygons,{\!\(TraditionalForm\`Axes\)->True,ImageSize->{250,250}}]]]


iterativeExecuteSierpinskiGasketTriangle[gr_Grammar,init_,depth_,debug_,saveChoices_, numOfIterations_]:=Module[ {thepool,choices,problast,k},For[k=0,k<numOfIterations,k++,{thepool,choices,problast}=executeGrammar[gr,init,depth,debug,saveChoices];(*Print[thepool];Print[choices];Print[problast];*)
plotSierpinskiGasket[ Cases[thepool, _drawtriangle] ]]]


iterativeExecuteSierpinskiGasketPyramid[gr_Grammar,init_,depth_,debug_,saveChoices_, numOfIterations_]:=Module[ {thepool,choices,problast,k},For[k=0,k<numOfIterations,k++,{thepool,choices,problast}=executeGrammar[gr,init,depth,debug,saveChoices];(*Print[thepool];Print[choices];Print[problast];*)
plotSierpinskiGasket3DPyramid[ Cases[thepool, {_cube,_pyramid}] ]]]


iterativeExecuteSierpinskiGasketCube[gr_Grammar,init_,depth_,debug_,saveChoices_, numOfIterations_]:=Module[ {thepool,choices,problast,k},For[k=0,k<numOfIterations,k++,{thepool,choices,problast}=executeGrammar[gr,init,depth,debug,saveChoices];(*Print[thepool];Print[choices];Print[problast];*)
plotSierpinskiGasket3DCube[ Cases[thepool, _cube] ]]]


plot3DGraphicalStruct[p_List]:= Module[{tempList}, 

tempList = Map[{{#[[2]],#[[3]]},Cases[p,node[_,_,_,#[[1]]]]}&,p];

tempList = DeleteCases[tempList,{_,{}}];


tempList = Map[Line[{#[[1]],{#[[2,1,2]],#[[2,1,3]]}}]&,tempList];

Show[
Graphics[tempList,{\!\(TraditionalForm\`Axes\)->True,ImageSize->{250,250}}]]]



FindReferencenList[name_,p_List] :=  Module[{},
Cases[p,node[_,name,_]]
]


iterativeExecuteGraphicalStruct3D[gr_Grammar,init_,depth_,debug_,saveChoices_, numOfIterations_]:=Module[ {thepool,choices,problast,k},For[k=0,k<numOfIterations,k++,{thepool,choices,problast}=executeGrammar[gr,init,depth,debug,saveChoices];(*Print[thepool];Print[choices];Print[problast];*)
plot3DGraphicalStruct[ Cases[thepool, _node] ]]]


executeItemGrammar[gr_Grammar,init_,depth_,saveChoices_,numIterations_,simStopCriteriaArr_(*by default should be empty list*)]:=Module[{res,index,curtime,curiter},
curpool=init;
curiter = curtime=0;
For[index = 1, index<= numIterations,index++,

res = executeGrammar[gr,curpool,depth,saveChoices,simStopCriteriaArr];

curpool = res[[1]];
curtime += res[[4]];
curiter +=res[[5]];
Print["Stochastic Process virtual time = ",curtime, " num iterations = ",curiter];

itemList = Apply[List,Cases[curpool, _item],{0,1}];
itemList = itemList[[All,Range[3,4]]];
ListPlot[itemList,Axes->False];
ListPlot[itemList,Axes->True];
(*
discList = Map[Function[{item},
{RGBColor[0,0,0],Disk[{item[[1]],item[[2]]},0.1*item[[3]]]}
],itemList];

Show[Graphics[discList,AspectRatio->Automatic,Frame->True,Axes->True]];
*)
];
];


executeObjectsGrammar[gr_Grammar,init_,depth_,saveChoices_,numIterations_]:=Module[{res,index,curtime,curiter,objList,discList},
curpool=init;
curiter = curtime=0;
For[index = 1, index<= numIterations,index++,

res = executeGrammar[gr,curpool,depth,saveChoices];

curpool = res[[1]];
curtime += res[[4]];
curiter +=res[[5]];
Print["Stochastic Process virtual time = ",curtime, " num iterations = ",curiter];
objList = Apply[List,Cases[curpool, _object],{0,1}];
(*object[tyep,locX,locY,subObj]*)
discList = Map[Function[{obj},{RGBColor[If[obj[[1]] == 1 ,1,0],If[obj[[1]] == 2 ,1,0],If[obj[[1]] == 3 ,1,0]],Disk[{obj[[2]],obj[[3]]},0.1*obj[[4]]]}],objList];

Show[Graphics[Flatten[{discList,{RGBColor[1,1,1],Point[{-5,-5}]},{RGBColor[1,1,1],Point[{5,5}]}},1],AspectRatio->Automatic,Frame->True,Axes->False]];
];
]


executeStarsGrammar[gr_Grammar,init_,depth_,saveChoices_,numIterations_]:=Module[{res,index,curtime,curiter},
curpool=init;
curiter = curtime=0;
For[index = 1, index<= numIterations,index++,

res = executeGrammar[gr,curpool,depth,saveChoices];

curpool = res[[1]];
curtime += res[[4]];
curiter +=res[[5]];
Print["Stochastic Process virtual time = ",curtime, " num iterations = ",curiter];
ListPlot[Apply[List,Cases[curpool, _star],{0,1}],Axes->False];
];
]


executeSTrianglGrammar[gr_Grammar,init_,depth_,saveChoices_,numIterations_]:=Module[{res,index,curtime,curiter,triArr,subTriIndexesArr,rootIndex,curTopTri,lineArr,curSubtri,geoPosSubTri,lowerMidPoint,leftMidPoint,rightMidPoint},
curpool=init;
curiter = curtime=0;
For[index = 1, index<= numIterations,index++,

res = executeGrammar[gr,curpool,depth,saveChoices];

curpool = res[[1]];
curtime += res[[4]];
curiter +=res[[5]];
Print["Stochastic Process virtual time = ",curtime, " num iterations = ",curiter];

triArr = Apply[List,Cases[curpool,_triangle],{0,1}];

(*triangle[triID,parentID,subTriSide]*)
subTriIndexesArr = Map[Function[{curTri},
Flatten[Position[triArr,{_,curTri[[1]],_}]]

],triArr];

(*find the root node*)
MapIndexed[Function[{curTri,indexTri},If[curTri[[2]] === parentROOT, rootIndex = indexTri[[1]];]; ],triArr];

lineArr = {};

queueTri = { {rootIndex,(*geometric position*){ {-1,0},{1,0},{0,1}}} };
AppendTo[lineArr,Line[Append[queueTri[[1,2]],queueTri[[1,2,1]]]]];

While[Length[queueTri]>0,
curTopTri = queueTri[[1]];
queueTri = Delete[queueTri,1];

lowerMidPoint = (curTopTri[[2,1]]+curTopTri[[2,2]])/2;
leftMidPoint = (curTopTri[[2,1]]+curTopTri[[2,3]])/2;
rightMidPoint = (curTopTri[[2,2]]+curTopTri[[2,3]])/2;


(*add the lines*)
AppendTo[lineArr,Line[{lowerMidPoint,leftMidPoint,rightMidPoint,lowerMidPoint}]];
(*AppendTo[lineArr,Line[Append[curTopTri[[2]],curTopTri[[2,1]]]]];*)

(*add the sb triangles*)
Map[Function[{subtriIndex},

curSubtri = triArr[[subtriIndex]];

(*now position according to the side of the triangle*)


If[curSubtri[[3]] == 1,
geoPosSubTri = {curTopTri[[2,1]],lowerMidPoint,leftMidPoint};
];
If[curSubtri[[3]]==2,
geoPosSubTri={lowerMidPoint,curTopTri[[2,2]],rightMidPoint};
];
If[curSubtri[[3]]==3,
geoPosSubTri={leftMidPoint,rightMidPoint,lowerMidPoint};
];
If[curSubtri[[3]]==4,
geoPosSubTri={leftMidPoint,rightMidPoint,curTopTri[[2,3]]};
];

AppendTo[queueTri,{subtriIndex,geoPosSubTri}];


],subTriIndexesArr[[curTopTri[[1]]]]];

];

Show[Graphics[lineArr(*,AspectRatio->Automatic,Frame->True,Axes->False*)]];
];
]


executeGraphGrammar[gr_Grammar,init_,depth_,saveChoices_,numIterations_]:=Module[{res,index,curtime,curiter,lineArr,nodeArr,edgeArr,curNbrNode},
curpool=init;
curiter = curtime=0;
gBStartNewSimulation = True;
For[index = 1, index<= numIterations,index++,

res = executeGrammar[gr,curpool,depth,saveChoices];

gBStartNewSimulation = False;

curpool = res[[1]];
curtime += res[[4]];
curiter +=res[[5]];
Print["Stochastic Process virtual time = ",curtime, " num iterations = ",curiter];

(*node[nID1,x1,y1], edge[nID1,nID2]*)
nodeArr = Apply[List,Cases[curpool,_node],{0,1}];
edgeArr = Apply[List,Cases[curpool,_edge],{0,1}];

(*Print["nodeArr = ",nodeArr];
Print["edgeArr = ",edgeArr];
*)
lineArr = Flatten[Map[Function[{curNode},

Map[Function[{curNbr},

curNbrNode = Cases[nodeArr,{curNbr,_,_}][[1]];

Line[{curNode[[Range[2,3]]],curNbrNode[[Range[2,3]]]}]
],Cases[edgeArr,{curNode[[1]],_}][[All,2]]]
],nodeArr]];


Show[Graphics[lineArr,Frame->True(*,AspectRatio->Automatic,Frame->True,Axes->False*)]];
Show[Graphics[lineArr,Frame->True,AspectRatio->Automatic(*,AspectRatio->Automatic,Frame->True,Axes->False*)]];
];

]


executeAnabaenaGrammar[gr_Grammar,init_,depth_,saveChoices_,numIterations_,negihborsIndexes_,parametersIndexes_]:=Module[{res,index,curtime,curiter,arrCellVeg,arrCellHet,arrCells,arrSortedCells,curNbrID,cuPos,nextPos,arrVegCellBars,arrHetCellBars,arrCellBars},
curpool=init;
curiter = curtime=0;
gBStartNewSimulation = True;


For[index = 1, index<= numIterations,index++,

res = executeGrammar[gr,curpool,depth,saveChoices,maxDerivationTimeBetweenSimSteps-> 10];

gBStartNewSimulation = False;

curpool = res[[1]];
curtime += res[[4]];
curiter +=res[[5]];
Print["Stochastic Process virtual time = ",curtime, " num iterations = ",curiter];

Print["curpool = ",curpool];

arrCellVeg = Map[#[[1]] &,Cases[curpool,_cellTypeVeg]];
arrCellHet = Map[#[[1]] &,Cases[curpool,_cellTypeHet]];

If[debug,Print["arrCellVeg = ",arrCellVeg];
Print["arrCellHet = ",arrCellHet];
];

If[Length[Intersection[arrCellVeg,arrCellHet]]>0,
Print["error  - some cell are veg and het!!!!!!"];
];

arrCells = Cases[curpool,_cell];

If[debug,Print["arrCells = ",arrCells];];

arrSortedCells = {};
curNbrID = noID;
For[indexCell = 1,indexCell<= Length[arrCells],indexCell++,

(*find the next cell in the list, we go from left to right, so we look for the node that its left nbr is curNbrID*)
Scan[Function[{curcell},If[curcell[[negihborsIndexes[[1]]]] === curNbrID,AppendTo[arrSortedCells,curcell];curNbrID = curcell[[1]] ]],arrCells];
];
If[debug,Print["arrSortedCells = ",arrSortedCells];];

Map[Function[{curParamIndex},
cuPos = 0;
nextPos = 0;
arrCellBars=Map[Function[{curbar},cuPos = nextPos+curbar[[2]]/2;nextPos +=curbar[[2]]; {curbar[[1]],cuPos,curbar[[curParamIndex]],curbar[[2]]}],arrSortedCells];
If[debug,Print["arrCellBars = ",arrCellBars];];

arrVegCellBars = Map[Function[{curcellid},
Flatten[Map[Function[{curcellBar},If[curcellid===curcellBar[[1]],{curcellBar[[2]],curcellBar[[3]],curcellBar[[4]]},{} ]],arrCellBars]]
],arrCellVeg];
arrHetCellBars = Map[Function[{curcellid},
Flatten[Map[Function[{curcellBar},If[curcellid===curcellBar[[1]],{curcellBar[[2]],curcellBar[[3]],curcellBar[[4]]},{} ]],arrCellBars]]
],arrCellHet];

If[debug,
Print["arrVegCellBars = ",arrVegCellBars];
Print["arrHetCellBars = ",arrHetCellBars];
];

GeneralizedBarChart[arrVegCellBars,arrHetCellBars];
],parametersIndexes];


];

]


convertGrammarToTreeGrammar[gr_Grammar]:=Module[{curRulesLst,newelement,rulesArr,curRuleID,curLHSRuleID,curRHSRuleID,curLHSRule,curRHSRule,lstTermsAndParams,curTermID,curTermParamID,totalRuleVbls,totalVblsElemens,paramVbls,withVbls,posInTotalRuleVars,withVarsTerms,subjecttoVbls,subjecttoVarsTerms,solvingVbls,solvingVarsTerms,dervVarsEqTerms,constraintsTerms},

curRulesLst = rules/.gr[[1]];
rulesArr = {};

newelement = {};
Map[Function[{curLstElem},

If[(Head[curLstElem]===Rule) || (Head[curLstElem]===RuleDelayed) || (Head[curLstElem]===DoubleRightArrow),(* this is a new rule*)

If[Length[newelement]>0,
AppendTo[rulesArr,newelement];
];

(*newelement={curLstElem, with,subjectto,solving};*)
newelement={curLstElem, 1,0,0};
];

If[(Head[curLstElem]===with),(* this is a new rule*)

newelement[[2]]=curLstElem[[1]];
];

If[(Head[curLstElem]===subjectto),(* this is a new rule*)

newelement[[3]]=Apply[List,curLstElem];
];

If[(Head[curLstElem]===solving),(* this is a new rule*)

newelement[[4]]=Apply[List,curLstElem];
];

],curRulesLst];

AppendTo[rulesArr,newelement];

Flatten[Map[Function[{curRule},
curRuleID = Unique[pRuleID];

curLHSRuleID = Unique[pLhsID];
curRHSRuleID = Unique[pRhsID];

curLHSRule = curRule[[1,1]];
curRHSRule = curRule[[1,2]];

If[Head[curLHSRule]=!= List,curLHSRule = {curLHSRule};];
If[Head[curRHSRule]=!= List,curRHSRule = {curRHSRule};];

totalRuleVbls=findVbls2[{curLHSRule,curRHSRule}];

(*create variables elements for all the variables*)
totalVblsElemens = Map[tRuleVar[curRuleID,Unique[pVarID],#]&,totalRuleVbls];

lstTermsAndParams = Flatten[MapThread[Function[{curRuleSideID,curRuleSide},

Map[Function[{curRTerm},

curTermID = Unique[pTermID];

{If[Length[curRTerm]>0,
MapIndexed[Function[{curTermParam,curTermParamIndex},
paramVbls = findVbls2[{curTermParam}];

posInTotalRuleVars = Flatten[Map[Position[totalRuleVbls,#]&,paramVbls]];

{Map[tParamVar[curTermParamIndex[[1]],curTermID,totalVblsElemens[[#,2]]]&,posInTotalRuleVars],
tParam[curTermParamIndex[[1]],curTermID,curTermParam]}
],Apply[List,curRTerm]],{}
],
tTerm[curTermID,curRuleSideID,If[Length[curRTerm]>0,Head[curRTerm],curRTerm]]
}
],curRuleSide]
],{{curLHSRuleID,curRHSRuleID},{curLHSRule,curRHSRule}}]];

withVbls = findVbls2[{curRule[[2]]}];
posInTotalRuleVars = Flatten[Map[Position[totalRuleVbls,#]&,withVbls]];
withVarsTerms = Map[tWithVar[curRuleID,totalVblsElemens[[#,2]]]&,posInTotalRuleVars];

subjecttoVbls = findVbls2[{curRule[[3]]}];
posInTotalRuleVars = Flatten[Map[Position[totalRuleVbls,#]&,subjecttoVbls]];
subjecttoVarsTerms = Map[tSubjectToVar[curRuleID,totalVblsElemens[[#,2]]]&,posInTotalRuleVars];

solvingVbls = findVbls2[{curRule[[4]]}];
posInTotalRuleVars = Flatten[Map[Position[totalRuleVbls,#]&,solvingVbls]];
solvingVarsTerms = Map[tSolvingVblsVar[curRuleID,totalVblsElemens[[#,2]]]&,posInTotalRuleVars];

(*analyze the constraints*)
If[curRule[[3]] =!= 0,
constraintsTerms = MapIndexed[Function[{curCont,curIndexConst},

tConstraint[curRuleID,curIndexConst[[1]],curCont]

],curRule[[3]]];
,
constraintsTerms = {};
];

(*analyze the solving section*)
If[curRule[[4]] =!= 0,
dervVarsEqTerms = MapIndexed[Function[{curDiffEq,curIndexDiffEq},

If[Head[curDiffEq[[1]]]===Derivative[1],

{tDervVar[curRuleID,curIndexDiffEq[[1]],totalVblsElemens[[Flatten[Position[totalRuleVbls,curDiffEq[[1,1]]]][[1]],2]]],tDervValue[curRuleID,curIndexDiffEq[[1]],curDiffEq[[2]]]}

,
Print["ERROR - invalid ODE input  ",curDiffEq];
]

],curRule[[4]]];
,
dervVarsEqTerms = {};
];

{tGrammarRule[curRuleID],tLhsRule[curLHSRuleID,curRuleID],tRhsRule[curRHSRuleID,curRuleID],lstTermsAndParams,totalVblsElemens,withVarsTerms,tWith[curRuleID,curRule[[2]]],subjecttoVarsTerms,constraintsTerms,solvingVarsTerms,dervVarsEqTerms}

],rulesArr]]
]


convertTreeGrammarToGrammar[inTreeGrammer_]:=Module[{gramRules,curLHSID,curRHSID,curRuleVars,curRuleConstarints,curRuleDervVars,curRuleDervValues,curRuleDervEq},

gramRules = Cases[inTreeGrammer,tGrammarRule[_]];

Grammar[rules->
Flatten[Map[Function[{curGramRule},

curRuleVars = Cases[inTreeGrammer,tRuleVar[curGramRule[[1]],_,_]];

curRuleConstarints = Cases[inTreeGrammer,tConstraint[curGramRule[[1]],_,_]];

If[Length[curRuleConstarints]>0,curRuleConstarints = Apply[subjectto,curRuleConstarints[[All,3]]];];

curRuleDervVars = Sort[Cases[inTreeGrammer,tDervVar[curGramRule[[1]],_,_]],#1[[2]]<#2[[2]]&];
curRuleDervValues =  Sort[Cases[inTreeGrammer,tDervValue[curGramRule[[1]],_,_]],#1[[2]]<#2[[2]]&];

curRuleDervEq = MapThread[Function[{dervvar,dervvalue},
Derivative[1][curRuleVars[[Flatten[Position[curRuleVars[[All,2]],dervvar[[3]]]][[1]],3]]] == dervvalue[[3]]
],{curRuleDervVars,curRuleDervValues}];

If[Length[curRuleDervEq]>0, curRuleDervEq = Apply[solving,curRuleDervEq];];

curLHSID = Cases[inTreeGrammer,tLhsRule[_,curGramRule[[1]]]][[1,1]];
curRHSID = Cases[inTreeGrammer,tRhsRule[_,curGramRule[[1]]]][[1,1]];

curLHSTerms = Cases[inTreeGrammer,tTerm[_,curLHSID,_]];
curRHSTerms = Cases[inTreeGrammer,tTerm[_,curRHSID,_]];

tempRule = Map[Function[{curTerm},

tempTerm = Apply[curTerm[[3]],Sort[Cases[inTreeGrammer,tParam[_,curTerm[[1]],_]],#1[[1]]<#2[[1]]&][[All,3]]];

If[Length[tempTerm]==0,Head[tempTerm],tempTerm]
 ],curLHSTerms]->
Map[Function[{curTerm},

tempTerm = Apply[curTerm[[3]],Sort[Cases[inTreeGrammer,tParam[_,curTerm[[1]],_]],#1[[1]]<#2[[1]]&][[All,3]]];

If[Length[tempTerm]==0,Head[tempTerm],tempTerm]
 ],curRHSTerms];

{tempRule,with[Cases[inTreeGrammer,tWith[curGramRule[[1]],_]][[1,2]]],curRuleConstarints,curRuleDervEq}

],gramRules]]
]

]


End[]


EndPackage[]
