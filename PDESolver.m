(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["PDESolver`"]


(*the stencil for 2 dimension:

(\[Placeholder]	u( x, y + h)
u( x - h, y )	-4 u( x, y )
\[Placeholder]	u( x, y - h )

\[Placeholder]
u( x + h, y )
\[Placeholder]

)
*)



(* Crank Nicolson Equation  - h- grid spacing,\[Tau] time spacing, d -diffusion const, k - decay const , s - source
*)
(* i - index on x axis , j-index on y axis , n - index over time axis
p=h^2/\[Tau] 

-d Subscript[u, n,i-1]-d Subscript[u, n,j-1]+Subscript[u, n,i](2p +4d+2h^2k)-d Subscript[u, n,i+1]-d Subscript[u, n,j+1]  =   d Subscript[u, n-1,i-1]+d Subscript[u, n-1,j-1]+Subscript[u, n-1,i](2p-4d )+d Subscript[u, n-1,i+1]+d Subscript[u, n-1,j+1]  + 2h^2 s

*)


pdeCrankNicolsonOneStep::"usage"="pdeCrankNicolsonOneStep[tblLHSEq_,currentGrid_,h_,deltaT_,diffConst_,decayConst_,inSourceGrid_,boundaryFunctionX_,boundaryFunctionY_,opt___?OptionQ]"


iniCrankNicolsonEquations::"usage"="iniCrankNicolsonEquations[iniGrid_,h_,deltaT_,diffConst_,decayConst_,boundaryTypefuncX_,boundaryTypefuncY_]"


pdeCrankNicolsonOneStep3::"usage"="pdeCrankNicolsonOneStep3[tblLHSEq_, currentGrid_, h_, deltaT_, diffConstGrid_,decayConstGrid_, inSourceGrid_, boundaryFunctionX_,boundaryFunctionY_, opt___?OptionQ] use here diffConstGrid, decayConstGrid for different decay/diff constants over space"


{gPDETypeDirichlet,gPDETypeNeumann} = Range[1,2];


pdeCrankNicolson[iniGrid_,h_,deltaT_,diffConst_,decayConst_,sourceFunc_,endTime_,boundaryTypefuncX_,boundaryFunctionX_,boundaryTypefuncY_,boundaryFunctionY_]:= Module[{arrGridsOverTime,currentGrid,gridMult,numGridPoints,numRows,numCols,matrix,loadVector},

gridMult = h^2/deltaT;

{numRows,numCols} = Dimensions[iniGrid];
numGridPoints = numRows*numCols;

matrix=Table[ 0.0,{ numGridPoints }, { numGridPoints }  ];


Do[ 
(*check if its not in the first or last col*)
If[ Mod[ pos-1, numCols ] != 0 && Mod[ pos , numCols ] != 0 , 

matrix[[ pos , {pos - 1,pos + 1,pos + numCols,pos - numCols} ]] = -diffConst;

matrix[[ pos, pos ]] = 2gridMult +4diffConst+2h^2decayConst;

] , { pos,numCols+2, numGridPoints-numCols } ];


(*handle boundary conditions*)
(*first row*)
Do[ matrix[[ pos, pos ]] = 1 , { pos,1, numCols } ];
If[boundaryTypefuncY[1] == gPDETypeNeumann,Do[ matrix[[ pos, pos+numCols ]] = -1 , { pos,1, numCols } ]];


(*last row*)
Do[ matrix[[ pos, pos ]] = 1 , { pos,numGridPoints -numCols+1, numGridPoints } ];
If[boundaryTypefuncY[numRows] == gPDETypeNeumann,Do[ matrix[[ pos, pos-numCols ]] = -1 , { pos,numGridPoints -numCols+1, numGridPoints } ]];

(*first col except the corners because they were defined by rows*)
Do[ matrix[[ pos, pos ]] = 1 , { pos,numCols+1, numGridPoints-numCols,numCols } ];
If[boundaryTypefuncX[1] == gPDETypeNeumann,Do[ matrix[[ pos, pos +1]] = -1 , { pos,numCols+1, numGridPoints-numCols,numCols } ]];


(*last col except the corners because they were defined by rows*)
Do[ matrix[[ pos, pos ]] = 1 , { pos,2numCols, numGridPoints-numCols,numCols } ];
If[boundaryTypefuncX[numCols] == gPDETypeNeumann,Do[ matrix[[ pos, pos -1]] = -1 , { pos,2numCols, numGridPoints-numCols,numCols } ]];


(*run over each time step and solve the equations to get a new grid*)
currentGrid = iniGrid;
arrGridsOverTime = Table[

currentGrid = solveCNcurTime[matrix,currentGrid,curTime,h,diffConst,gridMult,sourceFunc,boundaryFunctionX,boundaryFunctionY];

currentGrid
,{curTime,deltaT,endTime,deltaT}];

Prepend[arrGridsOverTime,iniGrid]
]


solveCNcurTime[matrix_,currentGrid_,curTime_,h_,diffConst_,gridMult_,sourceFunc_,boundaryFunctionX_,boundaryFunctionY_]:=Module[{numRows,numCols,loadVector,newGrid,numericalSolution},


{numRows,numCols} = Dimensions[currentGrid];

loadVector=Table[ 0.0, { Length[matrix[[1]]]} ];

Do[
loadVector[[ x + ( y -1 )*numCols ]] = diffConst (currentGrid[[y,x-1]]+currentGrid[[y,x+1]]+currentGrid[[y,x]]+currentGrid[[y,x]])+ currentGrid[[y,x]]*(2gridMult-4diffConst );
, { y, 2, numRows-1  }, { x, 2, numCols-1  } ];

loadVector += 2h^2 sourceFunc[curTime];

(*handle boundary conditions*)
Do[
loadVector[[ x ]] = boundaryFunctionY[1];
loadVector[[ x + ( numRows -1 )*numCols ]] = boundaryFunctionY[numRows];
, { x, 1, numCols  } ];

Do[
loadVector[[ 1 + ( y -1 )*numCols ]] = boundaryFunctionX[1];
loadVector[[ y*numCols ]] = boundaryFunctionX[numCols];
, { y, 1, numRows  } ];


numericalSolution = LinearSolve[ matrix, loadVector ];

newGrid = Partition[ numericalSolution, numCols ];


newGrid
]


(*this version there is no use of LinearSolve but Solve. We save for the number of variables, no need for N^2 matrix for all variables pairs.*)


pdeCrankNicolsonVer2[iniGrid_,h_,deltaT_,diffConst_,decayConst_,sourceFunc_,endTime_,boundaryTypefuncX_,boundaryFunctionX_,boundaryTypefuncY_,boundaryFunctionY_]:= Module[{tblLHSEq,arrGridsOverTime,currentGrid,gridMult,numGridPoints,numRows,numCols,loadVector},

gridMult = h^2/deltaT;

{numRows,numCols} = Dimensions[iniGrid];
numGridPoints = numRows*numCols;

tblLHSEq = Table[ 
If[i == 1,
u[i,j]+If[boundaryTypefuncY[1] == gPDETypeNeumann,-u[i+1,j],0]
,
If[i== numRows,
u[i,j]+If[boundaryTypefuncY[numRows] == gPDETypeNeumann,-u[i-1,j],0]
,
If[j== 1,
u[i,j]+If[boundaryTypefuncX[1] == gPDETypeNeumann,-u[i,j+1],0]
,
If[j== numCols,
u[i,j]+If[boundaryTypefuncX[numCols] == gPDETypeNeumann,-u[i,j-1],0]
,
(2gridMult +4diffConst+2h^2decayConst)u[i,j] -diffConst u[i-1,j] -diffConst u[i+1,j]-diffConst u[i,j-1]-diffConst u[i,j+1]
]
]
]
]
, { i,1, numRows } ,{ j,1, numCols }];


(*run over each time step and solve the equations to get a new grid*)
currentGrid = iniGrid;
arrGridsOverTime = Table[

currentGrid = solveCNcurTimeVer2[tblLHSEq,currentGrid,curTime,h,diffConst,gridMult,sourceFunc,boundaryFunctionX,boundaryFunctionY];

currentGrid
,{curTime,deltaT,endTime,deltaT}];

Prepend[arrGridsOverTime,iniGrid]
]


(* i - index on x axis , j-index on y axis , n - index over time axis
p=h^2/\[Tau] 

-d Subscript[u, n,i-1]-d Subscript[u, n,j-1]+Subscript[u, n,i](2p +4d+2h^2k)-d Subscript[u, n,i+1]-d Subscript[u, n,j+1]  =   d Subscript[u, n-1,i-1]+d Subscript[u, n-1,j-1]+Subscript[u, n-1,i](2p-4d )+d Subscript[u, n-1,i+1]+d Subscript[u, n-1,j+1]  + 2h^2 s

*)


solveCNcurTimeVer2[tblLHSEq_,currentGrid_,curTime_,h_,diffConst_,gridMult_,sourceFunc_,boundaryFunctionX_,boundaryFunctionY_]:=Module[{numRows,numCols,tblRHSEq,newGrid,numericalSolution,arrEq,arrVars},


{numRows,numCols} = Dimensions[currentGrid];


tblRHSEq = Table[ 
If[i == 1,
boundaryFunctionY[1]
,
If[i== numRows,
boundaryFunctionY[numRows]
,
If[j== 1,
boundaryFunctionX[1]
,
If[j== numCols,
boundaryFunctionX[numCols]
,
(2gridMult -4diffConst)currentGrid[[i,j]] +diffConst currentGrid[[i-1,j]] +diffConst currentGrid[[i+1,j]]+diffConst currentGrid[[i,j-1]]+diffConst currentGrid[[i,j+1]]
]
]
]
]
, { i,1, numRows } ,{ j,1, numCols }];

tblRHSEq += 2h^2 sourceFunc[curTime];
arrEq = MapThread[Function[{curLHS,curRHS},curLHS==curRHS],{Flatten[tblLHSEq],Flatten[tblRHSEq]}];

arrVars = Flatten[Table[ u[i,j], { i,1, numRows } ,{ j,1, numCols }]];

numericalSolution =Solve[ arrEq, arrVars ][[1]][[All,2]];

newGrid = Partition[ numericalSolution, numCols ];


newGrid
]


iniCrankNicolsonEquations[iniGrid_,h_,deltaT_,diffConst_,decayConst_,boundaryTypefuncX_,boundaryTypefuncY_]:= Module[{tblLHSEq,arrGridsOverTime,currentGrid,gridMult,numGridPoints,numRows,numCols},

gridMult = h^2/deltaT;

{numRows,numCols} = Dimensions[iniGrid];
numGridPoints = numRows*numCols;

tblLHSEq = Table[ 
If[i == 1,
u[i,j]+If[boundaryTypefuncY[1] == gPDETypeNeumann,-u[i+1,j],0]
,
If[i== numRows,
u[i,j]+If[boundaryTypefuncY[numRows] == gPDETypeNeumann,-u[i-1,j],0]
,
If[j== 1,
u[i,j]+If[boundaryTypefuncX[1] == gPDETypeNeumann,-u[i,j+1],0]
,
If[j== numCols,
u[i,j]+If[boundaryTypefuncX[numCols] == gPDETypeNeumann,-u[i,j-1],0]
,
(2gridMult +4diffConst+2h^2decayConst)u[i,j] -diffConst u[i-1,j] -diffConst u[i+1,j]-diffConst u[i,j-1]-diffConst u[i,j+1]
]
]
]
]
, { i,1, numRows } ,{ j,1, numCols }];


tblLHSEq
]


iniCrankNicolsonEquations2[iniGrid_,h_,deltaT_,diffConst_,decayConstGrid_,boundaryTypefuncX_,boundaryTypefuncY_]:= Module[{tblLHSEq,arrGridsOverTime,currentGrid,gridMult,numRows,numCols},

gridMult = h^2/deltaT;

{numRows,numCols} = Dimensions[iniGrid];

tblLHSEq = Table[ 
If[i == 1,
u[i,j]+If[boundaryTypefuncY[1] == gPDETypeNeumann,-u[i+1,j],0]
,
If[i== numRows,
u[i,j]+If[boundaryTypefuncY[numRows] == gPDETypeNeumann,-u[i-1,j],0]
,
If[j== 1,
u[i,j]+If[boundaryTypefuncX[1] == gPDETypeNeumann,-u[i,j+1],0]
,
If[j== numCols,
u[i,j]+If[boundaryTypefuncX[numCols] == gPDETypeNeumann,-u[i,j-1],0]
,
(2gridMult +4diffConst+2h^2decayConstGrid[[i,j]])u[i,j] -diffConst u[i-1,j] -diffConst u[i+1,j]-diffConst u[i,j-1]-diffConst u[i,j+1]
]
]
]
]
, { i,1, numRows } ,{ j,1, numCols }];


tblLHSEq
]


iniCrankNicolsonEquations3[iniGrid_,h_,deltaT_,diffConstGrid_,decayConstGrid_,boundaryTypefuncX_,boundaryTypefuncY_]:= Module[{tblLHSEq,arrGridsOverTime,currentGrid,gridMult,numRows,numCols},

gridMult = h^2/deltaT;

{numRows,numCols} = Dimensions[iniGrid];

tblLHSEq = Table[ 
If[i == 1,
u[i,j]+If[boundaryTypefuncY[1] == gPDETypeNeumann,-u[i+1,j],0]
,
If[i== numRows,
u[i,j]+If[boundaryTypefuncY[numRows] == gPDETypeNeumann,-u[i-1,j],0]
,
If[j== 1,
u[i,j]+If[boundaryTypefuncX[1] == gPDETypeNeumann,-u[i,j+1],0]
,
If[j== numCols,
u[i,j]+If[boundaryTypefuncX[numCols] == gPDETypeNeumann,-u[i,j-1],0]
,
(2gridMult +Total[Flatten[diffConstGrid[[i,j]]]]+2h^2decayConstGrid[[i,j]])u[i,j] -diffConstGrid[[i,j]][[1,1]] u[i-1,j] -diffConstGrid[[i,j]][[1,2]] u[i+1,j]-diffConstGrid[[i,j]][[2,1]] u[i,j-1]-diffConstGrid[[i,j]][[2,2]] u[i,j+1]
]
]
]
]
, { i,1, numRows } ,{ j,1, numCols }];


tblLHSEq
]


Options[pdeCrankNicolsonOneStep] = {pdeCNSolveOption-> 1}


pdeCrankNicolsonOneStep[tblLHSEq_,currentGrid_,h_,deltaT_,diffConst_,decayConst_,inSourceGrid_,boundaryFunctionX_,boundaryFunctionY_,opt___?OptionQ]:=Module[{curpdeCNSolveOption,gridMult,numRows,numCols,tblRHSEq,newGrid,numericalSolution,arrEq,arrVars,arrVarsAndIni},

curpdeCNSolveOption = pdeCNSolveOption/.{opt}/.Options[pdeCrankNicolsonOneStep];

gridMult = h^2/deltaT;

{numRows,numCols} = Dimensions[currentGrid];

tblRHSEq = Table[ 
If[i == 1 || i== numRows || j== 1 || j== numCols,
0
,
(2gridMult -4diffConst)currentGrid[[i,j]] +diffConst currentGrid[[i-1,j]] +diffConst currentGrid[[i+1,j]]+diffConst currentGrid[[i,j-1]]+diffConst currentGrid[[i,j+1]]
]
, { i,1, numRows } ,{ j,1, numCols }];

tblRHSEq += 2h^2 inSourceGrid;

tblRHSEq[[1]] = Table[boundaryFunctionY[1],{i,1,numCols}];
tblRHSEq[[All,1]] = Table[boundaryFunctionX[1],{i,1,numRows}];
tblRHSEq[[numRows]] = Table[boundaryFunctionY[numRows],{i,1,numCols}];
tblRHSEq[[All,numCols]] = Table[boundaryFunctionX[numCols],{i,1,numRows}];

arrEq = MapThread[Function[{curLHS,curRHS},curLHS==curRHS],{Flatten[tblLHSEq],Flatten[tblRHSEq]}];

arrVars = Table[ u[i,j], { i,1, numRows } ,{ j,1, numCols }];

If[curpdeCNSolveOption == 1,
numericalSolution =Solve[ arrEq, Flatten[arrVars] ][[1]][[All,2]];
,
(*curpdeCNSolveOption == 2*)
arrVarsAndIni = Flatten[MapThread[Function[{rowVars,rowVals},Transpose[{rowVars,rowVals}]],{arrVars,currentGrid}],1];

numericalSolution = FindRoot[arrEq,arrVarsAndIni][[All,2]];
];

newGrid = Partition[ numericalSolution, numCols ];


newGrid
]


pdeCrankNicolsonOneStep3[tblLHSEq_,currentGrid_,h_,deltaT_,diffConstGrid_,decayConstGrid_,inSourceGrid_,boundaryFunctionX_,boundaryFunctionY_,opt___?OptionQ]:=Module[{curpdeCNSolveOption,gridMult,numRows,numCols,tblRHSEq,newGrid,numericalSolution,arrEq,arrVars,arrVarsAndIni},

curpdeCNSolveOption = pdeCNSolveOption/.{opt}/.Options[pdeCrankNicolsonOneStep];

gridMult = h^2/deltaT;

{numRows,numCols} = Dimensions[currentGrid];

tblRHSEq = Table[ 
If[i == 1 || i== numRows || j== 1 || j== numCols,
0
,
(2gridMult -Total[Flatten[diffConstGrid[[i,j]]]])currentGrid[[i,j]] +diffConstGrid[[i,j]][[1,1]] currentGrid[[i-1,j]] +diffConstGrid[[i,j]][[1,2]] currentGrid[[i+1,j]]+diffConstGrid[[i,j]][[2,1]] currentGrid[[i,j-1]]+diffConstGrid[[i,j]][[2,2]] currentGrid[[i,j+1]]
]
, { i,1, numRows } ,{ j,1, numCols }];

tblRHSEq += 2h^2 inSourceGrid;

tblRHSEq[[1]] = Table[boundaryFunctionY[1],{i,1,numCols}];
tblRHSEq[[All,1]] = Table[boundaryFunctionX[1],{i,1,numRows}];
tblRHSEq[[numRows]] = Table[boundaryFunctionY[numRows],{i,1,numCols}];
tblRHSEq[[All,numCols]] = Table[boundaryFunctionX[numCols],{i,1,numRows}];

arrEq = MapThread[Function[{curLHS,curRHS},curLHS==curRHS],{Flatten[tblLHSEq],Flatten[tblRHSEq]}];

arrVars = Table[ u[i,j], { i,1, numRows } ,{ j,1, numCols }];

If[curpdeCNSolveOption == 1,
numericalSolution =Solve[ arrEq, Flatten[arrVars] ][[1]][[All,2]];
,
(*curpdeCNSolveOption == 2*)
arrVarsAndIni = Flatten[MapThread[Function[{rowVars,rowVals},Transpose[{rowVars,rowVals}]],{arrVars,currentGrid}],1];

numericalSolution = FindRoot[arrEq,arrVarsAndIni][[All,2]];
];

newGrid = Partition[ numericalSolution, numCols ];


newGrid
]


EndPackage[]


$ContextPath


Context[]
